var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"DCDC_Buck","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"DCDC_Buck.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"xcp.h\"\r\n#include \"ext_mode.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n  enableTimer0Interrupt();\r\n  DCDC_Buck_step();\r\n\r\n  /* Get model outputs here */\r\n  disableTimer0Interrupt();\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 5.0E-6;\r\n  float systemClock = 150;\r\n  extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  c2000_flash_init();\r\n  init_board();\r\n\r\n#ifdef MW_EXEC_PROFILER_ON\r\n\r\n  config_profilerTimer();\r\n\r\n#endif\r\n\r\n  ;\r\n  rtmSetErrorStatus(DCDC_Buck_M, 0);\r\n\r\n  /* Set Final Simulation Time in Ticks */\r\n  errorCode = extmodeSetFinalSimulationTime((extmodeSimulationTime_T) -1);\r\n\r\n  /* Parse External Mode command line arguments */\r\n  errorCode = extmodeParseArgs(0, NULL);\r\n  if (errorCode != EXTMODE_SUCCESS) {\r\n    return (errorCode);\r\n  }\r\n\r\n  DCDC_Buck_initialize();\r\n  globalInterruptDisable();\r\n  globalInterruptEnable();\r\n\r\n  /* External Mode initialization */\r\n  errorCode = extmodeInit(DCDC_Buck_M->extModeInfo, &rtmGetTFinal(DCDC_Buck_M));\r\n  if (errorCode != EXTMODE_SUCCESS) {\r\n    /* Code to handle External Mode initialization errors\r\n       may be added here */\r\n  }\r\n\r\n  if (errorCode == EXTMODE_SUCCESS) {\r\n    /* Wait until a Start or Stop Request has been received from the Host */\r\n    extmodeWaitForHostRequest(EXTMODE_WAIT_FOREVER);\r\n    if (extmodeStopRequested()) {\r\n      rtmSetStopRequested(DCDC_Buck_M, true);\r\n    }\r\n  }\r\n\r\n  globalInterruptDisable();\r\n  configureTimer0(modelBaseRate, systemClock);\r\n  runModel =\r\n    !extmodeSimulationComplete() && !extmodeStopRequested();\r\n  enableTimer0Interrupt();\r\n  globalInterruptEnable();\r\n  while (runModel) {\r\n    /* Run External Mode background activities */\r\n    errorCode = extmodeBackgroundRun();\r\n    if (errorCode != EXTMODE_SUCCESS) {\r\n      /* Code to handle External Mode background task errors\r\n         may be added here */\r\n    }\r\n\r\n    stopRequested = !(\r\n                      !extmodeSimulationComplete() && !extmodeStopRequested());\r\n    runModel = !(stopRequested);\r\n    if (stopRequested)\r\n      disableTimer0Interrupt();\r\n  }\r\n\r\n  /* Terminate model */\r\n  DCDC_Buck_terminate();\r\n\r\n  /* External Mode reset */\r\n  extmodeReset();\r\n  globalInterruptDisable();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCDC_Buck.c","type":"source","group":"model","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: DCDC_Buck.c\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"DCDC_Buck.h\"\r\n#include \"DCDC_Buck_private.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_DCDC_Buck_T DCDC_Buck_B;\r\n\r\n/* Continuous states */\r\nX_DCDC_Buck_T DCDC_Buck_X;\r\n\r\n/* Block states (default storage) */\r\nDW_DCDC_Buck_T DCDC_Buck_DW;\r\n\r\n/* Mass Matrices */\r\nMassMatrix_DCDC_Buck_T DCDC_Buck_MassMatrix;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_DCDC_Buck_T DCDC_Buck_M_;\r\nRT_MODEL_DCDC_Buck_T *const DCDC_Buck_M = &DCDC_Buck_M_;\r\n\r\n/* ForcingFunction for root system: '<Root>' */\r\nvoid DCDC_Buck_forcingfunction(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n  NeuDiagnosticTree *diagnosticTree;\r\n  XDot_DCDC_Buck_T *_rtXdot;\r\n  char *msg;\r\n  real_T tmp_1[16];\r\n  real_T time;\r\n  int32_T tmp_3;\r\n  int_T tmp_2[5];\r\n  boolean_T tmp;\r\n  boolean_T tmp_0;\r\n  _rtXdot = ((XDot_DCDC_Buck_T *) DCDC_Buck_M->derivs);\r\n\r\n  /* ForcingFunction for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n  simulationData = (NeslSimulationData *)DCDC_Buck_DW.STATE_1_SimData;\r\n  time = DCDC_Buck_M->Timing.t[0];\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time;\r\n  simulationData->mData->mContStates.mN = 31;\r\n  simulationData->mData->mContStates.mX =\r\n    &DCDC_Buck_X.DCDC_BuckDC_DC_Buck_PLANTDC_DC_[0];\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &DCDC_Buck_DW.STATE_1_Discrete;\r\n  simulationData->mData->mModeVector.mN = 11;\r\n  simulationData->mData->mModeVector.mX = (int32_T *)\r\n    &DCDC_Buck_DW.STATE_1_Modes[0];\r\n  tmp = false;\r\n  simulationData->mData->mFoundZcEvents = tmp;\r\n  tmp = rtmIsMajorTimeStep(DCDC_Buck_M);\r\n  simulationData->mData->mIsMajorTimeStep = tmp;\r\n  tmp_0 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  tmp_0 = rtsiIsSolverComputingJacobian(&DCDC_Buck_M->solverInfo);\r\n  simulationData->mData->mIsComputingJacobian = tmp_0;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n  tmp_2[0] = 0;\r\n  tmp_1[0] = DCDC_Buck_B.INPUT_1_1_1[0];\r\n  tmp_1[1] = DCDC_Buck_B.INPUT_1_1_1[1];\r\n  tmp_1[2] = DCDC_Buck_B.INPUT_1_1_1[2];\r\n  tmp_1[3] = DCDC_Buck_B.INPUT_1_1_1[3];\r\n  tmp_2[1] = 4;\r\n  tmp_1[4] = DCDC_Buck_B.INPUT_3_1_1[0];\r\n  tmp_1[5] = DCDC_Buck_B.INPUT_3_1_1[1];\r\n  tmp_1[6] = DCDC_Buck_B.INPUT_3_1_1[2];\r\n  tmp_1[7] = DCDC_Buck_B.INPUT_3_1_1[3];\r\n  tmp_2[2] = 8;\r\n  tmp_1[8] = DCDC_Buck_B.INPUT_2_1_1[0];\r\n  tmp_1[9] = DCDC_Buck_B.INPUT_2_1_1[1];\r\n  tmp_1[10] = DCDC_Buck_B.INPUT_2_1_1[2];\r\n  tmp_1[11] = DCDC_Buck_B.INPUT_2_1_1[3];\r\n  tmp_2[3] = 12;\r\n  tmp_1[12] = DCDC_Buck_B.INPUT_4_1_1[0];\r\n  tmp_1[13] = DCDC_Buck_B.INPUT_4_1_1[1];\r\n  tmp_1[14] = DCDC_Buck_B.INPUT_4_1_1[2];\r\n  tmp_1[15] = DCDC_Buck_B.INPUT_4_1_1[3];\r\n  tmp_2[4] = 16;\r\n  simulationData->mData->mInputValues.mN = 16;\r\n  simulationData->mData->mInputValues.mX = &tmp_1[0];\r\n  simulationData->mData->mInputOffsets.mN = 5;\r\n  simulationData->mData->mInputOffsets.mX = (int32_T *)&tmp_2[0];\r\n  simulationData->mData->mDx.mN = 31;\r\n  simulationData->mData->mDx.mX = &_rtXdot->DCDC_BuckDC_DC_Buck_PLANTDC_DC_[0];\r\n  diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.STATE_1_DiagMgr;\r\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  tmp_3 = ne_simulator_method((NeslSimulator *)DCDC_Buck_DW.STATE_1_Simulator,\r\n    NESL_SIM_FORCINGFUNCTION, simulationData, diagnosticManager);\r\n  if (tmp_3 != 0L) {\r\n    tmp = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n    if (tmp) {\r\n      msg = rtw_diagnostics_msg(diagnosticTree);\r\n      rtmSetErrorStatus(DCDC_Buck_M, msg);\r\n    }\r\n  }\r\n\r\n  /* End of ForcingFunction for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n}\r\n\r\n/* MassMatrix for root system: '<Root>' */\r\nvoid DCDC_Buck_massmatrix(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n  NeuDiagnosticTree *diagnosticTree;\r\n  char *msg;\r\n  real_T tmp_1[16];\r\n  real_T time;\r\n  real_T *tmp_3;\r\n  real_T *tmp_4;\r\n  int32_T tmp_5;\r\n  int_T tmp_2[5];\r\n  boolean_T tmp;\r\n  boolean_T tmp_0;\r\n\r\n  /* MassMatrix for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n  simulationData = (NeslSimulationData *)DCDC_Buck_DW.STATE_1_SimData;\r\n  time = DCDC_Buck_M->Timing.t[0];\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time;\r\n  simulationData->mData->mContStates.mN = 31;\r\n  simulationData->mData->mContStates.mX =\r\n    &DCDC_Buck_X.DCDC_BuckDC_DC_Buck_PLANTDC_DC_[0];\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &DCDC_Buck_DW.STATE_1_Discrete;\r\n  simulationData->mData->mModeVector.mN = 11;\r\n  simulationData->mData->mModeVector.mX = (int32_T *)\r\n    &DCDC_Buck_DW.STATE_1_Modes[0];\r\n  tmp = false;\r\n  simulationData->mData->mFoundZcEvents = tmp;\r\n  tmp = rtmIsMajorTimeStep(DCDC_Buck_M);\r\n  simulationData->mData->mIsMajorTimeStep = tmp;\r\n  tmp_0 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  tmp_0 = rtsiIsSolverComputingJacobian(&DCDC_Buck_M->solverInfo);\r\n  simulationData->mData->mIsComputingJacobian = tmp_0;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n  tmp_2[0] = 0;\r\n  tmp_1[0] = DCDC_Buck_B.INPUT_1_1_1[0];\r\n  tmp_1[1] = DCDC_Buck_B.INPUT_1_1_1[1];\r\n  tmp_1[2] = DCDC_Buck_B.INPUT_1_1_1[2];\r\n  tmp_1[3] = DCDC_Buck_B.INPUT_1_1_1[3];\r\n  tmp_2[1] = 4;\r\n  tmp_1[4] = DCDC_Buck_B.INPUT_3_1_1[0];\r\n  tmp_1[5] = DCDC_Buck_B.INPUT_3_1_1[1];\r\n  tmp_1[6] = DCDC_Buck_B.INPUT_3_1_1[2];\r\n  tmp_1[7] = DCDC_Buck_B.INPUT_3_1_1[3];\r\n  tmp_2[2] = 8;\r\n  tmp_1[8] = DCDC_Buck_B.INPUT_2_1_1[0];\r\n  tmp_1[9] = DCDC_Buck_B.INPUT_2_1_1[1];\r\n  tmp_1[10] = DCDC_Buck_B.INPUT_2_1_1[2];\r\n  tmp_1[11] = DCDC_Buck_B.INPUT_2_1_1[3];\r\n  tmp_2[3] = 12;\r\n  tmp_1[12] = DCDC_Buck_B.INPUT_4_1_1[0];\r\n  tmp_1[13] = DCDC_Buck_B.INPUT_4_1_1[1];\r\n  tmp_1[14] = DCDC_Buck_B.INPUT_4_1_1[2];\r\n  tmp_1[15] = DCDC_Buck_B.INPUT_4_1_1[3];\r\n  tmp_2[4] = 16;\r\n  simulationData->mData->mInputValues.mN = 16;\r\n  simulationData->mData->mInputValues.mX = &tmp_1[0];\r\n  simulationData->mData->mInputOffsets.mN = 5;\r\n  simulationData->mData->mInputOffsets.mX = (int32_T *)&tmp_2[0];\r\n  tmp_3 = DCDC_Buck_MassMatrix.pr;\r\n  tmp_4 = double_pointer_shift(tmp_3, DCDC_Buck_DW.STATE_1_MASS_MATRIX_PR);\r\n  simulationData->mData->mMassMatrixPr.mN = 13;\r\n  simulationData->mData->mMassMatrixPr.mX = tmp_4;\r\n  diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.STATE_1_DiagMgr;\r\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  tmp_5 = ne_simulator_method((NeslSimulator *)DCDC_Buck_DW.STATE_1_Simulator,\r\n    NESL_SIM_MASSMATRIX, simulationData, diagnosticManager);\r\n  if (tmp_5 != 0L) {\r\n    tmp = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n    if (tmp) {\r\n      msg = rtw_diagnostics_msg(diagnosticTree);\r\n      rtmSetErrorStatus(DCDC_Buck_M, msg);\r\n    }\r\n  }\r\n\r\n  /* End of MassMatrix for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n}\r\n\r\nvoid local_evaluateMassMatrix(RTWSolverInfo *si, real_T *Mdest )\r\n{\r\n  /* Refresh global mass matrix */\r\n  DCDC_Buck_massmatrix();\r\n\r\n  /* Copy the mass matrix from system to the destination, if needed. */\r\n  if (Mdest != rtsiGetSolverMassMatrixPr(si)) {\r\n    real_T *Msrc = rtsiGetSolverMassMatrixPr(si);\r\n    int_T nzmax = rtsiGetSolverMassMatrixNzMax(si);\r\n    (void) memcpy(Mdest, Msrc,\r\n                  (uint_T)nzmax*sizeof(real_T));\r\n  }\r\n}\r\n\r\n/* Simplified version of numjac.cpp, for use with RTW. */\r\nvoid local_numjac( RTWSolverInfo *si, real_T *y, const real_T *Fty, real_T *fac,\r\n                  real_T *dFdy )\r\n{\r\n  /* constants */\r\n  real_T THRESH = 1e-6;\r\n  real_T EPS = 2.2e-16;                /* utGetEps(); */\r\n  real_T BL = pow(EPS, 0.75);\r\n  real_T BU = pow(EPS, 0.25);\r\n  real_T FACMIN = pow(EPS, 0.78);\r\n  real_T FACMAX = 0.1;\r\n  int_T nx = 31;\r\n  real_T *x = rtsiGetContStates(si);\r\n  real_T del;\r\n  real_T difmax;\r\n  real_T FdelRowmax;\r\n  real_T temp;\r\n  real_T Fdiff;\r\n  real_T maybe;\r\n  real_T xscale;\r\n  real_T fscale;\r\n  real_T *p;\r\n  int_T rowmax;\r\n  int_T i,j;\r\n  if (x != y)\r\n    (void) memcpy(x, y,\r\n                  (uint_T)nx*sizeof(real_T));\r\n  rtsiSetSolverComputingJacobian(si,true);\r\n  for (p = dFdy, j = 0; j < nx; j++, p += nx) {\r\n    /* Select an increment del for a difference approximation to\r\n       column j of dFdy.  The vector fac accounts for experience\r\n       gained in previous calls to numjac. */\r\n    xscale = fabs(x[j]);\r\n    if (xscale < THRESH)\r\n      xscale = THRESH;\r\n    temp = (x[j] + fac[j]*xscale);\r\n    del = temp - y[j];\r\n    while (del == 0.0) {\r\n      if (fac[j] < FACMAX) {\r\n        fac[j] *= 100.0;\r\n        if (fac[j] > FACMAX)\r\n          fac[j] = FACMAX;\r\n        temp = (x[j] + fac[j]*xscale);\r\n        del = temp - x[j];\r\n      } else {\r\n        del = THRESH;                  /* thresh is nonzero */\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* Keep del pointing into region. */\r\n    if (Fty[j] >= 0.0)\r\n      del = fabs(del);\r\n    else\r\n      del = -fabs(del);\r\n\r\n    /* Form a difference approximation to column j of dFdy. */\r\n    temp = x[j];\r\n    x[j] += del;\r\n    DCDC_Buck_step();\r\n    rtsiSetdX(si,p);\r\n    DCDC_Buck_forcingfunction();\r\n    x[j] = temp;\r\n    difmax = 0.0;\r\n    rowmax = 0;\r\n    FdelRowmax = p[0];\r\n    temp = 1.0 / del;\r\n    for (i = 0; i < nx; i++) {\r\n      Fdiff = p[i] - Fty[i];\r\n      maybe = fabs(Fdiff);\r\n      if (maybe > difmax) {\r\n        difmax = maybe;\r\n        rowmax = i;\r\n        FdelRowmax = p[i];\r\n      }\r\n\r\n      p[i] = temp * Fdiff;\r\n    }\r\n\r\n    /* Adjust fac for next call to numjac. */\r\n    if (((FdelRowmax != 0.0) && (Fty[rowmax] != 0.0)) || (difmax == 0.0)) {\r\n      fscale = fabs(FdelRowmax);\r\n      if (fscale < fabs(Fty[rowmax]))\r\n        fscale = fabs(Fty[rowmax]);\r\n      if (difmax <= BL*fscale) {\r\n        /* The difference is small, so increase the increment. */\r\n        fac[j] *= 10.0;\r\n        if (fac[j] > FACMAX)\r\n          fac[j] = FACMAX;\r\n      } else if (difmax > BU*fscale) {\r\n        /* The difference is large, so reduce the increment. */\r\n        fac[j] *= 0.1;\r\n        if (fac[j] < FACMIN)\r\n          fac[j] = FACMIN;\r\n      }\r\n    }\r\n  }\r\n\r\n  rtsiSetSolverComputingJacobian(si,false);\r\n}                                      /* end local_numjac */\r\n\r\n/*\r\n * This function updates continuous states using the ODE14X fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  /* Solver Matrices */\r\n  static int_T rt_ODE14x_N[4] = { 12, 8, 6, 4 };\r\n\r\n  time_T t0 = rtsiGetT(si);\r\n  time_T t1 = t0;\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x1 = rtsiGetContStates(si);\r\n  int_T order = rtsiGetSolverExtrapolationOrder(si);\r\n  int_T numIter = rtsiGetSolverNumberNewtonIterations(si);\r\n  ODE14X_IntgData *id = (ODE14X_IntgData *)rtsiGetSolverData(si);\r\n  real_T *x0 = id->x0;\r\n  real_T *f0 = id->f0;\r\n  real_T *x1start = id->x1start;\r\n  real_T *f1 = id->f1;\r\n  real_T *Delta = id->Delta;\r\n  real_T *E = id->E;\r\n  real_T *fac = id->fac;\r\n  real_T *dfdx = id->DFDX;\r\n  real_T *W = id->W;\r\n  int_T *pivots = id->pivots;\r\n  real_T *xtmp = id->xtmp;\r\n  real_T *ztmp = id->ztmp;\r\n  int_T *Mpattern_ir = rtsiGetSolverMassMatrixIr(si);\r\n  int_T *Mpattern_jc = rtsiGetSolverMassMatrixJc(si);\r\n  real_T *M = id->M;\r\n  int_T col,row,rowidx;\r\n  int_T *N = &(rt_ODE14x_N[0]);\r\n  int_T i,j,k,iter;\r\n  int_T nx = 31;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(x0, x1,\r\n                (uint_T)nx*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  if (id->isFirstStep) {\r\n    local_evaluateMassMatrix(si,M );\r\n    id->isFirstStep = false;\r\n  }\r\n\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  DCDC_Buck_forcingfunction();\r\n  local_numjac(si,x0,f0,fac,dfdx );\r\n  for (j = 0; j < order; j++) {\r\n    real_T *p;\r\n    real_T hN = h/N[j];\r\n\r\n    /* Get the iteration matrix and solution at t0 */\r\n\r\n    /* [L,U] = lu(M - hN*J) */\r\n    (void) memcpy(W, dfdx,\r\n                  (uint_T)nx*nx*sizeof(real_T));\r\n    for (p = W, i = 0; i < nx*nx; i++, p++) {\r\n      *p *= (-hN);\r\n    }\r\n\r\n    for (col = 0, p = W; col < nx; col++, p += nx) {\r\n      for (rowidx = Mpattern_jc[col]; rowidx < Mpattern_jc[col+1]; rowidx++) {\r\n        real_T m_row_col = M[rowidx];\r\n        row = Mpattern_ir[rowidx];\r\n        p[row] += m_row_col;\r\n      }\r\n    }\r\n\r\n    rt_lu_real(W, nx,\r\n               pivots);\r\n\r\n    /* First Newton's iteration at t0. */\r\n    /* rhs = hN*f0 */\r\n    for (i = 0; i < nx; i++) {\r\n      Delta[i] = hN*f0[i];\r\n    }\r\n\r\n    /* Delta = (U \\ (L \\ rhs)) */\r\n    rt_ForwardSubstitutionRR_Dbl(W, Delta,\r\n      f1, nx,\r\n      1, pivots,\r\n      1);\r\n    rt_BackwardSubstitutionRR_Dbl(W+nx*nx-1, f1+nx-1,\r\n      Delta, nx,\r\n      1, 0);\r\n\r\n    /* ytmp = y0 + Delta\r\n       ztmp = (ytmp-y0)/h\r\n     */\r\n    (void) memcpy(x1, x0,\r\n                  (uint_T)nx*sizeof(real_T));\r\n    for (i = 0; i < nx; i++) {\r\n      x1[i] += Delta[i];\r\n      ztmp[i] = Delta[i]/hN;\r\n    }\r\n\r\n    /* Additional Newton's iterations, if desired.\r\n       for iter = 2:NewtIter\r\n       rhs = hN*feval(odefun,tn,ytmp,extraArgs{:}) - M*(ytmp - yn);\r\n       if statedepM   % only for state dep. Mdel ~= 0\r\n       Mdel = M - feval(massfun,tn,ytmp);\r\n       rhs = rhs + Mdel*ztmp*h;\r\n       end\r\n       Delta = ( U \\ ( L \\ rhs ) );\r\n       ytmp = ytmp + Delta;\r\n       ztmp = (ytmp - yn)/h\r\n       end\r\n     */\r\n    rtsiSetT(si, t0);\r\n    rtsiSetdX(si, f1);\r\n    for (iter = 1; iter < numIter; iter++) {\r\n      DCDC_Buck_step();\r\n      DCDC_Buck_forcingfunction();\r\n      for (i = 0; i < nx; i++) {\r\n        Delta[i] = hN*f1[i];\r\n        xtmp[i] = x1[i] - x0[i];\r\n      }\r\n\r\n      /* rhs = hN*f(tn,ytmp) - M*(ytmp-yn) */\r\n      for (col = 0; col < nx; col++) {\r\n        for (rowidx = Mpattern_jc[col]; rowidx < Mpattern_jc[col+1]; rowidx++) {\r\n          real_T m_row_col = M[rowidx];\r\n          row = Mpattern_ir[rowidx];\r\n          Delta[row] -= m_row_col*xtmp[col];\r\n        }\r\n      }\r\n\r\n      rt_ForwardSubstitutionRR_Dbl(W, Delta,\r\n        f1, nx,\r\n        1, pivots,\r\n        1);\r\n      rt_BackwardSubstitutionRR_Dbl(W+nx*nx-1, f1+nx-1,\r\n        Delta, nx,\r\n        1, 0);\r\n\r\n      /* ytmp = ytmp + delta\r\n         ztmp = (ytmp - yn)/h\r\n       */\r\n      for (i = 0; i < nx; i++) {\r\n        x1[i] += Delta[i];\r\n        ztmp[i] = (x1[i] - x0[i])/hN;\r\n      }\r\n    }\r\n\r\n    /* Steps from t0+hN to t1 -- subintegration of N(j) steps for extrapolation\r\n       ttmp = t0;\r\n       for i = 2:N(j)\r\n       ttmp = ttmp + hN\r\n       ytmp0 = ytmp;\r\n       for iter = 1:NewtIter\r\n       rhs = (ytmp0 - ytmp) + hN*feval(odefun,ttmp,ytmp,extraArgs{:});\r\n       Delta = ( U \\ ( L \\ rhs ) );\r\n       ytmp = ytmp + Delta;\r\n       end\r\n       end\r\n     */\r\n    for (k = 1; k < N[j]; k++) {\r\n      t1 = t0 + k*hN;\r\n      (void) memcpy(x1start, x1,\r\n                    (uint_T)nx*sizeof(real_T));\r\n      rtsiSetT(si, t1);\r\n      rtsiSetdX(si, f1);\r\n      for (iter = 0; iter < numIter; iter++) {\r\n        DCDC_Buck_step();\r\n        DCDC_Buck_forcingfunction();\r\n        if (iter == 0) {\r\n          for (i = 0; i < nx; i++) {\r\n            Delta[i] = hN*f1[i];\r\n          }\r\n        } else {\r\n          for (i = 0; i < nx; i++) {\r\n            Delta[i] = hN*f1[i];\r\n            xtmp[i] = (x1[i]-x1start[i]);\r\n          }\r\n\r\n          /* rhs = hN*f(tn,ytmp) - M*(ytmp-yn) */\r\n          for (col = 0; col < nx; col++) {\r\n            for (rowidx = Mpattern_jc[col]; rowidx < Mpattern_jc[col+1]; rowidx\r\n                 ++) {\r\n              real_T m_row_col = M[rowidx];\r\n              row = Mpattern_ir[rowidx];\r\n              Delta[row] -= m_row_col*xtmp[col];\r\n            }\r\n          }\r\n        }\r\n\r\n        rt_ForwardSubstitutionRR_Dbl(W, Delta,\r\n          f1, nx,\r\n          1, pivots,\r\n          1);\r\n        rt_BackwardSubstitutionRR_Dbl(W+nx*nx-1, f1+nx-1,\r\n          Delta, nx,\r\n          1, 0);\r\n\r\n        /* ytmp = ytmp + Delta\r\n           ztmp = (ytmp - ytmp0)/h\r\n         */\r\n        for (i = 0; i < nx; i++) {\r\n          x1[i] += Delta[i];\r\n          ztmp[i] = (x1[i] - x1start[i])/hN;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Extrapolate to order j\r\n       E(:,j) = ytmp\r\n       for k = j:-1:2\r\n       coef = N(k-1)/(N(j) - N(k-1))\r\n       E(:,k-1) = E(:,k) + coef*( E(:,k) - E(:,k-1) )\r\n       end\r\n     */\r\n    (void) memcpy(&(E[nx*j]), x1,\r\n                  (uint_T)nx*sizeof(real_T));\r\n    for (k = j; k > 0; k--) {\r\n      real_T coef = (real_T)(N[k-1]) / (N[j]-N[k-1]);\r\n      for (i = 0; i < nx; i++) {\r\n        x1[i] = E[nx*k+i] + coef*(E[nx*k+i] - E[nx*(k-1)+i]);\r\n      }\r\n\r\n      (void) memcpy(&(E[nx*(k-1)]), x1,\r\n                    (uint_T)nx*sizeof(real_T));\r\n    }\r\n  }\r\n\r\n  /* x1 = E(:,1); */\r\n  (void) memcpy(x1, E,\r\n                (uint_T)nx*sizeof(real_T));\r\n\r\n  /* t1 = t0 + h; */\r\n  rtsiSetT(si,rtsiGetSolverStopTime(si));\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\n/* Model step function */\r\nvoid DCDC_Buck_step(void)\r\n{\r\n  /* local block i/o variables */\r\n  int32_T rtb_IQNxIQN;\r\n  int32_T rtb_Sum2;\r\n  if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n    /* set solver stop time */\r\n    if (!(DCDC_Buck_M->Timing.clockTick0+1)) {\r\n      rtsiSetSolverStopTime(&DCDC_Buck_M->solverInfo,\r\n                            ((DCDC_Buck_M->Timing.clockTickH0 + 1) *\r\n        DCDC_Buck_M->Timing.stepSize0 * 4294967296.0));\r\n    } else {\r\n      rtsiSetSolverStopTime(&DCDC_Buck_M->solverInfo,\r\n                            ((DCDC_Buck_M->Timing.clockTick0 + 1) *\r\n        DCDC_Buck_M->Timing.stepSize0 + DCDC_Buck_M->Timing.clockTickH0 *\r\n        DCDC_Buck_M->Timing.stepSize0 * 4294967296.0));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(DCDC_Buck_M)) {\r\n    DCDC_Buck_M->Timing.t[0] = rtsiGetT(&DCDC_Buck_M->solverInfo);\r\n  }\r\n\r\n  {\r\n    NeslSimulationData *simulationData;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    NeuDiagnosticTree *diagnosticTree_0;\r\n    char *msg;\r\n    char *msg_0;\r\n    real_T tmp_3[58];\r\n    real_T tmp_1[16];\r\n    real_T Clock1_tmp;\r\n    real_T time;\r\n    real_T time_0;\r\n    int32_T rtb_Gain4;\r\n    int32_T rtb_Saturation;\r\n    int_T tmp_4[6];\r\n    int_T tmp_2[5];\r\n    boolean_T tmp;\r\n    boolean_T tmp_0;\r\n\r\n    /* Step: '<S2>/Step' */\r\n    if (DCDC_Buck_M->Timing.t[0] < DCDC_Buck_P.Step_Time) {\r\n      Clock1_tmp = DCDC_Buck_P.Step_Y0;\r\n    } else {\r\n      Clock1_tmp = DCDC_Buck_P.Step_YFinal;\r\n    }\r\n\r\n    /* End of Step: '<S2>/Step' */\r\n\r\n    /* Gain: '<S10>/Gain' */\r\n    DCDC_Buck_B.Gain = DCDC_Buck_P.Gain_Gain * Clock1_tmp;\r\n\r\n    /* SimscapeInputBlock: '<S26>/INPUT_1_1_1' */\r\n    DCDC_Buck_B.INPUT_1_1_1[0] = DCDC_Buck_B.Gain;\r\n    DCDC_Buck_B.INPUT_1_1_1[1] = 0.0;\r\n    DCDC_Buck_B.INPUT_1_1_1[2] = 0.0;\r\n    DCDC_Buck_B.INPUT_1_1_1[3] = 0.0;\r\n    if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n      /* S-Function (stiiqmath_iqmpy): '<S4>/IQN x IQN' incorporates:\r\n       *  Constant: '<S1>/Constant'\r\n       *  DataTypeConversion: '<S3>/Data Type Conversion'\r\n       *  Gain: '<S1>/VoltageScaling1'\r\n       *  Gain: '<S3>/PerUnitConvRate'\r\n       */\r\n      rtb_IQNxIQN = (int32_T)floor(DCDC_Buck_P.VSF * DCDC_Buck_P.Constant_Value *\r\n        DCDC_Buck_P.PerUnitConvRate_Gain * 1.6777216E+7);\r\n\r\n      /* DataTypeConversion: '<S3>/Data Type Conversion3' incorporates:\r\n       *  Gain: '<S3>/Gain4'\r\n       *  Gain: '<S3>/PerUnitConvRate1'\r\n       *  UnitDelay: '<S1>/Unit Delay'\r\n       */\r\n      rtb_Gain4 = (int32_T)floor(DCDC_Buck_P.PerUnitConvRate1_Gain *\r\n        DCDC_Buck_DW.UnitDelay_DSTATE * 1.6777216E+7);\r\n\r\n      /* Sum: '<S4>/Sum' incorporates:\r\n       *  Gain: '<S3>/Gain4'\r\n       *  S-Function (stiiqmath_iqmpy): '<S4>/IQN x IQN'\r\n       *  Saturate: '<S4>/Saturation'\r\n       */\r\n      rtb_Saturation = rtb_IQNxIQN - rtb_Gain4;\r\n\r\n      /* DataTypeConversion: '<S3>/Data Type Conversion1' incorporates:\r\n       *  Constant: '<S1>/Constant1'\r\n       *  Gain: '<S3>/Gain4'\r\n       */\r\n      rtb_Gain4 = (int32_T)floor(DCDC_Buck_P.Constant1_Value * 1.6777216E+7);\r\n\r\n      /* S-Function (stiiqmath_iqmpy): '<S4>/IQN x IQN' */\r\n\r\n      /* C28x IQmath Library (stiiqmath_iqmpy) - '<S4>/IQN x IQN' */\r\n      {\r\n        rtb_IQNxIQN = _IQ24mpy (rtb_Saturation, rtb_Gain4);\r\n      }\r\n\r\n      /* Switch: '<S6>/Switch' incorporates:\r\n       *  Constant: '<S1>/Constant2'\r\n       *  Constant: '<S6>/Constant'\r\n       *  Constant: '<S7>/Constant'\r\n       *  Constant: '<S8>/Constant'\r\n       *  DataTypeConversion: '<S3>/Data Type Conversion2'\r\n       *  DataTypeConversion: '<S4>/Subsystem_boundary_DTC'\r\n       *  Gain: '<S3>/Gain4'\r\n       *  Logic: '<S6>/Logical Operator'\r\n       *  RelationalOperator: '<S6>/Relational Operator1'\r\n       *  RelationalOperator: '<S7>/Compare'\r\n       *  RelationalOperator: '<S8>/Compare'\r\n       *  Saturate: '<S4>/Saturation'\r\n       *  UnitDelay: '<S6>/Unit Delay'\r\n       *  UnitDelay: '<S6>/Unit Delay1'\r\n       */\r\n      if (DCDC_Buck_DW.UnitDelay1_DSTATE || (((real32_T)rtb_Saturation *\r\n            5.96046448E-8F <= DCDC_Buck_P.CompareToConstant1_const) !=\r\n           (DCDC_Buck_DW.UnitDelay_DSTATE_b <=\r\n            DCDC_Buck_P.CompareToConstant_const))) {\r\n        rtb_Gain4 = (int32_T)floor(DCDC_Buck_P.Constant2_Value * 1.6777216E+7);\r\n      } else {\r\n        rtb_Gain4 = DCDC_Buck_P.Constant_Value_f;\r\n      }\r\n\r\n      /* End of Switch: '<S6>/Switch' */\r\n\r\n      /* S-Function (stiiqmath_iqmpy): '<S4>/IQN x IQN1' */\r\n\r\n      /* C28x IQmath Library (stiiqmath_iqmpy) - '<S4>/IQN x IQN1' */\r\n      {\r\n        rtb_Sum2 = _IQ24mpy (rtb_Saturation, rtb_Gain4);\r\n      }\r\n\r\n      /* Sum: '<S4>/Sum1' incorporates:\r\n       *  Sum: '<S4>/Sum2'\r\n       *  UnitDelay: '<S4>/Unit Delay'\r\n       */\r\n      DCDC_Buck_DW.UnitDelay_DSTATE_m += rtb_Sum2;\r\n\r\n      /* Sum: '<S4>/Sum2' incorporates:\r\n       *  S-Function (stiiqmath_iqmpy): '<S4>/IQN x IQN'\r\n       *  Sum: '<S4>/Sum1'\r\n       *  UnitDelay: '<S4>/Unit Delay'\r\n       */\r\n      rtb_Sum2 = rtb_IQNxIQN + DCDC_Buck_DW.UnitDelay_DSTATE_m;\r\n\r\n      /* Saturate: '<S4>/Saturation' incorporates:\r\n       *  Sum: '<S4>/Sum2'\r\n       */\r\n      if (rtb_Sum2 > DCDC_Buck_P.Saturation_UpperSat) {\r\n        rtb_Saturation = DCDC_Buck_P.Saturation_UpperSat;\r\n      } else if (rtb_Sum2 < DCDC_Buck_P.Saturation_LowerSat) {\r\n        rtb_Saturation = DCDC_Buck_P.Saturation_LowerSat;\r\n      } else {\r\n        rtb_Saturation = rtb_Sum2;\r\n      }\r\n\r\n      /* End of Saturate: '<S4>/Saturation' */\r\n\r\n      /* Gain: '<S3>/Gain4' incorporates:\r\n       *  DataTypeConversion: '<S3>/Data Type Conversion6'\r\n       *  Saturate: '<S4>/Saturation'\r\n       */\r\n      rtb_Gain4 = (int32_T)((real_T)rtb_Saturation * 5.9604644775390625E-8 *\r\n                            (real_T)DCDC_Buck_P.Gain4_Gain * 1.048576E+6);\r\n\r\n      /* Gain: '<S5>/Inverse TBPRD' incorporates:\r\n       *  DataTypeConversion: '<S5>/Data Type Conversion3'\r\n       *  Gain: '<S3>/Gain4'\r\n       */\r\n      DCDC_Buck_B.Duty = (real_T)rtb_Gain4 * 9.5367431640625E-7 *\r\n        DCDC_Buck_P.InverseTBPRD_Gain;\r\n\r\n      /* Constant: '<S9>/Time_Period' */\r\n      DCDC_Buck_B.Time_Period = DCDC_Buck_P.Tpwm;\r\n    }\r\n\r\n    /* Clock: '<S9>/Clock1' incorporates:\r\n     *  SimscapeExecutionBlock: '<S26>/OUTPUT_1_0'\r\n     *  SimscapeExecutionBlock: '<S26>/STATE_1'\r\n     */\r\n    Clock1_tmp = DCDC_Buck_M->Timing.t[0];\r\n\r\n    /* Clock: '<S9>/Clock1' */\r\n    DCDC_Buck_B.Clock1 = Clock1_tmp;\r\n\r\n    /* Math: '<S9>/Math Function2' */\r\n    DCDC_Buck_B.MathFunction2 = fmod(DCDC_Buck_B.Clock1, DCDC_Buck_B.Time_Period);\r\n\r\n    /* Gain: '<S9>/Gain1' */\r\n    DCDC_Buck_B.Gain1 = DCDC_Buck_P.FPWM * DCDC_Buck_B.MathFunction2;\r\n\r\n    /* DataTypeConversion: '<S5>/Data Type Conversion1' incorporates:\r\n     *  RelationalOperator: '<S5>/Relational Operator'\r\n     */\r\n    DCDC_Buck_B.DataTypeConversion1 = (DCDC_Buck_B.Duty >= DCDC_Buck_B.Gain1);\r\n\r\n    /* Gain: '<S3>/Gain6' */\r\n    DCDC_Buck_B.Gain6 = DCDC_Buck_P.Gain6_Gain * DCDC_Buck_B.DataTypeConversion1;\r\n\r\n    /* SimscapeInputBlock: '<S26>/INPUT_3_1_1' */\r\n    DCDC_Buck_B.INPUT_3_1_1[0] = DCDC_Buck_B.Gain6;\r\n    DCDC_Buck_B.INPUT_3_1_1[1] = 0.0;\r\n    DCDC_Buck_B.INPUT_3_1_1[2] = 0.0;\r\n    DCDC_Buck_B.INPUT_3_1_1[3] = 0.0;\r\n\r\n    /* SimscapeInputBlock: '<S26>/INPUT_2_1_1' */\r\n    DCDC_Buck_B.INPUT_2_1_1[0] = DCDC_Buck_B.Gain6;\r\n    DCDC_Buck_B.INPUT_2_1_1[1] = 0.0;\r\n    DCDC_Buck_B.INPUT_2_1_1[2] = 0.0;\r\n    DCDC_Buck_B.INPUT_2_1_1[3] = 0.0;\r\n\r\n    /* SimscapeInputBlock: '<S26>/INPUT_4_1_1' */\r\n    DCDC_Buck_B.INPUT_4_1_1[0] = DCDC_Buck_B.Gain6;\r\n    DCDC_Buck_B.INPUT_4_1_1[1] = 0.0;\r\n    DCDC_Buck_B.INPUT_4_1_1[2] = 0.0;\r\n    DCDC_Buck_B.INPUT_4_1_1[3] = 0.0;\r\n\r\n    /* SimscapeExecutionBlock: '<S26>/STATE_1' incorporates:\r\n     *  SimscapeExecutionBlock: '<S26>/OUTPUT_1_0'\r\n     */\r\n    simulationData = (NeslSimulationData *)DCDC_Buck_DW.STATE_1_SimData;\r\n    time = Clock1_tmp;\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time;\r\n    simulationData->mData->mContStates.mN = 31;\r\n    simulationData->mData->mContStates.mX =\r\n      &DCDC_Buck_X.DCDC_BuckDC_DC_Buck_PLANTDC_DC_[0];\r\n    simulationData->mData->mDiscStates.mN = 0;\r\n    simulationData->mData->mDiscStates.mX = &DCDC_Buck_DW.STATE_1_Discrete;\r\n    simulationData->mData->mModeVector.mN = 11;\r\n    simulationData->mData->mModeVector.mX = (int32_T *)\r\n      &DCDC_Buck_DW.STATE_1_Modes[0];\r\n    tmp = false;\r\n    simulationData->mData->mFoundZcEvents = tmp;\r\n    tmp = rtmIsMajorTimeStep(DCDC_Buck_M);\r\n    simulationData->mData->mIsMajorTimeStep = tmp;\r\n    tmp_0 = false;\r\n    simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n    simulationData->mData->mIsSolverCheckingCIC = false;\r\n    tmp_0 = rtsiIsSolverComputingJacobian(&DCDC_Buck_M->solverInfo);\r\n    simulationData->mData->mIsComputingJacobian = tmp_0;\r\n    simulationData->mData->mIsEvaluatingF0 = false;\r\n    simulationData->mData->mIsSolverRequestingReset = false;\r\n    simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n    tmp_2[0] = 0;\r\n    tmp_1[0] = DCDC_Buck_B.INPUT_1_1_1[0];\r\n    tmp_1[1] = DCDC_Buck_B.INPUT_1_1_1[1];\r\n    tmp_1[2] = DCDC_Buck_B.INPUT_1_1_1[2];\r\n    tmp_1[3] = DCDC_Buck_B.INPUT_1_1_1[3];\r\n    tmp_2[1] = 4;\r\n    tmp_1[4] = DCDC_Buck_B.INPUT_3_1_1[0];\r\n    tmp_1[5] = DCDC_Buck_B.INPUT_3_1_1[1];\r\n    tmp_1[6] = DCDC_Buck_B.INPUT_3_1_1[2];\r\n    tmp_1[7] = DCDC_Buck_B.INPUT_3_1_1[3];\r\n    tmp_2[2] = 8;\r\n    tmp_1[8] = DCDC_Buck_B.INPUT_2_1_1[0];\r\n    tmp_1[9] = DCDC_Buck_B.INPUT_2_1_1[1];\r\n    tmp_1[10] = DCDC_Buck_B.INPUT_2_1_1[2];\r\n    tmp_1[11] = DCDC_Buck_B.INPUT_2_1_1[3];\r\n    tmp_2[3] = 12;\r\n    tmp_1[12] = DCDC_Buck_B.INPUT_4_1_1[0];\r\n    tmp_1[13] = DCDC_Buck_B.INPUT_4_1_1[1];\r\n    tmp_1[14] = DCDC_Buck_B.INPUT_4_1_1[2];\r\n    tmp_1[15] = DCDC_Buck_B.INPUT_4_1_1[3];\r\n    tmp_2[4] = 16;\r\n    simulationData->mData->mInputValues.mN = 16;\r\n    simulationData->mData->mInputValues.mX = &tmp_1[0];\r\n    simulationData->mData->mInputOffsets.mN = 5;\r\n    simulationData->mData->mInputOffsets.mX = (int32_T *)&tmp_2[0];\r\n    simulationData->mData->mOutputs.mN = 42;\r\n    simulationData->mData->mOutputs.mX = &DCDC_Buck_B.STATE_1[0];\r\n    simulationData->mData->mSampleHits.mN = 0;\r\n    simulationData->mData->mSampleHits.mX = NULL;\r\n    simulationData->mData->mIsFundamentalSampleHit = false;\r\n    simulationData->mData->mTolerances.mN = 0;\r\n    simulationData->mData->mTolerances.mX = NULL;\r\n    simulationData->mData->mCstateHasChanged = false;\r\n    diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    rtb_Gain4 = ne_simulator_method((NeslSimulator *)\r\n      DCDC_Buck_DW.STATE_1_Simulator, NESL_SIM_OUTPUTS, simulationData,\r\n      diagnosticManager);\r\n    if (rtb_Gain4 != 0L) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n      if (tmp_0) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(DCDC_Buck_M, msg);\r\n      }\r\n    }\r\n\r\n    /* SimscapeExecutionBlock: '<S26>/OUTPUT_1_0' */\r\n    simulationData = (NeslSimulationData *)DCDC_Buck_DW.OUTPUT_1_0_SimData;\r\n    time_0 = Clock1_tmp;\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time_0;\r\n    simulationData->mData->mContStates.mN = 0;\r\n    simulationData->mData->mContStates.mX = NULL;\r\n    simulationData->mData->mDiscStates.mN = 0;\r\n    simulationData->mData->mDiscStates.mX = &DCDC_Buck_DW.OUTPUT_1_0_Discrete;\r\n    simulationData->mData->mModeVector.mN = 0;\r\n    simulationData->mData->mModeVector.mX = (int32_T *)\r\n      &DCDC_Buck_DW.OUTPUT_1_0_Modes;\r\n    tmp_0 = false;\r\n    simulationData->mData->mFoundZcEvents = tmp_0;\r\n    simulationData->mData->mIsMajorTimeStep = tmp;\r\n    tmp_0 = false;\r\n    simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n    simulationData->mData->mIsSolverCheckingCIC = false;\r\n    simulationData->mData->mIsComputingJacobian = false;\r\n    simulationData->mData->mIsEvaluatingF0 = false;\r\n    simulationData->mData->mIsSolverRequestingReset = false;\r\n    simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n    tmp_4[0] = 0;\r\n    tmp_3[0] = DCDC_Buck_B.INPUT_1_1_1[0];\r\n    tmp_3[1] = DCDC_Buck_B.INPUT_1_1_1[1];\r\n    tmp_3[2] = DCDC_Buck_B.INPUT_1_1_1[2];\r\n    tmp_3[3] = DCDC_Buck_B.INPUT_1_1_1[3];\r\n    tmp_4[1] = 4;\r\n    tmp_3[4] = DCDC_Buck_B.INPUT_3_1_1[0];\r\n    tmp_3[5] = DCDC_Buck_B.INPUT_3_1_1[1];\r\n    tmp_3[6] = DCDC_Buck_B.INPUT_3_1_1[2];\r\n    tmp_3[7] = DCDC_Buck_B.INPUT_3_1_1[3];\r\n    tmp_4[2] = 8;\r\n    tmp_3[8] = DCDC_Buck_B.INPUT_2_1_1[0];\r\n    tmp_3[9] = DCDC_Buck_B.INPUT_2_1_1[1];\r\n    tmp_3[10] = DCDC_Buck_B.INPUT_2_1_1[2];\r\n    tmp_3[11] = DCDC_Buck_B.INPUT_2_1_1[3];\r\n    tmp_4[3] = 12;\r\n    tmp_3[12] = DCDC_Buck_B.INPUT_4_1_1[0];\r\n    tmp_3[13] = DCDC_Buck_B.INPUT_4_1_1[1];\r\n    tmp_3[14] = DCDC_Buck_B.INPUT_4_1_1[2];\r\n    tmp_3[15] = DCDC_Buck_B.INPUT_4_1_1[3];\r\n    tmp_4[4] = 16;\r\n    memcpy(&tmp_3[16], &DCDC_Buck_B.STATE_1[0], 42U * sizeof(real_T));\r\n    tmp_4[5] = 58;\r\n    simulationData->mData->mInputValues.mN = 58;\r\n    simulationData->mData->mInputValues.mX = &tmp_3[0];\r\n    simulationData->mData->mInputOffsets.mN = 6;\r\n    simulationData->mData->mInputOffsets.mX = (int32_T *)&tmp_4[0];\r\n    simulationData->mData->mOutputs.mN = 2;\r\n    simulationData->mData->mOutputs.mX = &DCDC_Buck_B.OUTPUT_1_0[0];\r\n    simulationData->mData->mSampleHits.mN = 0;\r\n    simulationData->mData->mSampleHits.mX = NULL;\r\n    simulationData->mData->mIsFundamentalSampleHit = false;\r\n    simulationData->mData->mTolerances.mN = 0;\r\n    simulationData->mData->mTolerances.mX = NULL;\r\n    simulationData->mData->mCstateHasChanged = false;\r\n    diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.OUTPUT_1_0_DiagMgr;\r\n    diagnosticTree_0 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    rtb_Gain4 = ne_simulator_method((NeslSimulator *)\r\n      DCDC_Buck_DW.OUTPUT_1_0_Simulator, NESL_SIM_OUTPUTS, simulationData,\r\n      diagnosticManager);\r\n    if (rtb_Gain4 != 0L) {\r\n      tmp = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n      if (tmp) {\r\n        msg_0 = rtw_diagnostics_msg(diagnosticTree_0);\r\n        rtmSetErrorStatus(DCDC_Buck_M, msg_0);\r\n      }\r\n    }\r\n\r\n    if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n    }\r\n\r\n    /* Gain: '<S16>/Gain' */\r\n    DCDC_Buck_B.Gain_f = 1.0 / DCDC_Buck_P.Gi * DCDC_Buck_B.OUTPUT_1_0[0];\r\n    if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n    }\r\n\r\n    /* Gain: '<S1>/VoltageScaling' */\r\n    DCDC_Buck_B.VoltageScaling = DCDC_Buck_P.VSF * DCDC_Buck_B.OUTPUT_1_0[1];\r\n    if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n      /* DataTypeConversion: '<S4>/Subsystem_boundary_DTC3' incorporates:\r\n       *  Sum: '<S4>/Sum2'\r\n       *  UnitDelay: '<S6>/Unit Delay'\r\n       */\r\n      DCDC_Buck_DW.UnitDelay_DSTATE_b = (real_T)rtb_Sum2 * 5.9604644775390625E-8;\r\n\r\n      /* RelationalOperator: '<S6>/Relational Operator' incorporates:\r\n       *  DataTypeConversion: '<S4>/Subsystem_boundary_DTC2'\r\n       *  Saturate: '<S4>/Saturation'\r\n       *  UnitDelay: '<S6>/Unit Delay'\r\n       *  UnitDelay: '<S6>/Unit Delay1'\r\n       */\r\n      DCDC_Buck_DW.UnitDelay1_DSTATE = ((real_T)rtb_Saturation *\r\n        5.9604644775390625E-8 == DCDC_Buck_DW.UnitDelay_DSTATE_b);\r\n    }\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n    NeslSimulationData *simulationData;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    char *msg;\r\n    real_T tmp_1[16];\r\n    real_T time;\r\n    int32_T tmp_3;\r\n    int_T tmp_2[5];\r\n    boolean_T tmp;\r\n    boolean_T tmp_0;\r\n    if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n      /* Update for UnitDelay: '<S1>/Unit Delay' */\r\n      DCDC_Buck_DW.UnitDelay_DSTATE = DCDC_Buck_B.VoltageScaling;\r\n    }\r\n\r\n    /* Update for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n    simulationData = (NeslSimulationData *)DCDC_Buck_DW.STATE_1_SimData;\r\n    time = DCDC_Buck_M->Timing.t[0];\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time;\r\n    simulationData->mData->mContStates.mN = 31;\r\n    simulationData->mData->mContStates.mX =\r\n      &DCDC_Buck_X.DCDC_BuckDC_DC_Buck_PLANTDC_DC_[0];\r\n    simulationData->mData->mDiscStates.mN = 0;\r\n    simulationData->mData->mDiscStates.mX = &DCDC_Buck_DW.STATE_1_Discrete;\r\n    simulationData->mData->mModeVector.mN = 11;\r\n    simulationData->mData->mModeVector.mX = (int32_T *)\r\n      &DCDC_Buck_DW.STATE_1_Modes[0];\r\n    tmp = false;\r\n    simulationData->mData->mFoundZcEvents = tmp;\r\n    tmp = rtmIsMajorTimeStep(DCDC_Buck_M);\r\n    simulationData->mData->mIsMajorTimeStep = tmp;\r\n    tmp_0 = false;\r\n    simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n    simulationData->mData->mIsSolverCheckingCIC = false;\r\n    tmp_0 = rtsiIsSolverComputingJacobian(&DCDC_Buck_M->solverInfo);\r\n    simulationData->mData->mIsComputingJacobian = tmp_0;\r\n    simulationData->mData->mIsEvaluatingF0 = false;\r\n    simulationData->mData->mIsSolverRequestingReset = false;\r\n    simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n    tmp_2[0] = 0;\r\n    tmp_1[0] = DCDC_Buck_B.INPUT_1_1_1[0];\r\n    tmp_1[1] = DCDC_Buck_B.INPUT_1_1_1[1];\r\n    tmp_1[2] = DCDC_Buck_B.INPUT_1_1_1[2];\r\n    tmp_1[3] = DCDC_Buck_B.INPUT_1_1_1[3];\r\n    tmp_2[1] = 4;\r\n    tmp_1[4] = DCDC_Buck_B.INPUT_3_1_1[0];\r\n    tmp_1[5] = DCDC_Buck_B.INPUT_3_1_1[1];\r\n    tmp_1[6] = DCDC_Buck_B.INPUT_3_1_1[2];\r\n    tmp_1[7] = DCDC_Buck_B.INPUT_3_1_1[3];\r\n    tmp_2[2] = 8;\r\n    tmp_1[8] = DCDC_Buck_B.INPUT_2_1_1[0];\r\n    tmp_1[9] = DCDC_Buck_B.INPUT_2_1_1[1];\r\n    tmp_1[10] = DCDC_Buck_B.INPUT_2_1_1[2];\r\n    tmp_1[11] = DCDC_Buck_B.INPUT_2_1_1[3];\r\n    tmp_2[3] = 12;\r\n    tmp_1[12] = DCDC_Buck_B.INPUT_4_1_1[0];\r\n    tmp_1[13] = DCDC_Buck_B.INPUT_4_1_1[1];\r\n    tmp_1[14] = DCDC_Buck_B.INPUT_4_1_1[2];\r\n    tmp_1[15] = DCDC_Buck_B.INPUT_4_1_1[3];\r\n    tmp_2[4] = 16;\r\n    simulationData->mData->mInputValues.mN = 16;\r\n    simulationData->mData->mInputValues.mX = &tmp_1[0];\r\n    simulationData->mData->mInputOffsets.mN = 5;\r\n    simulationData->mData->mInputOffsets.mX = (int32_T *)&tmp_2[0];\r\n    diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_3 = ne_simulator_method((NeslSimulator *)DCDC_Buck_DW.STATE_1_Simulator,\r\n      NESL_SIM_UPDATE, simulationData, diagnosticManager);\r\n    if (tmp_3 != 0L) {\r\n      tmp = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n      if (tmp) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(DCDC_Buck_M, msg);\r\n      }\r\n    }\r\n\r\n    /* End of Update for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n    {                                  /* Sample time: [0.0s, 0.0s] */\r\n      extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\r\n      extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T)\r\n        (((DCDC_Buck_M->Timing.clockTick0+DCDC_Buck_M->Timing.clockTickH0*\r\n           4294967296.0) * 1) + 0)\r\n        ;\r\n\r\n      /* Trigger External Mode event */\r\n      errorCode = extmodeEvent(0,currentTime);\r\n      if (errorCode != EXTMODE_SUCCESS) {\r\n        /* Code to handle External Mode event errors\r\n           may be added here */\r\n      }\r\n    }\r\n\r\n    if (rtmIsMajorTimeStep(DCDC_Buck_M)) {/* Sample time: [5.0E-6s, 0.0s] */\r\n      extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\r\n      extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T)\r\n        (((DCDC_Buck_M->Timing.clockTick1+DCDC_Buck_M->Timing.clockTickH1*\r\n           4294967296.0) * 1) + 0)\r\n        ;\r\n\r\n      /* Trigger External Mode event */\r\n      errorCode = extmodeEvent(1,currentTime);\r\n      if (errorCode != EXTMODE_SUCCESS) {\r\n        /* Code to handle External Mode event errors\r\n           may be added here */\r\n      }\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(DCDC_Buck_M)) {\r\n    rt_ertODEUpdateContinuousStates(&DCDC_Buck_M->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    if (!(++DCDC_Buck_M->Timing.clockTick0)) {\r\n      ++DCDC_Buck_M->Timing.clockTickH0;\r\n    }\r\n\r\n    DCDC_Buck_M->Timing.t[0] = rtsiGetSolverStopTime(&DCDC_Buck_M->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [5.0E-6s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 5.0E-6, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       * Timer of this task consists of two 32 bit unsigned integers.\r\n       * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n       * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n       */\r\n      DCDC_Buck_M->Timing.clockTick1++;\r\n      if (!DCDC_Buck_M->Timing.clockTick1) {\r\n        DCDC_Buck_M->Timing.clockTickH1++;\r\n      }\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid DCDC_Buck_derivatives(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n  NeuDiagnosticTree *diagnosticTree;\r\n  XDot_DCDC_Buck_T *_rtXdot;\r\n  char *msg;\r\n  real_T tmp_1[16];\r\n  real_T time;\r\n  int32_T tmp_3;\r\n  int_T tmp_2[5];\r\n  boolean_T tmp;\r\n  boolean_T tmp_0;\r\n  _rtXdot = ((XDot_DCDC_Buck_T *) DCDC_Buck_M->derivs);\r\n\r\n  /* Derivatives for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n  simulationData = (NeslSimulationData *)DCDC_Buck_DW.STATE_1_SimData;\r\n  time = DCDC_Buck_M->Timing.t[0];\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time;\r\n  simulationData->mData->mContStates.mN = 31;\r\n  simulationData->mData->mContStates.mX =\r\n    &DCDC_Buck_X.DCDC_BuckDC_DC_Buck_PLANTDC_DC_[0];\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &DCDC_Buck_DW.STATE_1_Discrete;\r\n  simulationData->mData->mModeVector.mN = 11;\r\n  simulationData->mData->mModeVector.mX = (int32_T *)\r\n    &DCDC_Buck_DW.STATE_1_Modes[0];\r\n  tmp = false;\r\n  simulationData->mData->mFoundZcEvents = tmp;\r\n  tmp = rtmIsMajorTimeStep(DCDC_Buck_M);\r\n  simulationData->mData->mIsMajorTimeStep = tmp;\r\n  tmp_0 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  tmp_0 = rtsiIsSolverComputingJacobian(&DCDC_Buck_M->solverInfo);\r\n  simulationData->mData->mIsComputingJacobian = tmp_0;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n  tmp_2[0] = 0;\r\n  tmp_1[0] = DCDC_Buck_B.INPUT_1_1_1[0];\r\n  tmp_1[1] = DCDC_Buck_B.INPUT_1_1_1[1];\r\n  tmp_1[2] = DCDC_Buck_B.INPUT_1_1_1[2];\r\n  tmp_1[3] = DCDC_Buck_B.INPUT_1_1_1[3];\r\n  tmp_2[1] = 4;\r\n  tmp_1[4] = DCDC_Buck_B.INPUT_3_1_1[0];\r\n  tmp_1[5] = DCDC_Buck_B.INPUT_3_1_1[1];\r\n  tmp_1[6] = DCDC_Buck_B.INPUT_3_1_1[2];\r\n  tmp_1[7] = DCDC_Buck_B.INPUT_3_1_1[3];\r\n  tmp_2[2] = 8;\r\n  tmp_1[8] = DCDC_Buck_B.INPUT_2_1_1[0];\r\n  tmp_1[9] = DCDC_Buck_B.INPUT_2_1_1[1];\r\n  tmp_1[10] = DCDC_Buck_B.INPUT_2_1_1[2];\r\n  tmp_1[11] = DCDC_Buck_B.INPUT_2_1_1[3];\r\n  tmp_2[3] = 12;\r\n  tmp_1[12] = DCDC_Buck_B.INPUT_4_1_1[0];\r\n  tmp_1[13] = DCDC_Buck_B.INPUT_4_1_1[1];\r\n  tmp_1[14] = DCDC_Buck_B.INPUT_4_1_1[2];\r\n  tmp_1[15] = DCDC_Buck_B.INPUT_4_1_1[3];\r\n  tmp_2[4] = 16;\r\n  simulationData->mData->mInputValues.mN = 16;\r\n  simulationData->mData->mInputValues.mX = &tmp_1[0];\r\n  simulationData->mData->mInputOffsets.mN = 5;\r\n  simulationData->mData->mInputOffsets.mX = (int32_T *)&tmp_2[0];\r\n  simulationData->mData->mDx.mN = 31;\r\n  simulationData->mData->mDx.mX = &_rtXdot->DCDC_BuckDC_DC_Buck_PLANTDC_DC_[0];\r\n  diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.STATE_1_DiagMgr;\r\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  tmp_3 = ne_simulator_method((NeslSimulator *)DCDC_Buck_DW.STATE_1_Simulator,\r\n    NESL_SIM_DERIVATIVES, simulationData, diagnosticManager);\r\n  if (tmp_3 != 0L) {\r\n    tmp = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n    if (tmp) {\r\n      msg = rtw_diagnostics_msg(diagnosticTree);\r\n      rtmSetErrorStatus(DCDC_Buck_M, msg);\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid DCDC_Buck_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)DCDC_Buck_M, 0,\r\n                sizeof(RT_MODEL_DCDC_Buck_T));\r\n\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&DCDC_Buck_M->solverInfo,\r\n                          &DCDC_Buck_M->Timing.simTimeStep);\r\n    rtsiSetTPtr(&DCDC_Buck_M->solverInfo, &rtmGetTPtr(DCDC_Buck_M));\r\n    rtsiSetStepSizePtr(&DCDC_Buck_M->solverInfo, &DCDC_Buck_M->Timing.stepSize0);\r\n    rtsiSetdXPtr(&DCDC_Buck_M->solverInfo, &DCDC_Buck_M->derivs);\r\n    rtsiSetContStatesPtr(&DCDC_Buck_M->solverInfo, (real_T **)\r\n                         &DCDC_Buck_M->contStates);\r\n    rtsiSetNumContStatesPtr(&DCDC_Buck_M->solverInfo,\r\n      &DCDC_Buck_M->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&DCDC_Buck_M->solverInfo,\r\n      &DCDC_Buck_M->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&DCDC_Buck_M->solverInfo,\r\n      &DCDC_Buck_M->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&DCDC_Buck_M->solverInfo,\r\n      &DCDC_Buck_M->periodicContStateRanges);\r\n    rtsiSetErrorStatusPtr(&DCDC_Buck_M->solverInfo, (&rtmGetErrorStatus\r\n      (DCDC_Buck_M)));\r\n    rtsiSetSolverMassMatrixIr(&DCDC_Buck_M->solverInfo, DCDC_Buck_MassMatrix.ir);\r\n    rtsiSetSolverMassMatrixJc(&DCDC_Buck_M->solverInfo, DCDC_Buck_MassMatrix.jc);\r\n    rtsiSetSolverMassMatrixPr(&DCDC_Buck_M->solverInfo, DCDC_Buck_MassMatrix.pr);\r\n    rtsiSetRTModelPtr(&DCDC_Buck_M->solverInfo, DCDC_Buck_M);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&DCDC_Buck_M->solverInfo, MAJOR_TIME_STEP);\r\n  DCDC_Buck_M->intgData.x0 = DCDC_Buck_M->odeX0;\r\n  DCDC_Buck_M->intgData.f0 = DCDC_Buck_M->odeF0;\r\n  DCDC_Buck_M->intgData.x1start = DCDC_Buck_M->odeX1START;\r\n  DCDC_Buck_M->intgData.f1 = DCDC_Buck_M->odeF1;\r\n  DCDC_Buck_M->intgData.Delta = DCDC_Buck_M->odeDELTA;\r\n  DCDC_Buck_M->intgData.E = DCDC_Buck_M->odeE;\r\n  DCDC_Buck_M->intgData.fac = DCDC_Buck_M->odeFAC;\r\n\r\n  /* initialize */\r\n  {\r\n    int_T i;\r\n    real_T *f = DCDC_Buck_M->intgData.fac;\r\n    for (i = 0; i < (int_T)(sizeof(DCDC_Buck_M->odeFAC)/sizeof(real_T)); i++) {\r\n      f[i] = 1.5e-8;\r\n    }\r\n  }\r\n\r\n  DCDC_Buck_M->intgData.DFDX = DCDC_Buck_M->odeDFDX;\r\n  DCDC_Buck_M->intgData.W = DCDC_Buck_M->odeW;\r\n  DCDC_Buck_M->intgData.pivots = DCDC_Buck_M->odePIVOTS;\r\n  DCDC_Buck_M->intgData.xtmp = DCDC_Buck_M->odeXTMP;\r\n  DCDC_Buck_M->intgData.ztmp = DCDC_Buck_M->odeZTMP;\r\n  DCDC_Buck_M->intgData.M = DCDC_Buck_M->odeMASSMATRIX_M;\r\n  DCDC_Buck_M->intgData.isFirstStep = true;\r\n  rtsiSetSolverExtrapolationOrder(&DCDC_Buck_M->solverInfo, 4);\r\n  rtsiSetSolverNumberNewtonIterations(&DCDC_Buck_M->solverInfo, 1);\r\n  DCDC_Buck_M->contStates = ((X_DCDC_Buck_T *) &DCDC_Buck_X);\r\n  DCDC_Buck_M->massMatrixType = ((ssMatrixType)1);\r\n  DCDC_Buck_M->massMatrixNzMax = (13);\r\n  DCDC_Buck_M->massMatrixIr = (DCDC_Buck_MassMatrix.ir);\r\n  DCDC_Buck_M->massMatrixJc = (DCDC_Buck_MassMatrix.jc);\r\n  DCDC_Buck_M->massMatrixPr = (DCDC_Buck_MassMatrix.pr);\r\n  rtsiSetSolverMassMatrixType(&DCDC_Buck_M->solverInfo, (ssMatrixType)1);\r\n  rtsiSetSolverMassMatrixNzMax(&DCDC_Buck_M->solverInfo, 13);\r\n  rtsiSetSolverData(&DCDC_Buck_M->solverInfo, (void *)&DCDC_Buck_M->intgData);\r\n  rtsiSetSolverName(&DCDC_Buck_M->solverInfo,\"ode14x\");\r\n  rtmSetTPtr(DCDC_Buck_M, &DCDC_Buck_M->Timing.tArray[0]);\r\n  rtmSetTFinal(DCDC_Buck_M, -1);\r\n  DCDC_Buck_M->Timing.stepSize0 = 5.0E-6;\r\n\r\n  /* External mode info */\r\n  DCDC_Buck_M->Sizes.checksums[0] = (1171246107U);\r\n  DCDC_Buck_M->Sizes.checksums[1] = (1312331121U);\r\n  DCDC_Buck_M->Sizes.checksums[2] = (645355539U);\r\n  DCDC_Buck_M->Sizes.checksums[3] = (2015632949U);\r\n\r\n  {\r\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\r\n    static RTWExtModeInfo rt_ExtModeInfo;\r\n    static const sysRanDType *systemRan[3];\r\n    DCDC_Buck_M->extModeInfo = (&rt_ExtModeInfo);\r\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\r\n    systemRan[0] = &rtAlwaysEnabled;\r\n    systemRan[1] = &rtAlwaysEnabled;\r\n    systemRan[2] = &rtAlwaysEnabled;\r\n    rteiSetModelMappingInfoPtr(DCDC_Buck_M->extModeInfo,\r\n      &DCDC_Buck_M->SpecialInfo.mappingInfo);\r\n    rteiSetChecksumsPtr(DCDC_Buck_M->extModeInfo, DCDC_Buck_M->Sizes.checksums);\r\n    rteiSetTPtr(DCDC_Buck_M->extModeInfo, rtmGetTPtr(DCDC_Buck_M));\r\n  }\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &DCDC_Buck_B), 0,\r\n                sizeof(B_DCDC_Buck_T));\r\n\r\n  /* states (continuous) */\r\n  {\r\n    (void) memset((void *)&DCDC_Buck_X, 0,\r\n                  sizeof(X_DCDC_Buck_T));\r\n  }\r\n\r\n  /* global mass matrix */\r\n  {\r\n    int_T *ir = DCDC_Buck_MassMatrix.ir;\r\n    int_T *jc = DCDC_Buck_MassMatrix.jc;\r\n    real_T *pr = DCDC_Buck_MassMatrix.pr;\r\n    (void) memset((void *)ir, 0,\r\n                  13*sizeof(int_T));\r\n    (void) memset((void *)jc, 0,\r\n                  (31+1)*sizeof(int_T));\r\n    (void) memset((void *)pr, 0,\r\n                  13*sizeof(real_T));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&DCDC_Buck_DW, 0,\r\n                sizeof(DW_DCDC_Buck_T));\r\n\r\n  /* Root-level init GlobalMassMatrixPr offset */\r\n  {\r\n    DCDC_Buck_DW.STATE_1_MASS_MATRIX_PR = 0;/* '<S26>/STATE_1' */\r\n  }\r\n\r\n  {\r\n    NeModelParameters modelParameters;\r\n    NeModelParameters modelParameters_0;\r\n    NeslSimulationData *tmp_1;\r\n    NeslSimulator *tmp;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    NeuDiagnosticTree *diagnosticTree_0;\r\n    char *msg;\r\n    char *msg_0;\r\n    real_T tmp_2;\r\n    int32_T tmp_3;\r\n    int_T tmp_5;\r\n    int_T tmp_6;\r\n    int_T tmp_7;\r\n    int_T tmp_8;\r\n    int_T tmp_9;\r\n    int_T tmp_a;\r\n    boolean_T tmp_0;\r\n    boolean_T tmp_4;\r\n\r\n    /* Start for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n    tmp = nesl_lease_simulator(\r\n      \"DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration_1\", 0L, 0L);\r\n    DCDC_Buck_DW.STATE_1_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(DCDC_Buck_DW.STATE_1_Simulator);\r\n    if (tmp_0) {\r\n      DCDC_Buck_9d5357ce_1_gateway();\r\n      tmp = nesl_lease_simulator(\r\n        \"DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration_1\", 0L, 0L);\r\n      DCDC_Buck_DW.STATE_1_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    DCDC_Buck_DW.STATE_1_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    DCDC_Buck_DW.STATE_1_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters.mSolverTolerance = 0.001;\r\n    modelParameters.mVariableStepSolver = false;\r\n    modelParameters.mIsUsingODEN = false;\r\n    modelParameters.mFixedStepSize = 0.001;\r\n    modelParameters.mStartTime = 0.0;\r\n    modelParameters.mLoadInitialState = false;\r\n    modelParameters.mUseSimState = false;\r\n    modelParameters.mLinTrimCompile = false;\r\n    modelParameters.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters.mRTWModifiedTimeStamp = 6.32502036E+8;\r\n    modelParameters.mZcDisabled = false;\r\n    tmp_2 = 0.001;\r\n    modelParameters.mSolverTolerance = tmp_2;\r\n    tmp_2 = 5.0E-6;\r\n    modelParameters.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters.mIsUsingODEN = tmp_0;\r\n    modelParameters.mLoadInitialState = false;\r\n    modelParameters.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_3 = nesl_initialize_simulator((NeslSimulator *)\r\n      DCDC_Buck_DW.STATE_1_Simulator, &modelParameters, diagnosticManager);\r\n    if (tmp_3 != 0L) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n      if (tmp_0) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(DCDC_Buck_M, msg);\r\n      }\r\n    }\r\n\r\n    /* End of Start for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n\r\n    /* Start for SimscapeExecutionBlock: '<S26>/OUTPUT_1_0' */\r\n    tmp = nesl_lease_simulator(\r\n      \"DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration_1\", 1L, 0L);\r\n    DCDC_Buck_DW.OUTPUT_1_0_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(DCDC_Buck_DW.OUTPUT_1_0_Simulator);\r\n    if (tmp_0) {\r\n      DCDC_Buck_9d5357ce_1_gateway();\r\n      tmp = nesl_lease_simulator(\r\n        \"DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration_1\", 1L, 0L);\r\n      DCDC_Buck_DW.OUTPUT_1_0_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    DCDC_Buck_DW.OUTPUT_1_0_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    DCDC_Buck_DW.OUTPUT_1_0_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters_0.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters_0.mSolverTolerance = 0.001;\r\n    modelParameters_0.mVariableStepSolver = false;\r\n    modelParameters_0.mIsUsingODEN = false;\r\n    modelParameters_0.mFixedStepSize = 0.001;\r\n    modelParameters_0.mStartTime = 0.0;\r\n    modelParameters_0.mLoadInitialState = false;\r\n    modelParameters_0.mUseSimState = false;\r\n    modelParameters_0.mLinTrimCompile = false;\r\n    modelParameters_0.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters_0.mRTWModifiedTimeStamp = 6.32502036E+8;\r\n    modelParameters_0.mZcDisabled = false;\r\n    tmp_2 = 0.001;\r\n    modelParameters_0.mSolverTolerance = tmp_2;\r\n    tmp_2 = 5.0E-6;\r\n    modelParameters_0.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters_0.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters_0.mIsUsingODEN = tmp_0;\r\n    modelParameters_0.mLoadInitialState = false;\r\n    modelParameters_0.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)DCDC_Buck_DW.OUTPUT_1_0_DiagMgr;\r\n    diagnosticTree_0 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_3 = nesl_initialize_simulator((NeslSimulator *)\r\n      DCDC_Buck_DW.OUTPUT_1_0_Simulator, &modelParameters_0, diagnosticManager);\r\n    if (tmp_3 != 0L) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(DCDC_Buck_M));\r\n      if (tmp_0) {\r\n        msg_0 = rtw_diagnostics_msg(diagnosticTree_0);\r\n        rtmSetErrorStatus(DCDC_Buck_M, msg_0);\r\n      }\r\n    }\r\n\r\n    /* End of Start for SimscapeExecutionBlock: '<S26>/OUTPUT_1_0' */\r\n\r\n    /* InitializeConditions for UnitDelay: '<S1>/Unit Delay' */\r\n    DCDC_Buck_DW.UnitDelay_DSTATE = DCDC_Buck_P.UnitDelay_InitialCondition;\r\n\r\n    /* InitializeConditions for UnitDelay: '<S6>/Unit Delay1' */\r\n    DCDC_Buck_DW.UnitDelay1_DSTATE = DCDC_Buck_P.UnitDelay1_InitialCondition;\r\n\r\n    /* InitializeConditions for UnitDelay: '<S6>/Unit Delay' */\r\n    DCDC_Buck_DW.UnitDelay_DSTATE_b = DCDC_Buck_P.UnitDelay_InitialCondition_a;\r\n\r\n    /* InitializeConditions for UnitDelay: '<S4>/Unit Delay' */\r\n    DCDC_Buck_DW.UnitDelay_DSTATE_m = DCDC_Buck_P.UnitDelay_InitialCondition_f;\r\n\r\n    /* InitializeConditions for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n    tmp_0 = false;\r\n    tmp_4 = false;\r\n    if (tmp_4 || tmp_0) {\r\n      tmp_5 = strcmp(rtsiGetSolverName(&DCDC_Buck_M->solverInfo), \"daessc\");\r\n      tmp_6 = strcmp(rtsiGetSolverName(&DCDC_Buck_M->solverInfo), \"ode14x\");\r\n      tmp_7 = strcmp(rtsiGetSolverName(&DCDC_Buck_M->solverInfo), \"ode15s\");\r\n      tmp_8 = strcmp(rtsiGetSolverName(&DCDC_Buck_M->solverInfo), \"ode1be\");\r\n      tmp_9 = strcmp(rtsiGetSolverName(&DCDC_Buck_M->solverInfo), \"ode23t\");\r\n      tmp_a = strcmp(rtsiGetSolverName(&DCDC_Buck_M->solverInfo), \"odeN\");\r\n      if ((boolean_T)((int16_T)(boolean_T)((int16_T)(boolean_T)((int16_T)\r\n             (boolean_T)((int16_T)(boolean_T)((tmp_5 != 0) & (tmp_6 != 0)) &\r\n                         (tmp_7 != 0)) & (tmp_8 != 0)) & (tmp_9 != 0)) & (tmp_a\r\n            != 0))) {\r\n        rtmSetErrorStatus(DCDC_Buck_M,\r\n                          \"Detected inconsistent solvers in the model reference hierarchy. Model built with ode14x requires one of {daessc, ode14x, ode15s, ode1be, ode23t, odeN} solvers to run. Use one of the required solvers in the top model.\");\r\n      }\r\n    }\r\n\r\n    /* End of InitializeConditions for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n\r\n    /* Root-level InitSystemMatrices */\r\n    {\r\n      static int_T modelMassMatrixIr[13] = { 2, 0, 7, 1, 12, 3, 4, 5, 6, 8, 9,\r\n        10, 11 };\r\n\r\n      static int_T modelMassMatrixJc[32] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\r\n        11, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\r\n        13, 13, 13 };\r\n\r\n      static real_T modelMassMatrixPr[13] = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n        1.0, 1.0, 1.0, 1.0, 1.0, 1.0 };\r\n\r\n      (void) memcpy(DCDC_Buck_MassMatrix.ir, modelMassMatrixIr,\r\n                    13*sizeof(int_T));\r\n      (void) memcpy(DCDC_Buck_MassMatrix.jc, modelMassMatrixJc,\r\n                    32*sizeof(int_T));\r\n      (void) memcpy(DCDC_Buck_MassMatrix.pr, modelMassMatrixPr,\r\n                    13*sizeof(real_T));\r\n    }\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid DCDC_Buck_terminate(void)\r\n{\r\n  /* Terminate for SimscapeExecutionBlock: '<S26>/STATE_1' */\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)\r\n    DCDC_Buck_DW.STATE_1_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)\r\n    DCDC_Buck_DW.STATE_1_SimData);\r\n  nesl_erase_simulator(\"DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n\r\n  /* Terminate for SimscapeExecutionBlock: '<S26>/OUTPUT_1_0' */\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)\r\n    DCDC_Buck_DW.OUTPUT_1_0_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)\r\n    DCDC_Buck_DW.OUTPUT_1_0_SimData);\r\n  nesl_erase_simulator(\"DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCDC_Buck.h","type":"header","group":"model","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: DCDC_Buck.h\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_DCDC_Buck_h_\r\n#define RTW_HEADER_DCDC_Buck_h_\r\n#include <string.h>\r\n#include <math.h>\r\n#ifndef DCDC_Buck_COMMON_INCLUDES_\r\n#define DCDC_Buck_COMMON_INCLUDES_\r\n#include <IQmathLib.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_extmode.h\"\r\n#include \"sysran_types.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"ext_mode.h\"\r\n#include \"nesl_rtw.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_gateway.h\"\r\n#endif                                 /* DCDC_Buck_COMMON_INCLUDES_ */\r\n\r\n#include \"DCDC_Buck_types.h\"\r\n\r\n/* Shared type includes */\r\n#include \"multiword_types.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n#include \"math.h\"\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetMassMatrixIr\r\n#define rtmGetMassMatrixIr(rtm)        ((rtm)->massMatrixIr)\r\n#endif\r\n\r\n#ifndef rtmSetMassMatrixIr\r\n#define rtmSetMassMatrixIr(rtm, val)   ((rtm)->massMatrixIr = (val))\r\n#endif\r\n\r\n#ifndef rtmGetMassMatrixJc\r\n#define rtmGetMassMatrixJc(rtm)        ((rtm)->massMatrixJc)\r\n#endif\r\n\r\n#ifndef rtmSetMassMatrixJc\r\n#define rtmSetMassMatrixJc(rtm, val)   ((rtm)->massMatrixJc = (val))\r\n#endif\r\n\r\n#ifndef rtmGetMassMatrixNzMax\r\n#define rtmGetMassMatrixNzMax(rtm)     ((rtm)->massMatrixNzMax)\r\n#endif\r\n\r\n#ifndef rtmSetMassMatrixNzMax\r\n#define rtmSetMassMatrixNzMax(rtm, val) ((rtm)->massMatrixNzMax = (val))\r\n#endif\r\n\r\n#ifndef rtmGetMassMatrixPr\r\n#define rtmGetMassMatrixPr(rtm)        ((rtm)->massMatrixPr)\r\n#endif\r\n\r\n#ifndef rtmSetMassMatrixPr\r\n#define rtmSetMassMatrixPr(rtm, val)   ((rtm)->massMatrixPr = (val))\r\n#endif\r\n\r\n#ifndef rtmGetMassMatrixType\r\n#define rtmGetMassMatrixType(rtm)      ((rtm)->massMatrixType)\r\n#endif\r\n\r\n#ifndef rtmSetMassMatrixType\r\n#define rtmSetMassMatrixType(rtm, val) ((rtm)->massMatrixType = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeDELTA\r\n#define rtmGetOdeDELTA(rtm)            ((rtm)->odeDELTA)\r\n#endif\r\n\r\n#ifndef rtmSetOdeDELTA\r\n#define rtmSetOdeDELTA(rtm, val)       ((rtm)->odeDELTA = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeDFDX\r\n#define rtmGetOdeDFDX(rtm)             ((rtm)->odeDFDX)\r\n#endif\r\n\r\n#ifndef rtmSetOdeDFDX\r\n#define rtmSetOdeDFDX(rtm, val)        ((rtm)->odeDFDX = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeE\r\n#define rtmGetOdeE(rtm)                ((rtm)->odeE)\r\n#endif\r\n\r\n#ifndef rtmSetOdeE\r\n#define rtmSetOdeE(rtm, val)           ((rtm)->odeE = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF0\r\n#define rtmGetOdeF0(rtm)               ((rtm)->odeF0)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF0\r\n#define rtmSetOdeF0(rtm, val)          ((rtm)->odeF0 = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF1\r\n#define rtmGetOdeF1(rtm)               ((rtm)->odeF1)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF1\r\n#define rtmSetOdeF1(rtm, val)          ((rtm)->odeF1 = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeFAC\r\n#define rtmGetOdeFAC(rtm)              ((rtm)->odeFAC)\r\n#endif\r\n\r\n#ifndef rtmSetOdeFAC\r\n#define rtmSetOdeFAC(rtm, val)         ((rtm)->odeFAC = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeMASSMATRIX_M\r\n#define rtmGetOdeMASSMATRIX_M(rtm)     ((rtm)->odeMASSMATRIX_M)\r\n#endif\r\n\r\n#ifndef rtmSetOdeMASSMATRIX_M\r\n#define rtmSetOdeMASSMATRIX_M(rtm, val) ((rtm)->odeMASSMATRIX_M = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdePIVOTS\r\n#define rtmGetOdePIVOTS(rtm)           ((rtm)->odePIVOTS)\r\n#endif\r\n\r\n#ifndef rtmSetOdePIVOTS\r\n#define rtmSetOdePIVOTS(rtm, val)      ((rtm)->odePIVOTS = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeW\r\n#define rtmGetOdeW(rtm)                ((rtm)->odeW)\r\n#endif\r\n\r\n#ifndef rtmSetOdeW\r\n#define rtmSetOdeW(rtm, val)           ((rtm)->odeW = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeX0\r\n#define rtmGetOdeX0(rtm)               ((rtm)->odeX0)\r\n#endif\r\n\r\n#ifndef rtmSetOdeX0\r\n#define rtmSetOdeX0(rtm, val)          ((rtm)->odeX0 = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeX1START\r\n#define rtmGetOdeX1START(rtm)          ((rtm)->odeX1START)\r\n#endif\r\n\r\n#ifndef rtmSetOdeX1START\r\n#define rtmSetOdeX1START(rtm, val)     ((rtm)->odeX1START = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeXTMP\r\n#define rtmGetOdeXTMP(rtm)             ((rtm)->odeXTMP)\r\n#endif\r\n\r\n#ifndef rtmSetOdeXTMP\r\n#define rtmSetOdeXTMP(rtm, val)        ((rtm)->odeXTMP = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeZTMP\r\n#define rtmGetOdeZTMP(rtm)             ((rtm)->odeZTMP)\r\n#endif\r\n\r\n#ifndef rtmSetOdeZTMP\r\n#define rtmSetOdeZTMP(rtm, val)        ((rtm)->odeZTMP = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWExtModeInfo\r\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Gain;                         /* '<S10>/Gain' */\r\n  real_T INPUT_1_1_1[4];               /* '<S26>/INPUT_1_1_1' */\r\n  real_T Duty;                         /* '<S5>/Inverse TBPRD' */\r\n  real_T Clock1;                       /* '<S9>/Clock1' */\r\n  real_T Time_Period;                  /* '<S9>/Time_Period' */\r\n  real_T MathFunction2;                /* '<S9>/Math Function2' */\r\n  real_T Gain1;                        /* '<S9>/Gain1' */\r\n  real_T DataTypeConversion1;          /* '<S5>/Data Type Conversion1' */\r\n  real_T Gain6;                        /* '<S3>/Gain6' */\r\n  real_T INPUT_3_1_1[4];               /* '<S26>/INPUT_3_1_1' */\r\n  real_T INPUT_2_1_1[4];               /* '<S26>/INPUT_2_1_1' */\r\n  real_T INPUT_4_1_1[4];               /* '<S26>/INPUT_4_1_1' */\r\n  real_T STATE_1[42];                  /* '<S26>/STATE_1' */\r\n  real_T OUTPUT_1_0[2];                /* '<S26>/OUTPUT_1_0' */\r\n  real_T Gain_f;                       /* '<S16>/Gain' */\r\n  real_T VoltageScaling;               /* '<S1>/VoltageScaling' */\r\n} B_DCDC_Buck_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T INPUT_1_1_1_Discrete[2];      /* '<S26>/INPUT_1_1_1' */\r\n  real_T UnitDelay_DSTATE;             /* '<S1>/Unit Delay' */\r\n  real_T UnitDelay_DSTATE_b;           /* '<S6>/Unit Delay' */\r\n  real_T INPUT_3_1_1_Discrete[2];      /* '<S26>/INPUT_3_1_1' */\r\n  real_T INPUT_2_1_1_Discrete[2];      /* '<S26>/INPUT_2_1_1' */\r\n  real_T INPUT_4_1_1_Discrete[2];      /* '<S26>/INPUT_4_1_1' */\r\n  real_T STATE_1_Discrete;             /* '<S26>/STATE_1' */\r\n  real_T OUTPUT_1_0_Discrete;          /* '<S26>/OUTPUT_1_0' */\r\n  void* STATE_1_Simulator;             /* '<S26>/STATE_1' */\r\n  void* STATE_1_SimData;               /* '<S26>/STATE_1' */\r\n  void* STATE_1_DiagMgr;               /* '<S26>/STATE_1' */\r\n  void* STATE_1_ZcLogger;              /* '<S26>/STATE_1' */\r\n  void* STATE_1_TsIndex;               /* '<S26>/STATE_1' */\r\n  void* OUTPUT_1_0_Simulator;          /* '<S26>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_SimData;            /* '<S26>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_DiagMgr;            /* '<S26>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_ZcLogger;           /* '<S26>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_TsIndex;            /* '<S26>/OUTPUT_1_0' */\r\n  struct {\r\n    void *AQHandles;\r\n  } TAQSigLogging_InsertedFor_DCDC_;   /* synthesized block */\r\n\r\n  struct {\r\n    void *LoggedData[2];\r\n  } Scope_PWORK;                       /* '<Root>/Scope' */\r\n\r\n  struct {\r\n    void *AQHandles;\r\n  } TAQSigLogging_InsertedFor_DCD_l;   /* synthesized block */\r\n\r\n  struct {\r\n    void *LoggedData[4];\r\n  } Scope_PWORK_e;                     /* '<S9>/Scope' */\r\n\r\n  struct {\r\n    void *AQHandles;\r\n  } TAQSigLogging_InsertedFor_Gain1;   /* synthesized block */\r\n\r\n  struct {\r\n    void *AQHandles;\r\n  } TAQSigLogging_InsertedFor_MathF;   /* synthesized block */\r\n\r\n  struct {\r\n    void *AQHandles;\r\n  } TAQSigLogging_InsertedFor_Time_;   /* synthesized block */\r\n\r\n  struct {\r\n    void *AQHandles;\r\n  } TAQSigLogging_InsertedFor_Clock;   /* synthesized block */\r\n\r\n  int32_T UnitDelay_DSTATE_m;          /* '<S4>/Unit Delay' */\r\n  int32_T IQNxIQN_FRAC_LEN;            /* '<S4>/IQN x IQN' */\r\n  int32_T IQNxIQN1_FRAC_LEN;           /* '<S4>/IQN x IQN1' */\r\n  int_T STATE_1_Modes[11];             /* '<S26>/STATE_1' */\r\n  int_T OUTPUT_1_0_Modes;              /* '<S26>/OUTPUT_1_0' */\r\n  int32_T STATE_1_MASS_MATRIX_PR;      /* '<S26>/STATE_1' */\r\n  boolean_T UnitDelay1_DSTATE;         /* '<S6>/Unit Delay1' */\r\n  boolean_T STATE_1_FirstOutput;       /* '<S26>/STATE_1' */\r\n  boolean_T OUTPUT_1_0_FirstOutput;    /* '<S26>/OUTPUT_1_0' */\r\n} DW_DCDC_Buck_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T DCDC_BuckDC_DC_Buck_PLANTDC_DC_[31];/* '<S26>/STATE_1' */\r\n} X_DCDC_Buck_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T DCDC_BuckDC_DC_Buck_PLANTDC_DC_[31];/* '<S26>/STATE_1' */\r\n} XDot_DCDC_Buck_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T DCDC_BuckDC_DC_Buck_PLANTDC_DC_[31];/* '<S26>/STATE_1' */\r\n} XDis_DCDC_Buck_T;\r\n\r\n/* Mass Matrix (global) */\r\ntypedef struct {\r\n  int_T ir[13];\r\n  int_T jc[32];\r\n  real_T pr[13];\r\n} MassMatrix_DCDC_Buck_T;\r\n\r\n#ifndef ODE14X_INTG\r\n#define ODE14X_INTG\r\n\r\n/* ODE14X Integration Data */\r\ntypedef struct {\r\n  real_T *x0;\r\n  real_T *f0;\r\n  real_T *x1start;\r\n  real_T *f1;\r\n  real_T *Delta;\r\n  real_T *E;\r\n  real_T *fac;\r\n  real_T *DFDX;\r\n  real_T *W;\r\n  int_T *pivots;\r\n  real_T *xtmp;\r\n  real_T *ztmp;\r\n  real_T *M;\r\n  real_T *M1;\r\n  real_T *Edot;\r\n  real_T *xdot;\r\n  real_T *fminusMxdot;\r\n  boolean_T isFirstStep;\r\n} ODE14X_IntgData;\r\n\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\nstruct P_DCDC_Buck_T_ {\r\n  real_T FPWM;                         /* Variable: FPWM\r\n                                        * Referenced by: '<S9>/Gain1'\r\n                                        */\r\n  real_T Gi;                           /* Variable: Gi\r\n                                        * Referenced by: '<S16>/Gain'\r\n                                        */\r\n  real_T Tpwm;                         /* Variable: Tpwm\r\n                                        * Referenced by: '<S9>/Time_Period'\r\n                                        */\r\n  real_T VSF;                          /* Variable: VSF\r\n                                        * Referenced by:\r\n                                        *   '<S1>/VoltageScaling'\r\n                                        *   '<S1>/VoltageScaling1'\r\n                                        */\r\n  real_T CompareToConstant_const;     /* Mask Parameter: CompareToConstant_const\r\n                                       * Referenced by: '<S7>/Constant'\r\n                                       */\r\n  real32_T CompareToConstant1_const; /* Mask Parameter: CompareToConstant1_const\r\n                                      * Referenced by: '<S8>/Constant'\r\n                                      */\r\n  real_T Constant2_Value;              /* Expression: 0.003\r\n                                        * Referenced by: '<S1>/Constant2'\r\n                                        */\r\n  real_T Step_Time;                    /* Expression: 0.05\r\n                                        * Referenced by: '<S2>/Step'\r\n                                        */\r\n  real_T Step_Y0;                      /* Expression: 0\r\n                                        * Referenced by: '<S2>/Step'\r\n                                        */\r\n  real_T Step_YFinal;                  /* Expression: 1\r\n                                        * Referenced by: '<S2>/Step'\r\n                                        */\r\n  real_T Gain_Gain;                    /* Expression: 9\r\n                                        * Referenced by: '<S10>/Gain'\r\n                                        */\r\n  real_T Constant_Value;               /* Expression: 5\r\n                                        * Referenced by: '<S1>/Constant'\r\n                                        */\r\n  real_T PerUnitConvRate_Gain;         /* Expression: 1\r\n                                        * Referenced by: '<S3>/PerUnitConvRate'\r\n                                        */\r\n  real_T UnitDelay_InitialCondition;   /* Expression: 0\r\n                                        * Referenced by: '<S1>/Unit Delay'\r\n                                        */\r\n  real_T PerUnitConvRate1_Gain;        /* Expression: 1\r\n                                        * Referenced by: '<S3>/PerUnitConvRate1'\r\n                                        */\r\n  real_T Constant1_Value;              /* Expression: 0.003\r\n                                        * Referenced by: '<S1>/Constant1'\r\n                                        */\r\n  real_T UnitDelay_InitialCondition_a; /* Expression: 0\r\n                                        * Referenced by: '<S6>/Unit Delay'\r\n                                        */\r\n  real_T InverseTBPRD_Gain;            /* Expression: 1/TBPRD\r\n                                        * Referenced by: '<S5>/Inverse TBPRD'\r\n                                        */\r\n  real_T Gain6_Gain;                   /* Expression: 9\r\n                                        * Referenced by: '<S3>/Gain6'\r\n                                        */\r\n  int32_T Constant_Value_f;            /* Computed Parameter: Constant_Value_f\r\n                                        * Referenced by: '<S6>/Constant'\r\n                                        */\r\n  int32_T UnitDelay_InitialCondition_f;\r\n                             /* Computed Parameter: UnitDelay_InitialCondition_f\r\n                              * Referenced by: '<S4>/Unit Delay'\r\n                              */\r\n  int32_T Saturation_UpperSat;        /* Computed Parameter: Saturation_UpperSat\r\n                                       * Referenced by: '<S4>/Saturation'\r\n                                       */\r\n  int32_T Saturation_LowerSat;        /* Computed Parameter: Saturation_LowerSat\r\n                                       * Referenced by: '<S4>/Saturation'\r\n                                       */\r\n  int16_T Gain4_Gain;                  /* Expression: TBPRD\r\n                                        * Referenced by: '<S3>/Gain4'\r\n                                        */\r\n  boolean_T UnitDelay1_InitialCondition;\r\n                              /* Computed Parameter: UnitDelay1_InitialCondition\r\n                               * Referenced by: '<S6>/Unit Delay1'\r\n                               */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_DCDC_Buck_T {\r\n  const char_T *errorStatus;\r\n  RTWExtModeInfo *extModeInfo;\r\n  RTWSolverInfo solverInfo;\r\n  X_DCDC_Buck_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  boolean_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  int_T massMatrixType;\r\n  int_T massMatrixNzMax;\r\n  int_T *massMatrixIr;\r\n  int_T *massMatrixJc;\r\n  real_T *massMatrixPr;\r\n  real_T odeX0[31];\r\n  real_T odeF0[31];\r\n  real_T odeX1START[31];\r\n  real_T odeF1[31];\r\n  real_T odeDELTA[31];\r\n  real_T odeE[4*31];\r\n  real_T odeFAC[31];\r\n  real_T odeDFDX[31*31];\r\n  real_T odeW[31*31];\r\n  int_T odePIVOTS[31];\r\n  real_T odeXTMP[31];\r\n  real_T odeZTMP[31];\r\n  real_T odeMASSMATRIX_M[13];\r\n  ODE14X_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    uint32_T checksums[4];\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * SpecialInfo:\r\n   * The following substructure contains special information\r\n   * related to other components that are dependent on RTW.\r\n   */\r\n  struct {\r\n    const void *mappingInfo;\r\n  } SpecialInfo;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    time_T tFinal;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_DCDC_Buck_T DCDC_Buck_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_DCDC_Buck_T DCDC_Buck_B;\r\n\r\n/* Continuous states (default storage) */\r\nextern X_DCDC_Buck_T DCDC_Buck_X;\r\n\r\n/* Block states (default storage) */\r\nextern DW_DCDC_Buck_T DCDC_Buck_DW;\r\n\r\n/* global MassMatrix */\r\nextern MassMatrix_DCDC_Buck_T DCDC_Buck_MassMatrix;\r\n\r\n/* Model entry point functions */\r\nextern void DCDC_Buck_initialize(void);\r\nextern void DCDC_Buck_step(void);\r\nextern void DCDC_Buck_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_DCDC_Buck_T *const DCDC_Buck_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S4>/IQN x IQN1_boundary_DTC' : Eliminate redundant data type conversion\r\n * Block '<S4>/Subsystem_boundary_DTC1' : Eliminate redundant data type conversion\r\n * Block '<S5>/Rate Transition' : Eliminated since input and output rates are identical\r\n * Block '<S1>/Rate Transition1' : Eliminated since input and output rates are identical\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'DCDC_Buck'\r\n * '<S1>'   : 'DCDC_Buck/Controller'\r\n * '<S2>'   : 'DCDC_Buck/DC//DC_Buck_PLANT'\r\n * '<S3>'   : 'DCDC_Buck/Controller/Controller'\r\n * '<S4>'   : 'DCDC_Buck/Controller/Controller/PI_Controller'\r\n * '<S5>'   : 'DCDC_Buck/Controller/Controller/Subsystem'\r\n * '<S6>'   : 'DCDC_Buck/Controller/Controller/PI_Controller/Subsystem'\r\n * '<S7>'   : 'DCDC_Buck/Controller/Controller/PI_Controller/Subsystem/Compare To Constant'\r\n * '<S8>'   : 'DCDC_Buck/Controller/Controller/PI_Controller/Subsystem/Compare To Constant1'\r\n * '<S9>'   : 'DCDC_Buck/Controller/Controller/Subsystem/Sawtooth_Generator'\r\n * '<S10>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/Active_Load'\r\n * '<S11>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck'\r\n * '<S12>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/PS-Simulink Converter'\r\n * '<S13>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'\r\n * '<S14>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/Simulink-PS Converter1'\r\n * '<S15>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/Simulink-PS Converter1/EVAL_KEY'\r\n * '<S16>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor'\r\n * '<S17>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS Converter'\r\n * '<S18>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS Converter1'\r\n * '<S19>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS Converter3'\r\n * '<S20>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/PS-Simulink Converter'\r\n * '<S21>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/PS-Simulink Converter/EVAL_KEY'\r\n * '<S22>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS Converter/EVAL_KEY'\r\n * '<S23>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS Converter1/EVAL_KEY'\r\n * '<S24>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS Converter3/EVAL_KEY'\r\n * '<S25>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/PS-Simulink Converter/EVAL_KEY'\r\n * '<S26>'  : 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration/EVAL_KEY'\r\n */\r\n#endif                                 /* RTW_HEADER_DCDC_Buck_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCDC_Buck_private.h","type":"header","group":"model","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: DCDC_Buck_private.h\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_DCDC_Buck_private_h_\r\n#define RTW_HEADER_DCDC_Buck_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFFFU) ) || ( SCHAR_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFU) ) || ( INT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFUL) ) || ( LONG_MAX != (0x7FFFFFFFL) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n/* Skipping ulong_long/long_long check: insufficient preprocessor integer range. */\r\n\r\n/* private model entry point functions */\r\nextern void DCDC_Buck_derivatives(void);\r\n\r\n#endif                                 /* RTW_HEADER_DCDC_Buck_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCDC_Buck_types.h","type":"header","group":"model","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: DCDC_Buck_types.h\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_DCDC_Buck_types_h_\r\n#define RTW_HEADER_DCDC_Buck_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\n/* Model Code Variants */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_DCDC_Buck_T_ P_DCDC_Buck_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_DCDC_Buck_T RT_MODEL_DCDC_Buck_T;\r\n\r\n#endif                                 /* RTW_HEADER_DCDC_Buck_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCDC_Buck_data.c","type":"source","group":"data","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * File: DCDC_Buck_data.c\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"DCDC_Buck.h\"\r\n#include \"DCDC_Buck_private.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_DCDC_Buck_T DCDC_Buck_P = {\r\n  /* Variable: FPWM\r\n   * Referenced by: '<S9>/Gain1'\r\n   */\r\n  200000.0,\r\n\r\n  /* Variable: Gi\r\n   * Referenced by: '<S16>/Gain'\r\n   */\r\n  0.439,\r\n\r\n  /* Variable: Tpwm\r\n   * Referenced by: '<S9>/Time_Period'\r\n   */\r\n  5.0E-6,\r\n\r\n  /* Variable: VSF\r\n   * Referenced by:\r\n   *   '<S1>/VoltageScaling'\r\n   *   '<S1>/VoltageScaling1'\r\n   */\r\n  0.439,\r\n\r\n  /* Mask Parameter: CompareToConstant_const\r\n   * Referenced by: '<S7>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: CompareToConstant1_const\r\n   * Referenced by: '<S8>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Expression: 0.003\r\n   * Referenced by: '<S1>/Constant2'\r\n   */\r\n  0.003,\r\n\r\n  /* Expression: 0.05\r\n   * Referenced by: '<S2>/Step'\r\n   */\r\n  0.05,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S2>/Step'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S2>/Step'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 9\r\n   * Referenced by: '<S10>/Gain'\r\n   */\r\n  9.0,\r\n\r\n  /* Expression: 5\r\n   * Referenced by: '<S1>/Constant'\r\n   */\r\n  5.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S3>/PerUnitConvRate'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S1>/Unit Delay'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S3>/PerUnitConvRate1'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0.003\r\n   * Referenced by: '<S1>/Constant1'\r\n   */\r\n  0.003,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S6>/Unit Delay'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1/TBPRD\r\n   * Referenced by: '<S5>/Inverse TBPRD'\r\n   */\r\n  0.001,\r\n\r\n  /* Expression: 9\r\n   * Referenced by: '<S3>/Gain6'\r\n   */\r\n  9.0,\r\n\r\n  /* Computed Parameter: Constant_Value_f\r\n   * Referenced by: '<S6>/Constant'\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: UnitDelay_InitialCondition_f\r\n   * Referenced by: '<S4>/Unit Delay'\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: Saturation_UpperSat\r\n   * Referenced by: '<S4>/Saturation'\r\n   */\r\n  13421773,\r\n\r\n  /* Computed Parameter: Saturation_LowerSat\r\n   * Referenced by: '<S4>/Saturation'\r\n   */\r\n  0,\r\n\r\n  /* Expression: TBPRD\r\n   * Referenced by: '<S3>/Gain4'\r\n   */\r\n  1000,\r\n\r\n  /* Computed Parameter: UnitDelay1_InitialCondition\r\n   * Referenced by: '<S6>/Unit Delay1'\r\n   */\r\n  false\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: multiword_types.h\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Texas Instruments->C2000\r\n *   Number of bits:     char:  16    short:   16    int:  16\r\n *                       long:  32    long long:  64\r\n *                       native word size:  16\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *                                                                       *\r\n *                                                                       *\r\n *   Note:  Because the specified hardware does not have native support  *\r\n *          for all data sizes, some data types are actually typedef'ed  *\r\n *          from larger native data sizes.  The following data types are *\r\n *          not in the ideal native data types:                          *\r\n *                                                                       *\r\n *          int8_T, uint8_T                                              *\r\n *=======================================================================*/\r\ntypedef int int8_T;\r\ntypedef unsigned int uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned int boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ext_mode_types.h","type":"header","group":"interface","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * ext_mode_types.h\r\n *\r\n * Code generation for model \"DCDC_Buck\".\r\n *\r\n * Model version              : 1.6\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef EXT_MODE_TYPES_H\r\n#define EXT_MODE_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/** External Mode Event ID */\r\ntypedef uint16_T extmodeEventId_T;\r\n\r\n/** External Mode real time, measured using the target's clock */\r\ntypedef uint32_T extmodeRealTime_T;\r\n\r\n/** External Mode simulation time */\r\ntypedef uint32_T extmodeSimulationTime_T;\r\n\r\n/** External Mode double data type */\r\ntypedef real_T extmodeDouble_T;\r\n\r\n/** External Mode classic trigger signal */\r\ntypedef real_T extmodeClassicTriggerSignal_T;\r\n\r\n/** Run the simulation forever (infinite simulation end time) */\r\n#define EXTMODE_SIMULATION_RUN_FOREVER ((extmodeSimulationTime_T) -1)\r\n\r\n/** External Mode MAX simulation time */\r\n#define MAX_extmodeSimulationTime_T    MAX_uint32_T\r\n\r\n/** External Mode MAX base rate simulation time */\r\n#define EXTMODE_MAX_BASE_RATE_SIMULATION_TIME MAX_uint32_T\r\n\r\n/** External Mode Step Size in microseconds */\r\n#define EXTMODE_STEP_SIZE_IN_MICROSECONDS 5\r\n\r\n/** External Mode Base rate event id */\r\n#define EXTMODE_BASE_RATE_EVENT_ID     1\r\n\r\n/** External Mode Max Event Id */\r\n#define EXTMODE_MAX_EVENT_ID           0xFF\r\n#endif                                 /* EXT_MODE_TYPES_H */\r\n\r\n/* [EOF] ext_mode_types.h */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'DCDC_Buck'.\r\n *\r\n * Model version                  : 1.6\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sat Mar 16 15:06:16 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"DCDC_Buck.h\"\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCDC_Buck_9d5357ce_1.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_std.h\"\r\n#include \"pm_default_allocator.h\"\r\n#include \"ne_dae_fwd.h\"\r\n#include \"ne_profiler_fwd.h\"\r\n#include \"ne_dae_construct.h\"\r\n#include \"nesl_la.h\"\r\n#include \"DCDC_Buck_9d5357ce_1.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n\r\nvoid DCDC_Buck_9d5357ce_1_dae( NeDae **dae, const NeModelParameters *modelParams,\r\n  const NeSolverParameters *solverParams)\r\n{\r\n  PmAllocator *ne_allocator;\r\n  const McLinearAlgebraFactory *linear_algebra_ptr =\r\n    (solverParams->mLinearAlgebra == NE_FULL_LA) ?\r\n    get_rtw_linear_algebra() :\r\n    ((solverParams->mLinearAlgebra == NE_SPARSE_LA) ?\r\n     mc_get_csparse_linear_algebra() :\r\n     get_auto_linear_algebra());\r\n  NeRtpValues *rtpValues = NULL;\r\n  ne_allocator = pm_default_allocator();\r\n  ne_dae_create( dae,\r\n                DCDC_Buck_9d5357ce_1_dae_ds( ne_allocator ),\r\n                NULL,\r\n                FALSE,\r\n                rtpValues,\r\n                *solverParams,\r\n                *modelParams,\r\n                linear_algebra_ptr,\r\n                NULL,\r\n                NULL,\r\n                NULL,\r\n                ne_allocator,\r\n                DAEMON_CHOICE_NONE);\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#ifndef __DCDC_Buck_9d5357ce_1_h__\r\n#define __DCDC_Buck_9d5357ce_1_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void DCDC_Buck_9d5357ce_1_dae( NeDae **dae, const NeModelParameters\r\n    *modelParams,\r\n    const NeSolverParameters *solverParams);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif                                 /* ifndef __DCDC_Buck_9d5357ce_1_h__ */\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds.c - body for module DCDC_Buck_9d5357ce_1_ds */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_zc.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_tdxy_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_dxy_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_exp.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_m_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_log.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_all.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_imax.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_act.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_imin.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_tdxf_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_a_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_il.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_a.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_dxf_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_dxf.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_mode.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_f.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_assert.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"ssc_ml_fun.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n\r\nstatic int32_T ds_m(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dum_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dum(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_b_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_b(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_c_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_c(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vpf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vsf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf0(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_duf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_duf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_tduf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_v_x(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cer(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ic(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_icr(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_im(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_id(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_il(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mdxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_y(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_dxy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_duy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_duy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dty_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dty(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_r(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_i(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_sfo(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_sfp(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_init_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_init_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_passert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_iassert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_t(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v0(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_tmax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_l(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_j(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qx(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qu(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qt(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_q1(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qx_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qu_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_q1_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_var_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_eq_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_slv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_nldv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_sclv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dimin(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dimax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic void release_reference(NeDynamicSystem *ds);\r\nstatic void get_reference(NeDynamicSystem *ds);\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T);\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp);\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr);\r\nstatic NeEquationData s_equation_data[31] = { { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U,\r\n    0U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 1U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 2U, TRUE, 1.0, \"1\", }, {\r\n    \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 3U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 4U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 5U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 6U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 7U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 8U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 9U, TRUE, 1.0, \"1\", },\r\n    { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 10U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 11U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 2U, 12U, TRUE, 1.0, \"1\", }, {\r\n    \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 3U, 14U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 3U, 17U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 20U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 21U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 22U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 23U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 24U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 25U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 26U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 5U, 27U, FALSE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 5U, 32U, FALSE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 5U, 37U, FALSE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 3U, 42U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 3U, 45U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 3U, 48U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 3U, 51U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 3U, 54U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 3U, 57U, TRUE, 1.0, \"1\",\r\n  } };\r\n\r\nstatic NeCERData *s_cer_data = NULL;\r\nstatic NeICRData *s_icr_data = NULL;\r\nstatic NeVariableData s_variable_data[31] = { {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1.0, \"1\", 0.0, TRUE, FALSE, 1U,\r\n    1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1.0, \"1\", 0.0, TRUE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1.0, \"1\", 0.0, TRUE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.i_L\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1.0, \"1\", 0.0, TRUE, FALSE, 1U,\r\n    1U, NE_INIT_MODE_MANDATORY, \"Inductor current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.Cjunction.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1.0, \"1\", 0.0, TRUE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_NONE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.Cjunction.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1.0, \"1\", 0.0, TRUE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_NONE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.Cjunction.vc\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1.0, \"1\", 0.0, TRUE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_NONE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.D.v\", 0U, 1,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"i\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1.0, \"1\", 0.0, FALSE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1.0, \"1\", 0.0, FALSE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1.0, \"1\", 0.0,\r\n    FALSE, FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1.0, \"1\", 0.0,\r\n    FALSE, FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1.0, \"1\", 0.0, FALSE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.n.v\", 0U, 1,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1.0, \"1\", 0.0,\r\n    FALSE, FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1.0, \"1\", 0.0,\r\n    FALSE, FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.i_capacitor\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1.0, \"1\", 0.0, FALSE, FALSE,\r\n    1U, 1U, NE_INIT_MODE_NONE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"i\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.i_capacitor\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"i\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.i_capacitor\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.i\", 0U, 0,\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_NONE, \"i\", } };\r\n\r\nstatic NeVariableData *s_discrete_data = NULL;\r\nstatic NeObservableData s_observable_data[278] = { {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.D.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"G\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.S.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.Tsim\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.i_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.i_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.v_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.ni.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode.v_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.isOn\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"isOn\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Power dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.Simulink_PS_Converter1_output\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/Simulink-PS\\nConverter1\", 1U, 1U,\r\n    \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter1_output\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.x0.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Active_Load.x1.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 1U, \"kW\", 1.0e-6, \"kW\",\r\n    NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 1U, \"kW\", 1.0e-6,\r\n    \"kW\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 1U, \"kW\", 1.0e-6, \"kW\",\r\n    NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Conn1.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Conn2.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Conn3.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 1U, \"kW\",\r\n    1.0e-6, \"kW\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 1U, \"kW\",\r\n    1.0e-6, \"kW\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 1U, \"kW\",\r\n    1.0e-6, \"kW\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 1U, \"kW\",\r\n    1.0e-6, \"kW\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 1U, \"kW\",\r\n    1.0e-6, \"kW\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 1U, \"kW\",\r\n    1.0e-6, \"kW\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Conn0.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor\", 1U, 1U, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Conn1.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor\", 1U, 1U, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Electrical_Reference.V.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Electrical Reference\",\r\n    1U, 1U, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Op_Amp.i1\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Op-Amp\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Input current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Op_Amp.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Op-Amp\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Op_Amp.out.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Op-Amp\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Op_Amp.outI\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Op-Amp\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current into output node\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Op_Amp.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Op-Amp\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Op_Amp.v1\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Op-Amp\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Input voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R10.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R10\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R10.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R10\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R10.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R10\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R10.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R10\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R10.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R10\", 1U, 1U,\r\n    \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R11.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R11\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R11.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R11\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R11.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R11\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R11.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R11\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R11.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R11\", 1U, 1U,\r\n    \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R22.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R22.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R22.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R22.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R22.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 1U,\r\n    \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R8.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R8\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R8.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R8\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R8.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R8\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R8.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R8\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R8.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R8\", 1U, 1U,\r\n    \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R9.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R9\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R9.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R9\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R9.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R9\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R9.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R9\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R9.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R9\", 1U, 1U,\r\n    \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Voltage_Sensor.V\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Voltage Sensor\", 1U,\r\n    1U, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"V\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Voltage_Sensor.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Voltage Sensor\", 1U,\r\n    1U, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Voltage_Sensor.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/Voltage Sensor\", 1U,\r\n    1U, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Voltage_Sensor_V\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/PS-Simulink\\nConverter\",\r\n    1U, 1U, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage_Sensor_V\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.Cjunction.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.Cjunction.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.Cjunction.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.Cjunction.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.Cjunction.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.Tsim\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.i_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.i_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.v_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.ni.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.ohmicResistance.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.ohmicResistance.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.ohmicResistance.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.ohmicResistance.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.pi.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.v_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.Cjunction.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.Cjunction.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.Cjunction.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.Cjunction.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.Cjunction.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.Tsim\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.i_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.i_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.v_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.ni.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.ohmicResistance.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.ohmicResistance.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.ohmicResistance.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.ohmicResistance.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.pi.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.v_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.Cjunction.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.Cjunction.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.Cjunction.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.Cjunction.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.Cjunction.vc\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Capacitor voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.Tsim\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.i_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.i_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.v_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.ni.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.ohmicResistance.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.ohmicResistance.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.ohmicResistance.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.ohmicResistance.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.pi.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.v_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.i_L\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Inductor current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 1U, \"kW\", 1.0e-6, \"kW\",\r\n    NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.D.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"G\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.S.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.Tsim\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.i_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.i_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.v_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.ni.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode.v_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.isOn\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"isOn\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Power dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.D.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"G\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.S.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.Tsim\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.i_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.i_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.v_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.ni.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode.v_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.isOn\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"isOn\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Power dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.D.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"G\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.S.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.Tsim\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.i_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.i_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.v_diode\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.ni.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode.v_capacitor\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.G\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.isOn\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"isOn\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Power dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.power_dissipated\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1U, 1U, \"A^2*Ohm\", 1.0e-6,\r\n    \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter1_output\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS\\nConverter1\", 1U, 1U,\r\n    \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter1_output\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter3_output\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS\\nConverter3\", 1U, 1U,\r\n    \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter3_output\", }, {\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter_output\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Simulink-PS\\nConverter\", 1U, 1U,\r\n    \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter_output\", }, {\r\n    \"DC_DC_Buck_PLANT.Electrical_Reference.V.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Electrical Reference\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Output_Voltage.V\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Output Voltage\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"V\", }, {\r\n    \"DC_DC_Buck_PLANT.Output_Voltage.n.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Output Voltage\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Output_Voltage.p.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Output Voltage\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Output_Voltage_V\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PS-Simulink\\nConverter\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Output_Voltage_V\", }, {\r\n    \"DC_DC_Buck_PLANT.PR1.i\", \"DCDC_Buck/DC//DC_Buck_PLANT/PR1\", 1U, 1U, \"A\",\r\n    1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.PR1.n.v\", \"DCDC_Buck/DC//DC_Buck_PLANT/PR1\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.PR1.p.v\", \"DCDC_Buck/DC//DC_Buck_PLANT/PR1\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"DC_DC_Buck_PLANT.PR1.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PR1\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.PR1.power_dissipated\", \"DCDC_Buck/DC//DC_Buck_PLANT/PR1\",\r\n    1U, 1U, \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE,\r\n    \"power_dissipated\", }, { \"DC_DC_Buck_PLANT.PR2.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PR2\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.PR2.n.v\", \"DCDC_Buck/DC//DC_Buck_PLANT/PR2\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.PR2.p.v\", \"DCDC_Buck/DC//DC_Buck_PLANT/PR2\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"DC_DC_Buck_PLANT.PR2.v\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PR2\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.PR2.power_dissipated\", \"DCDC_Buck/DC//DC_Buck_PLANT/PR2\",\r\n    1U, 1U, \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE,\r\n    \"power_dissipated\", }, { \"DC_DC_Buck_PLANT.Source.i\",\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Source\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_DC_Buck_PLANT.Source.n.v\", \"DCDC_Buck/DC//DC_Buck_PLANT/Source\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Source.p.v\", \"DCDC_Buck/DC//DC_Buck_PLANT/Source\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_DC_Buck_PLANT.Source.v\", \"DCDC_Buck/DC//DC_Buck_PLANT/Source\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", } };\r\n\r\nstatic NeModeData *s_major_mode_data = NULL;\r\nstatic NeZCData s_zc_data[11] = { {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 0U,\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U,\r\n    1U, \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U,\r\n    2U, \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U,\r\n    3U, \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U,\r\n    4U, \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U,\r\n    5U, \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U,\r\n    6U, \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U,\r\n    7U, \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U,\r\n    8U, \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U,\r\n    9U, \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U,\r\n    10U, \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    NE_ZC_TYPE_FALSE, } };\r\n\r\nstatic NeRange s_range[11] = { {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, } };\r\n\r\nstatic NeAssertData s_assert_data[78] = { {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 0U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 1U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 2U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C2+C3\", 1U, 3U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C2C3.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 4U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 5U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 6U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C4+C5+C6\", 1U, 7U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C4C5C6.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 8U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 9U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 10U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/C8\", 1U, 11U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.C8.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 12U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 13U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 14U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C10\", 1U, 15U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C10.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 16U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 17U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 18U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C11\", 1U, 19U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C11.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 20U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 21U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 22U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C12\", 1U, 23U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C12.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 24U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 25U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 26U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C13\", 1U, 27U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C13.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 28U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 29U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 30U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C14\", 1U, 31U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C14.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 32U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 33U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 34U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/C22\", 1U, 35U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.C22.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R10\", 1U, 36U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R10.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R10\", 1U, 37U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R10.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R11\", 1U, 38U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R11.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R11\", 1U, 39U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R11.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 40U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R22.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R22\", 1U, 41U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R22.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R8\", 1U, 42U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R8.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R8\", 1U, 43U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R8.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R9\", 1U, 44U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R9.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Current_Sensor/R9\", 1U, 45U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.R9.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 46U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.ohmicResistance.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode\", 1U, 47U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode.private.ohmicResistance.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 48U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.ohmicResistance.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode1\", 1U, 49U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode1.private.ohmicResistance.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 50U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.ohmicResistance.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/Diode2\", 1U, 51U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Diode2.private.ohmicResistance.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 52U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 53U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 54U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/L1\", 1U, 55U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.L1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1U, 56U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/R4\", 1U, 57U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.R4.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PR1\", 1U, 58U,\r\n    \"DC_DC_Buck_PLANT.PR1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PR1\", 1U, 59U,\r\n    \"DC_DC_Buck_PLANT.PR1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PR2\", 1U, 60U,\r\n    \"DC_DC_Buck_PLANT.PR2.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/PR2\", 1U, 61U,\r\n    \"DC_DC_Buck_PLANT.PR2.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 62U,\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 63U,\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 64U,\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Active_Load/MOSFET\", 1U, 65U,\r\n    \"DC_DC_Buck_PLANT.Active_Load.MOSFET.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 66U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 67U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 68U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET1\", 1U, 69U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET1.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 70U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 71U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 72U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET2\", 1U, 73U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET2.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 74U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 75U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 76U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.diode\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/DC//DC Buck/MOSFET3\", 1U, 77U,\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.MOSFET3.mosfet_equation\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", } };\r\n\r\nstatic NeRange s_assert_range[78] = { {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    25U, 31U, 25U, 32U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    25U, 27U, 25U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    25U, 39U, 25U, 40U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    25U, 37U, 25U, 38U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, } };\r\n\r\nstatic NeAssertData *s_param_assert_data = NULL;\r\nstatic NeRange *s_param_assert_range = NULL;\r\nstatic NeAssertData *s_initial_assert_data = NULL;\r\nstatic NeRange *s_initial_assert_range = NULL;\r\nstatic NeRange s_equation_range[60] = { {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    34U, 5U, 34U, 23U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/inductor.ssc\",\r\n    34U, 20U, 34U, 27U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    35U, 5U, 35U, 18U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    35U, 5U, 35U, 18U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    35U, 5U, 35U, 18U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    35U, 5U, 35U, 18U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    35U, 5U, 35U, 18U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    35U, 5U, 35U, 18U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+electrical/branch.ssc\",\r\n    23U, 5U, 23U, 19U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+semiconductors/+mosfet_ideal/mosfet_equation.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, } };\r\n\r\nstatic NeRange *s_cer_range = NULL;\r\nstatic NeRange *s_icr_range = NULL;\r\nstatic NeParameterData *s_logical_parameter_data = NULL;\r\nstatic NeParameterData *s_integer_parameter_data = NULL;\r\nstatic NeParameterData *s_index_parameter_data = NULL;\r\nstatic NeParameterData *s_real_parameter_data = NULL;\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM_P.mNumCol = 31;\r\n  out->mM_P.mNumRow = 31;\r\n  out->mM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    13);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM.mN = 13;\r\n  out->mM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 13);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMM.mN = 13;\r\n  out->mVMM.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    13);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM_P.mNumCol = 31;\r\n  out->mDXM_P.mNumRow = 13;\r\n  out->mDXM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mDXM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM.mN = 0;\r\n  out->mDXM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM_P.mNumCol = 0;\r\n  out->mDDM_P.mNumRow = 13;\r\n  out->mDDM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDDM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM.mN = 0;\r\n  out->mDDM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM_P.mNumCol = 4;\r\n  out->mDUM_P.mNumRow = 13;\r\n  out->mDUM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mDUM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM.mN = 0;\r\n  out->mDUM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM_P.mNumCol = 1;\r\n  out->mDTM_P.mNumRow = 13;\r\n  out->mDTM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM.mN = 0;\r\n  out->mDTM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM_P.mNumCol = 0;\r\n  out->mDPM_P.mNumRow = 13;\r\n  out->mDPM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDPM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM.mN = 0;\r\n  out->mDPM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA_P.mNumCol = 31;\r\n  out->mA_P.mNumRow = 31;\r\n  out->mA_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mA_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    83);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA.mN = 83;\r\n  out->mA.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 83);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB_P.mNumCol = 4;\r\n  out->mB_P.mNumRow = 31;\r\n  out->mB_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mB_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB.mN = 0;\r\n  out->mB.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC_P.mNumCol = 1;\r\n  out->mC_P.mNumRow = 31;\r\n  out->mC_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mC_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC.mN = 0;\r\n  out->mC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mF.mN = 31;\r\n  out->mF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMF.mN = 31;\r\n  out->mVMF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVPF.mN = 31;\r\n  out->mVPF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVSF.mN = 31;\r\n  out->mVSF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF.mN = 31;\r\n  out->mSLF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF0.mN = 31;\r\n  out->mSLF0.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF_P.mNumCol = 31;\r\n  out->mDXF_P.mNumRow = 31;\r\n  out->mDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    37);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF.mN = 37;\r\n  out->mDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 37);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF_P.mNumCol = 4;\r\n  out->mDUF_P.mNumRow = 31;\r\n  out->mDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF.mN = 0;\r\n  out->mDUF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF_P.mNumCol = 1;\r\n  out->mDTF_P.mNumRow = 31;\r\n  out->mDTF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF.mN = 0;\r\n  out->mDTF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF_P.mNumCol = 0;\r\n  out->mDDF_P.mNumRow = 31;\r\n  out->mDDF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDDF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF.mN = 0;\r\n  out->mDDF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF_P.mNumCol = 0;\r\n  out->mDPDXF_P.mNumRow = 37;\r\n  out->mDPDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDPDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF.mN = 0;\r\n  out->mDPDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF_P.mNumCol = 0;\r\n  out->mDWF_P.mNumRow = 31;\r\n  out->mDWF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDWF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF.mN = 0;\r\n  out->mDWF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUF_P.mNumCol = 4;\r\n  out->mTDUF_P.mNumRow = 31;\r\n  out->mTDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mTDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXF_P.mNumCol = 31;\r\n  out->mTDXF_P.mNumRow = 31;\r\n  out->mTDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mTDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    120);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_P.mNumCol = 32;\r\n  out->mDNF_P.mNumRow = 31;\r\n  out->mDNF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    33);\r\n  out->mDNF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF.mN = 0;\r\n  out->mDNF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_V_X.mN = 31;\r\n  out->mDNF_V_X.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCER.mN = 0;\r\n  out->mCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER.mN = 0;\r\n  out->mDXCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER_P.mNumCol = 31;\r\n  out->mDXCER_P.mNumRow = 0;\r\n  out->mDXCER_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 32);\r\n  out->mDXCER_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIC.mN = 31;\r\n  out->mIC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR.mN = 0;\r\n  out->mICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IM.mN = 0;\r\n  out->mICR_IM.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_ID.mN = 0;\r\n  out->mICR_ID.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IL.mN = 0;\r\n  out->mICR_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR.mN = 0;\r\n  out->mDXICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR_P.mNumCol = 31;\r\n  out->mDXICR_P.mNumRow = 0;\r\n  out->mDXICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 32);\r\n  out->mDXICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR.mN = 0;\r\n  out->mDDICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR_P.mNumCol = 0;\r\n  out->mDDICR_P.mNumRow = 0;\r\n  out->mDDICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDDICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUICR_P.mNumCol = 4;\r\n  out->mTDUICR_P.mNumRow = 0;\r\n  out->mTDUICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 5);\r\n  out->mTDUICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM_P.mNumCol = 31;\r\n  out->mICRM_P.mNumRow = 0;\r\n  out->mICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM.mN = 0;\r\n  out->mICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM_P.mNumCol = 31;\r\n  out->mDXICRM_P.mNumRow = 0;\r\n  out->mDXICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 32);\r\n  out->mDXICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM.mN = 0;\r\n  out->mDXICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM_P.mNumCol = 0;\r\n  out->mDDICRM_P.mNumRow = 0;\r\n  out->mDDICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDDICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM.mN = 0;\r\n  out->mDDICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDUY_P.mNumCol = 4;\r\n  out->mMDUY_P.mNumRow = 2;\r\n  out->mMDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mMDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDXY_P.mNumCol = 31;\r\n  out->mMDXY_P.mNumRow = 2;\r\n  out->mMDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mMDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUY_P.mNumCol = 4;\r\n  out->mTDUY_P.mNumRow = 2;\r\n  out->mTDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mTDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXY_P.mNumCol = 31;\r\n  out->mTDXY_P.mNumRow = 2;\r\n  out->mTDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mTDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mY.mN = 2;\r\n  out->mY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY_P.mNumCol = 31;\r\n  out->mDXY_P.mNumRow = 2;\r\n  out->mDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY.mN = 4;\r\n  out->mDXY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY_P.mNumCol = 4;\r\n  out->mDUY_P.mNumRow = 2;\r\n  out->mDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY.mN = 0;\r\n  out->mDUY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY_P.mNumCol = 1;\r\n  out->mDTY_P.mNumRow = 2;\r\n  out->mDTY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY.mN = 0;\r\n  out->mDTY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMODE.mN = 11;\r\n  out->mMODE.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    11);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mZC.mN = 11;\r\n  out->mZC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 11);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_R.mN = 0;\r\n  out->mCACHE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_I.mN = 0;\r\n  out->mCACHE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_R.mN = 0;\r\n  out->mUPDATE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_I.mN = 0;\r\n  out->mUPDATE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_R.mN = 0;\r\n  out->mUPDATE2_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_I.mN = 0;\r\n  out->mUPDATE2_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_R.mN = 0;\r\n  out->mLOCK_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_I.mN = 0;\r\n  out->mLOCK_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_R.mN = 0;\r\n  out->mLOCK2_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_I.mN = 0;\r\n  out->mLOCK2_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFO.mN = 0;\r\n  out->mSFO.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFP.mN = 0;\r\n  out->mSFP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_R.mN = 0;\r\n  out->mINIT_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_I.mN = 0;\r\n  out->mINIT_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOG.mN = 208;\r\n  out->mLOG.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 208);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mASSERT.mN = 78;\r\n  out->mASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    78);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mPASSERT.mN = 0;\r\n  out->mPASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIASSERT.mN = 0;\r\n  out->mIASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_T.mN = 0;\r\n  out->mDEL_T.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V.mN = 0;\r\n  out->mDEL_V.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V0.mN = 0;\r\n  out->mDEL_V0.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_TMAX.mN = 0;\r\n  out->mDEL_TMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT_P.mNumCol = 31;\r\n  out->mDXDELT_P.mNumRow = 0;\r\n  out->mDXDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 32);\r\n  out->mDXDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT.mN = 0;\r\n  out->mDXDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT_P.mNumCol = 4;\r\n  out->mDUDELT_P.mNumRow = 0;\r\n  out->mDUDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 5);\r\n  out->mDUDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT.mN = 0;\r\n  out->mDUDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT_P.mNumCol = 1;\r\n  out->mDTDELT_P.mNumRow = 0;\r\n  out->mDTDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDTDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT.mN = 0;\r\n  out->mDTDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_EXP.mN = 260;\r\n  out->mOBS_EXP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    260);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ACT.mN = 260;\r\n  out->mOBS_ACT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    260);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ALL.mN = 260;\r\n  out->mOBS_ALL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    260);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_IL.mN = 260;\r\n  out->mOBS_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 260);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_L.mN = 0;\r\n  out->mDP_L.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_I.mN = 0;\r\n  out->mDP_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_J.mN = 0;\r\n  out->mDP_J.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_R.mN = 0;\r\n  out->mDP_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX.mN = 0;\r\n  out->mQX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU.mN = 0;\r\n  out->mQU.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT.mN = 0;\r\n  out->mQT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1.mN = 0;\r\n  out->mQ1.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX_P.mNumCol = 31;\r\n  out->mQX_P.mNumRow = 31;\r\n  out->mQX_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    32);\r\n  out->mQX_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU_P.mNumCol = 4;\r\n  out->mQU_P.mNumRow = 31;\r\n  out->mQU_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  out->mQU_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT_P.mNumCol = 1;\r\n  out->mQT_P.mNumRow = 31;\r\n  out->mQT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1_P.mNumCol = 1;\r\n  out->mQ1_P.mNumRow = 31;\r\n  out->mQ1_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQ1_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVAR_TOL.mN = 31;\r\n  out->mVAR_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mEQ_TOL.mN = 31;\r\n  out->mEQ_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLV.mN = 31;\r\n  out->mLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLV.mN = 31;\r\n  out->mSLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mNLDV.mN = 31;\r\n  out->mNLDV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSCLV.mN = 31;\r\n  out->mSCLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMIN.mN = 31;\r\n  out->mIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMAX.mN = 31;\r\n  out->mIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 31);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMIN.mN = 0;\r\n  out->mDIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMAX.mN = 0;\r\n  out->mDIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic void release_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  if (--_ds->mRefCnt == 0) {\r\n    _ds->mAlloc.mFreeFcn(&_ds->mAlloc, _ds);\r\n  }\r\n}\r\n\r\nstatic void get_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  ++_ds->mRefCnt;\r\n}\r\n\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T kp)\r\n{\r\n  _NeDynamicSystem *_ds = (_NeDynamicSystem *)ds;\r\n  (void) kp;\r\n  ne_ds_get_reference(&_ds->mBase);\r\n  return &_ds->mBase;\r\n}\r\n\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp)\r\n{\r\n  (void)ds;\r\n  (void)kp;\r\n  memcpy(out->mX, in->mX.mX, sizeof(real_T)*out->mN);\r\n}\r\n\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr)\r\n{\r\n  (void)ds;\r\n  memcpy(outl->mX, inl->mX, sizeof(int32_T)*inl->mN);\r\n  memcpy(outi->mX, ini->mX, sizeof(int32_T)*ini->mN);\r\n  memcpy(outj->mX, inj->mX, sizeof(int32_T)*inj->mN);\r\n  memcpy(outr->mX, inr->mX, sizeof(real_T)*inr->mN);\r\n}\r\n\r\nNeDynamicSystem *DCDC_Buck_9d5357ce_1_dae_ds(PmAllocator *allocator)\r\n{\r\n  NeDynamicSystem *ds;\r\n  _NeDynamicSystem *_ds;\r\n  static NeDsIoInfo input_info[4];\r\n  static NeDsIoInfo output_info[2];\r\n\r\n  /* allocate dynamic system data and extended data */\r\n  _ds = (_NeDynamicSystem *)allocator->mCallocFcn( allocator, sizeof\r\n    (_NeDynamicSystem), 1);\r\n  _ds->mAlloc = *allocator;\r\n  _ds->mRefCnt = 1;\r\n  ds = &_ds->mBase;\r\n\r\n  /* setup sizes */\r\n  ds->mNumVariables = 31;\r\n  ds->mNumDiscreteRealVariables = 0;\r\n  ds->mNumDifferentialVariables = 13;\r\n  ds->mNumEquations = 31;\r\n  ds->mNumCEResiduals = 0;\r\n  ds->mNumICResiduals = 0;\r\n  ds->mNumModes = 11;\r\n  ds->mNumMajorModes = 0;\r\n  ds->mNumRealCache = 0;\r\n  ds->mNumIntCache = 0;\r\n  ds->mNumObservables = 278;\r\n  ds->mNumObservableElements = 260;\r\n  ds->mNumZcs = 11;\r\n  ds->mNumAsserts = 78;\r\n  ds->mNumAssertRanges = 78;\r\n  ds->mNumParamAsserts = 0;\r\n  ds->mNumParamAssertRanges = 0;\r\n  ds->mNumInitialAsserts = 0;\r\n  ds->mNumInitialAssertRanges = 0;\r\n  ds->mNumRanges = 11;\r\n  ds->mNumEquationRanges = 60;\r\n  ds->mNumCERRanges = 0;\r\n  ds->mNumICRRanges = 0;\r\n  ds->mNumFundamentalSamples = 0;\r\n  ds->mNumDelays = 0;\r\n  ds->mNumLogicalParameters = 0;\r\n  ds->mNumIntegerParameters = 0;\r\n  ds->mNumIndexParameters = 0;\r\n  ds->mNumRealParameters = 0;\r\n  ds->mNumLogicalDerivedParameters = 0;\r\n  ds->mNumIntegerDerivedParameters = 0;\r\n  ds->mNumIndexDerivedParameters = 0;\r\n  ds->mNumRealDerivedParameters = 0;\r\n  ds->mIsOutputLinear = TRUE;\r\n  ds->mIsOutputSwitchedLinear = TRUE;\r\n  ds->mIsScalable = FALSE;\r\n\r\n  /* setup ios */\r\n  ds->mNumIo[NE_INPUT_IO_TYPE] = 4;\r\n  input_info[0].mIdentifier =\r\n    \"DC_DC_Buck_PLANT.Active_Load.Simulink_PS_Converter1_output\";\r\n  input_info[0].mM = 1;\r\n  input_info[0].mN = 1;\r\n  input_info[0].mName =\r\n    \"DC_DC_Buck_PLANT.Active_Load.Simulink_PS_Converter1_output\";\r\n  input_info[0].mUnit = \"1\";\r\n  input_info[1].mIdentifier =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter1_output\";\r\n  input_info[1].mM = 1;\r\n  input_info[1].mN = 1;\r\n  input_info[1].mName =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter1_output\";\r\n  input_info[1].mUnit = \"1\";\r\n  input_info[2].mIdentifier =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter_output\";\r\n  input_info[2].mM = 1;\r\n  input_info[2].mN = 1;\r\n  input_info[2].mName =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter_output\";\r\n  input_info[2].mUnit = \"1\";\r\n  input_info[3].mIdentifier =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter3_output\";\r\n  input_info[3].mM = 1;\r\n  input_info[3].mN = 1;\r\n  input_info[3].mName =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Simulink_PS_Converter3_output\";\r\n  input_info[3].mUnit = \"1\";\r\n  ds->mIo[NE_INPUT_IO_TYPE] = input_info;\r\n  ds->mNumIo[NE_OUTPUT_IO_TYPE] = 2;\r\n  output_info[0].mIdentifier =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Voltage_Sensor_V\";\r\n  output_info[0].mM = 1;\r\n  output_info[0].mN = 1;\r\n  output_info[0].mName =\r\n    \"DC_DC_Buck_PLANT.DC_DC_Buck.Current_Sensor.Voltage_Sensor_V\";\r\n  output_info[0].mUnit = \"V\";\r\n  output_info[1].mIdentifier = \"DC_DC_Buck_PLANT.Output_Voltage_V\";\r\n  output_info[1].mM = 1;\r\n  output_info[1].mN = 1;\r\n  output_info[1].mName = \"DC_DC_Buck_PLANT.Output_Voltage_V\";\r\n  output_info[1].mUnit = \"V\";\r\n  ds->mIo[NE_OUTPUT_IO_TYPE] = output_info;\r\n\r\n  /* setup administration methods */\r\n  ds->mReleaseReference = release_reference;\r\n  ds->mGetReference = get_reference;\r\n  ds->mDiagnosticsDsFcn = diagnostics;\r\n  ds->mExpandFcn = expand;\r\n  ds->mRtpMapFcn = rtpmap;\r\n  ds->mMethods[NE_DS_METHOD_M_P] = DCDC_Buck_9d5357ce_1_ds_m_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_M_P] = ds_output_m_p;\r\n  ds->mMethods[NE_DS_METHOD_M] = ds_m;\r\n  ds->mMakeOutput[NE_DS_METHOD_M] = ds_output_m;\r\n  ds->mMethods[NE_DS_METHOD_VMM] = ds_vmm;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMM] = ds_output_vmm;\r\n  ds->mMethods[NE_DS_METHOD_DXM_P] = ds_dxm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM_P] = ds_output_dxm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXM] = ds_dxm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM] = ds_output_dxm;\r\n  ds->mMethods[NE_DS_METHOD_DDM_P] = ds_ddm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM_P] = ds_output_ddm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDM] = ds_ddm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM] = ds_output_ddm;\r\n  ds->mMethods[NE_DS_METHOD_DUM_P] = ds_dum_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM_P] = ds_output_dum_p;\r\n  ds->mMethods[NE_DS_METHOD_DUM] = ds_dum;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM] = ds_output_dum;\r\n  ds->mMethods[NE_DS_METHOD_DTM_P] = ds_dtm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM_P] = ds_output_dtm_p;\r\n  ds->mMethods[NE_DS_METHOD_DTM] = ds_dtm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM] = ds_output_dtm;\r\n  ds->mMethods[NE_DS_METHOD_DPM_P] = ds_dpm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM_P] = ds_output_dpm_p;\r\n  ds->mMethods[NE_DS_METHOD_DPM] = ds_dpm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM] = ds_output_dpm;\r\n  ds->mMethods[NE_DS_METHOD_A_P] = DCDC_Buck_9d5357ce_1_ds_a_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_A_P] = ds_output_a_p;\r\n  ds->mMethods[NE_DS_METHOD_A] = DCDC_Buck_9d5357ce_1_ds_a;\r\n  ds->mMakeOutput[NE_DS_METHOD_A] = ds_output_a;\r\n  ds->mMethods[NE_DS_METHOD_B_P] = ds_b_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_B_P] = ds_output_b_p;\r\n  ds->mMethods[NE_DS_METHOD_B] = ds_b;\r\n  ds->mMakeOutput[NE_DS_METHOD_B] = ds_output_b;\r\n  ds->mMethods[NE_DS_METHOD_C_P] = ds_c_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_C_P] = ds_output_c_p;\r\n  ds->mMethods[NE_DS_METHOD_C] = ds_c;\r\n  ds->mMakeOutput[NE_DS_METHOD_C] = ds_output_c;\r\n  ds->mMethods[NE_DS_METHOD_F] = DCDC_Buck_9d5357ce_1_ds_f;\r\n  ds->mMakeOutput[NE_DS_METHOD_F] = ds_output_f;\r\n  ds->mMethods[NE_DS_METHOD_VMF] = ds_vmf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMF] = ds_output_vmf;\r\n  ds->mMethods[NE_DS_METHOD_VPF] = ds_vpf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VPF] = ds_output_vpf;\r\n  ds->mMethods[NE_DS_METHOD_VSF] = ds_vsf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VSF] = ds_output_vsf;\r\n  ds->mMethods[NE_DS_METHOD_SLF] = ds_slf;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF] = ds_output_slf;\r\n  ds->mMethods[NE_DS_METHOD_SLF0] = ds_slf0;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF0] = ds_output_slf0;\r\n  ds->mMethods[NE_DS_METHOD_DXF_P] = DCDC_Buck_9d5357ce_1_ds_dxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF_P] = ds_output_dxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DXF] = DCDC_Buck_9d5357ce_1_ds_dxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF] = ds_output_dxf;\r\n  ds->mMethods[NE_DS_METHOD_DUF_P] = ds_duf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF_P] = ds_output_duf_p;\r\n  ds->mMethods[NE_DS_METHOD_DUF] = ds_duf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF] = ds_output_duf;\r\n  ds->mMethods[NE_DS_METHOD_DTF_P] = ds_dtf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF_P] = ds_output_dtf_p;\r\n  ds->mMethods[NE_DS_METHOD_DTF] = ds_dtf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF] = ds_output_dtf;\r\n  ds->mMethods[NE_DS_METHOD_DDF_P] = ds_ddf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF_P] = ds_output_ddf_p;\r\n  ds->mMethods[NE_DS_METHOD_DDF] = ds_ddf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF] = ds_output_ddf;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF_P] = ds_dpdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF_P] = ds_output_dpdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF] = ds_dpdxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF] = ds_output_dpdxf;\r\n  ds->mMethods[NE_DS_METHOD_DWF_P] = ds_dwf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF_P] = ds_output_dwf_p;\r\n  ds->mMethods[NE_DS_METHOD_DWF] = ds_dwf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF] = ds_output_dwf;\r\n  ds->mMethods[NE_DS_METHOD_TDUF_P] = ds_tduf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUF_P] = ds_output_tduf_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXF_P] = DCDC_Buck_9d5357ce_1_ds_tdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXF_P] = ds_output_tdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF_P] = ds_dnf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_P] = ds_output_dnf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF] = ds_dnf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF] = ds_output_dnf;\r\n  ds->mMethods[NE_DS_METHOD_DNF_V_X] = ds_dnf_v_x;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_V_X] = ds_output_dnf_v_x;\r\n  ds->mMethods[NE_DS_METHOD_CER] = ds_cer;\r\n  ds->mMakeOutput[NE_DS_METHOD_CER] = ds_output_cer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER] = ds_dxcer;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER] = ds_output_dxcer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER_P] = ds_dxcer_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER_P] = ds_output_dxcer_p;\r\n  ds->mMethods[NE_DS_METHOD_IC] = ds_ic;\r\n  ds->mMakeOutput[NE_DS_METHOD_IC] = ds_output_ic;\r\n  ds->mMethods[NE_DS_METHOD_ICR] = ds_icr;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR] = ds_output_icr;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IM] = ds_icr_im;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IM] = ds_output_icr_im;\r\n  ds->mMethods[NE_DS_METHOD_ICR_ID] = ds_icr_id;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_ID] = ds_output_icr_id;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IL] = ds_icr_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IL] = ds_output_icr_il;\r\n  ds->mMethods[NE_DS_METHOD_DXICR] = ds_dxicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR] = ds_output_dxicr;\r\n  ds->mMethods[NE_DS_METHOD_DXICR_P] = ds_dxicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR_P] = ds_output_dxicr_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICR] = ds_ddicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR] = ds_output_ddicr;\r\n  ds->mMethods[NE_DS_METHOD_DDICR_P] = ds_ddicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR_P] = ds_output_ddicr_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUICR_P] = ds_tduicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUICR_P] = ds_output_tduicr_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM_P] = ds_icrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM_P] = ds_output_icrm_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM] = ds_icrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM] = ds_output_icrm;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM_P] = ds_dxicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM_P] = ds_output_dxicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM] = ds_dxicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM] = ds_output_dxicrm;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM_P] = ds_ddicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM_P] = ds_output_ddicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM] = ds_ddicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM] = ds_output_ddicrm;\r\n  ds->mMethods[NE_DS_METHOD_MDUY_P] = ds_mduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDUY_P] = ds_output_mduy_p;\r\n  ds->mMethods[NE_DS_METHOD_MDXY_P] = ds_mdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDXY_P] = ds_output_mdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUY_P] = ds_tduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUY_P] = ds_output_tduy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXY_P] = DCDC_Buck_9d5357ce_1_ds_tdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXY_P] = ds_output_tdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_Y] = ds_y;\r\n  ds->mMakeOutput[NE_DS_METHOD_Y] = ds_output_y;\r\n  ds->mMethods[NE_DS_METHOD_DXY_P] = DCDC_Buck_9d5357ce_1_ds_dxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY_P] = ds_output_dxy_p;\r\n  ds->mMethods[NE_DS_METHOD_DXY] = ds_dxy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY] = ds_output_dxy;\r\n  ds->mMethods[NE_DS_METHOD_DUY_P] = ds_duy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY_P] = ds_output_duy_p;\r\n  ds->mMethods[NE_DS_METHOD_DUY] = ds_duy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY] = ds_output_duy;\r\n  ds->mMethods[NE_DS_METHOD_DTY_P] = ds_dty_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY_P] = ds_output_dty_p;\r\n  ds->mMethods[NE_DS_METHOD_DTY] = ds_dty;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY] = ds_output_dty;\r\n  ds->mMethods[NE_DS_METHOD_MODE] = DCDC_Buck_9d5357ce_1_ds_mode;\r\n  ds->mMakeOutput[NE_DS_METHOD_MODE] = ds_output_mode;\r\n  ds->mMethods[NE_DS_METHOD_ZC] = DCDC_Buck_9d5357ce_1_ds_zc;\r\n  ds->mMakeOutput[NE_DS_METHOD_ZC] = ds_output_zc;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_R] = ds_cache_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_R] = ds_output_cache_r;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_I] = ds_cache_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_I] = ds_output_cache_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_R] = ds_update_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_R] = ds_output_update_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_I] = ds_update_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_I] = ds_output_update_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_R] = ds_update2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_R] = ds_output_update2_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_I] = ds_update2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_I] = ds_output_update2_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_R] = ds_lock_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_R] = ds_output_lock_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_I] = ds_lock_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_I] = ds_output_lock_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_R] = ds_lock2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_R] = ds_output_lock2_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_I] = ds_lock2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_I] = ds_output_lock2_i;\r\n  ds->mMethods[NE_DS_METHOD_SFO] = ds_sfo;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFO] = ds_output_sfo;\r\n  ds->mMethods[NE_DS_METHOD_SFP] = ds_sfp;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFP] = ds_output_sfp;\r\n  ds->mMethods[NE_DS_METHOD_INIT_R] = ds_init_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_R] = ds_output_init_r;\r\n  ds->mMethods[NE_DS_METHOD_INIT_I] = ds_init_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_I] = ds_output_init_i;\r\n  ds->mMethods[NE_DS_METHOD_LOG] = DCDC_Buck_9d5357ce_1_ds_log;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOG] = ds_output_log;\r\n  ds->mMethods[NE_DS_METHOD_ASSERT] = DCDC_Buck_9d5357ce_1_ds_assert;\r\n  ds->mMakeOutput[NE_DS_METHOD_ASSERT] = ds_output_assert;\r\n  ds->mMethods[NE_DS_METHOD_PASSERT] = ds_passert;\r\n  ds->mMakeOutput[NE_DS_METHOD_PASSERT] = ds_output_passert;\r\n  ds->mMethods[NE_DS_METHOD_IASSERT] = ds_iassert;\r\n  ds->mMakeOutput[NE_DS_METHOD_IASSERT] = ds_output_iassert;\r\n  ds->mMethods[NE_DS_METHOD_DEL_T] = ds_del_t;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_T] = ds_output_del_t;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V] = ds_del_v;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V] = ds_output_del_v;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V0] = ds_del_v0;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V0] = ds_output_del_v0;\r\n  ds->mMethods[NE_DS_METHOD_DEL_TMAX] = ds_del_tmax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_TMAX] = ds_output_del_tmax;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT_P] = ds_dxdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT_P] = ds_output_dxdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT] = ds_dxdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT] = ds_output_dxdelt;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT_P] = ds_dudelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT_P] = ds_output_dudelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT] = ds_dudelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT] = ds_output_dudelt;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT_P] = ds_dtdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT_P] = ds_output_dtdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT] = ds_dtdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT] = ds_output_dtdelt;\r\n  ds->mMethods[NE_DS_METHOD_OBS_EXP] = DCDC_Buck_9d5357ce_1_ds_obs_exp;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_EXP] = ds_output_obs_exp;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ACT] = DCDC_Buck_9d5357ce_1_ds_obs_act;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ACT] = ds_output_obs_act;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ALL] = DCDC_Buck_9d5357ce_1_ds_obs_all;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ALL] = ds_output_obs_all;\r\n  ds->mMethods[NE_DS_METHOD_OBS_IL] = DCDC_Buck_9d5357ce_1_ds_obs_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_IL] = ds_output_obs_il;\r\n  ds->mMethods[NE_DS_METHOD_DP_L] = ds_dp_l;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_L] = ds_output_dp_l;\r\n  ds->mMethods[NE_DS_METHOD_DP_I] = ds_dp_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_I] = ds_output_dp_i;\r\n  ds->mMethods[NE_DS_METHOD_DP_J] = ds_dp_j;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_J] = ds_output_dp_j;\r\n  ds->mMethods[NE_DS_METHOD_DP_R] = ds_dp_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_R] = ds_output_dp_r;\r\n  ds->mMethods[NE_DS_METHOD_QX] = ds_qx;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX] = ds_output_qx;\r\n  ds->mMethods[NE_DS_METHOD_QU] = ds_qu;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU] = ds_output_qu;\r\n  ds->mMethods[NE_DS_METHOD_QT] = ds_qt;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT] = ds_output_qt;\r\n  ds->mMethods[NE_DS_METHOD_Q1] = ds_q1;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1] = ds_output_q1;\r\n  ds->mMethods[NE_DS_METHOD_QX_P] = ds_qx_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX_P] = ds_output_qx_p;\r\n  ds->mMethods[NE_DS_METHOD_QU_P] = ds_qu_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU_P] = ds_output_qu_p;\r\n  ds->mMethods[NE_DS_METHOD_QT_P] = ds_qt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT_P] = ds_output_qt_p;\r\n  ds->mMethods[NE_DS_METHOD_Q1_P] = ds_q1_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1_P] = ds_output_q1_p;\r\n  ds->mMethods[NE_DS_METHOD_VAR_TOL] = ds_var_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_VAR_TOL] = ds_output_var_tol;\r\n  ds->mMethods[NE_DS_METHOD_EQ_TOL] = ds_eq_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_EQ_TOL] = ds_output_eq_tol;\r\n  ds->mMethods[NE_DS_METHOD_LV] = ds_lv;\r\n  ds->mMakeOutput[NE_DS_METHOD_LV] = ds_output_lv;\r\n  ds->mMethods[NE_DS_METHOD_SLV] = ds_slv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLV] = ds_output_slv;\r\n  ds->mMethods[NE_DS_METHOD_NLDV] = ds_nldv;\r\n  ds->mMakeOutput[NE_DS_METHOD_NLDV] = ds_output_nldv;\r\n  ds->mMethods[NE_DS_METHOD_SCLV] = ds_sclv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SCLV] = ds_output_sclv;\r\n  ds->mMethods[NE_DS_METHOD_IMIN] = DCDC_Buck_9d5357ce_1_ds_imin;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMIN] = ds_output_imin;\r\n  ds->mMethods[NE_DS_METHOD_IMAX] = DCDC_Buck_9d5357ce_1_ds_imax;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMAX] = ds_output_imax;\r\n  ds->mMethods[NE_DS_METHOD_DIMIN] = ds_dimin;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMIN] = ds_output_dimin;\r\n  ds->mMethods[NE_DS_METHOD_DIMAX] = ds_dimax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMAX] = ds_output_dimax;\r\n\r\n  /* equation data */\r\n  ds->mEquationData = s_equation_data;\r\n\r\n  /* cer data */\r\n  ds->mCERData = s_cer_data;\r\n\r\n  /* icr data */\r\n  ds->mICRData = s_icr_data;\r\n\r\n  /* continuous variable data */\r\n  ds->mVariableData = s_variable_data;\r\n\r\n  /* discrete variable data */\r\n  ds->mDiscreteData = s_discrete_data;\r\n\r\n  /* observable data */\r\n  ds->mObservableData = s_observable_data;\r\n\r\n  /* major mode data */\r\n  ds->mMajorModeData = s_major_mode_data;\r\n\r\n  /* zc data */\r\n  ds->mZCData = s_zc_data;\r\n\r\n  /* ranges */\r\n  ds->mRanges = s_range;\r\n\r\n  /* assert data */\r\n  ds->mAssertData = s_assert_data;\r\n\r\n  /* assert ranges */\r\n  ds->mAssertRanges = s_assert_range;\r\n\r\n  /* param assert data */\r\n  ds->mParamAssertData = s_param_assert_data;\r\n\r\n  /* param assert ranges */\r\n  ds->mParamAssertRanges = s_param_assert_range;\r\n\r\n  /* initial assert data */\r\n  ds->mInitialAssertData = s_initial_assert_data;\r\n\r\n  /* initial assert ranges */\r\n  ds->mInitialAssertRanges = s_initial_assert_range;\r\n\r\n  /* equation ranges */\r\n  ds->mEquationRanges = s_equation_range;\r\n\r\n  /* cer ranges */\r\n  ds->mCERRanges = s_cer_range;\r\n\r\n  /* icr ranges */\r\n  ds->mICRRanges = s_icr_range;\r\n\r\n  /* parameters */\r\n  ds->mLogicalParameters = s_logical_parameter_data;\r\n  ds->mIntegerParameters = s_integer_parameter_data;\r\n  ds->mIndexParameters = s_index_parameter_data;\r\n  ds->mRealParameters = s_real_parameter_data;\r\n\r\n  /* constant tables */\r\n  ds->mNumLargeArray = 0;\r\n  return (NeDynamicSystem *)_ds;\r\n}\r\n\r\nstatic int32_T ds_passert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_iassert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cer (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXCER_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_tmax (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_t (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXDELT_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUDELT_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTDELT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfp (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfo (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUF_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mB_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mC_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUF_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 3;\r\n  out.mJc[4] = 4;\r\n  out.mIr[0] = 14;\r\n  out.mIr[1] = 26;\r\n  out.mIr[2] = 28;\r\n  out.mIr[3] = 30;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDWF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPDXF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 37ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = true;\r\n  out.mX[14] = true;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = true;\r\n  out.mX[23] = true;\r\n  out.mX[24] = true;\r\n  out.mX[25] = true;\r\n  out.mX[26] = true;\r\n  out.mX[27] = true;\r\n  out.mX[28] = true;\r\n  out.mX[29] = true;\r\n  out.mX[30] = true;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDNF_P;\r\n  out.mNumCol = 32ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  out.mJc[32] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_v_x (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mDNF_V_X;\r\n  out.mX[0] = true;\r\n  out.mX[1] = true;\r\n  out.mX[2] = true;\r\n  out.mX[3] = true;\r\n  out.mX[4] = true;\r\n  out.mX[5] = true;\r\n  out.mX[6] = true;\r\n  out.mX[7] = true;\r\n  out.mX[8] = true;\r\n  out.mX[9] = true;\r\n  out.mX[10] = true;\r\n  out.mX[11] = true;\r\n  out.mX[12] = true;\r\n  out.mX[13] = true;\r\n  out.mX[14] = true;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = true;\r\n  out.mX[23] = true;\r\n  out.mX[24] = true;\r\n  out.mX[25] = true;\r\n  out.mX[26] = true;\r\n  out.mX[27] = true;\r\n  out.mX[28] = true;\r\n  out.mX[29] = true;\r\n  out.mX[30] = true;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF0;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vpf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVPF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vsf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVSF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ic (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIC;\r\n  out.mX[0] = 0.0;\r\n  out.mX[1] = 0.0;\r\n  out.mX[2] = 0.0;\r\n  out.mX[3] = 0.0;\r\n  out.mX[4] = 0.0;\r\n  out.mX[5] = 0.0;\r\n  out.mX[6] = 0.0;\r\n  out.mX[7] = 0.0;\r\n  out.mX[8] = 0.0;\r\n  out.mX[9] = 0.0;\r\n  out.mX[10] = 0.0;\r\n  out.mX[11] = 0.0;\r\n  out.mX[12] = 0.0;\r\n  out.mX[13] = 0.0;\r\n  out.mX[14] = 0.0;\r\n  out.mX[15] = 0.0;\r\n  out.mX[16] = 0.0;\r\n  out.mX[17] = 0.0;\r\n  out.mX[18] = 0.0;\r\n  out.mX[19] = 0.0;\r\n  out.mX[20] = 0.0;\r\n  out.mX[21] = 0.0;\r\n  out.mX[22] = 0.0;\r\n  out.mX[23] = 0.0;\r\n  out.mX[24] = 0.0;\r\n  out.mX[25] = 0.0;\r\n  out.mX[26] = 0.0;\r\n  out.mX[27] = 0.0;\r\n  out.mX[28] = 0.0;\r\n  out.mX[29] = 0.0;\r\n  out.mX[30] = 0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_im (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_id (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_il (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICR_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICR_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUICR_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mICRM_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICRM_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICRM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimin (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimax (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_m (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mM;\r\n  out.mX[0] = -0.00033;\r\n  out.mX[1] = -4.4E-5;\r\n  out.mX[2] = -1.0E-11;\r\n  out.mX[3] = -6.5999999999999992E-5;\r\n  out.mX[4] = -4.8E-6;\r\n  out.mX[5] = -2.2E-10;\r\n  out.mX[6] = -2.2E-10;\r\n  out.mX[7] = -1.0E-9;\r\n  out.mX[8] = -1.0E-11;\r\n  out.mX[9] = -3.3E-9;\r\n  out.mX[10] = -5.0E-12;\r\n  out.mX[11] = -5.0E-12;\r\n  out.mX[12] = -5.0E-12;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXM_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 13ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 13ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUM_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 13ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 13ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 13ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMM;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_l (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_j (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1 (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQX_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQU_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQ1_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_var_tol (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mVAR_TOL;\r\n  out.mX[0] = 1.0E-8;\r\n  out.mX[1] = 1.0E-8;\r\n  out.mX[2] = 1.0E-8;\r\n  out.mX[3] = 1.0E-8;\r\n  out.mX[4] = 1.0E-8;\r\n  out.mX[5] = 1.0E-8;\r\n  out.mX[6] = 1.0E-8;\r\n  out.mX[7] = 1.0E-8;\r\n  out.mX[8] = 1.0E-8;\r\n  out.mX[9] = 1.0E-8;\r\n  out.mX[10] = 1.0E-8;\r\n  out.mX[11] = 1.0E-8;\r\n  out.mX[12] = 1.0E-8;\r\n  out.mX[13] = 1.0E-8;\r\n  out.mX[14] = 1.0E-8;\r\n  out.mX[15] = 1.0E-8;\r\n  out.mX[16] = 1.0E-8;\r\n  out.mX[17] = 1.0E-8;\r\n  out.mX[18] = 1.0E-8;\r\n  out.mX[19] = 1.0E-8;\r\n  out.mX[20] = 1.0E-8;\r\n  out.mX[21] = 1.0E-8;\r\n  out.mX[22] = 1.0E-8;\r\n  out.mX[23] = 1.0E-8;\r\n  out.mX[24] = 1.0E-8;\r\n  out.mX[25] = 1.0E-8;\r\n  out.mX[26] = 1.0E-8;\r\n  out.mX[27] = 1.0E-8;\r\n  out.mX[28] = 1.0E-8;\r\n  out.mX[29] = 1.0E-8;\r\n  out.mX[30] = 1.0E-8;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_eq_tol (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mEQ_TOL;\r\n  out.mX[0] = 1.0E-8;\r\n  out.mX[1] = 1.0E-8;\r\n  out.mX[2] = 1.0E-8;\r\n  out.mX[3] = 1.0E-8;\r\n  out.mX[4] = 1.0E-8;\r\n  out.mX[5] = 1.0E-8;\r\n  out.mX[6] = 1.0E-8;\r\n  out.mX[7] = 1.0E-8;\r\n  out.mX[8] = 1.0E-8;\r\n  out.mX[9] = 1.0E-8;\r\n  out.mX[10] = 1.0E-8;\r\n  out.mX[11] = 1.0E-8;\r\n  out.mX[12] = 1.0E-8;\r\n  out.mX[13] = 1.0E-8;\r\n  out.mX[14] = 1.0E-8;\r\n  out.mX[15] = 1.0E-8;\r\n  out.mX[16] = 1.0E-8;\r\n  out.mX[17] = 1.0E-8;\r\n  out.mX[18] = 1.0E-8;\r\n  out.mX[19] = 1.0E-8;\r\n  out.mX[20] = 1.0E-8;\r\n  out.mX[21] = 1.0E-8;\r\n  out.mX[22] = 1.0E-8;\r\n  out.mX[23] = 1.0E-8;\r\n  out.mX[24] = 1.0E-8;\r\n  out.mX[25] = 1.0E-8;\r\n  out.mX[26] = 1.0E-8;\r\n  out.mX[27] = 1.0E-8;\r\n  out.mX[28] = 1.0E-8;\r\n  out.mX[29] = 1.0E-8;\r\n  out.mX[30] = 1.0E-8;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lv (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = true;\r\n  out.mX[17] = true;\r\n  out.mX[18] = true;\r\n  out.mX[19] = true;\r\n  out.mX[20] = true;\r\n  out.mX[21] = true;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = true;\r\n  out.mX[17] = true;\r\n  out.mX[18] = true;\r\n  out.mX[19] = true;\r\n  out.mX[20] = true;\r\n  out.mX[21] = true;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_nldv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mNLDV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sclv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSCLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  out.mX[16] = false;\r\n  out.mX[17] = false;\r\n  out.mX[18] = false;\r\n  out.mX[19] = false;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = false;\r\n  out.mX[23] = false;\r\n  out.mX[24] = false;\r\n  out.mX[25] = false;\r\n  out.mX[26] = false;\r\n  out.mX[27] = false;\r\n  out.mX[28] = false;\r\n  out.mX[29] = false;\r\n  out.mX[30] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_y (const NeDynamicSystem *sys, const NeDynamicSystemInput *t3,\r\n                     NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T X_idx_0;\r\n  real_T X_idx_15;\r\n  real_T X_idx_21;\r\n  real_T X_idx_9;\r\n  X_idx_0 = t3->mX.mX[0];\r\n  X_idx_9 = t3->mX.mX[9];\r\n  X_idx_15 = t3->mX.mX[15];\r\n  X_idx_21 = t3->mX.mX[21];\r\n  out = t4->mY;\r\n  out.mX[0] = X_idx_21 * 1.0E-6 + X_idx_9;\r\n  out.mX[1] = X_idx_15 * 0.002 + X_idx_0;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t5, NeDsMethodOutput *t6)\r\n{\r\n  PmRealVector out;\r\n  (void)t5;\r\n  out = t6->mDXY;\r\n  out.mX[0] = 1.0;\r\n  out.mX[1] = 1.0;\r\n  out.mX[2] = 0.002;\r\n  out.mX[3] = 1.0E-6;\r\n  (void)sys;\r\n  (void)t6;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUY_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDUY_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mdxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDXY_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  out.mJc[17] = 0;\r\n  out.mJc[18] = 0;\r\n  out.mJc[19] = 0;\r\n  out.mJc[20] = 0;\r\n  out.mJc[21] = 0;\r\n  out.mJc[22] = 0;\r\n  out.mJc[23] = 0;\r\n  out.mJc[24] = 0;\r\n  out.mJc[25] = 0;\r\n  out.mJc[26] = 0;\r\n  out.mJc[27] = 0;\r\n  out.mJc[28] = 0;\r\n  out.mJc[29] = 0;\r\n  out.mJc[30] = 0;\r\n  out.mJc[31] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUY_P;\r\n  out.mNumCol = 4ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTY_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds.h - header for module DCDC_Buck_9d5357ce_1_ds */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_H      1\r\n\r\n  extern NeDynamicSystem *DCDC_Buck_9d5357ce_1_dae_ds(PmAllocator *allocator );\r\n\r\n#endif                                 /* #ifndef DCDC_BUCK_9D5357CE_1_DS_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_a.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_a.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_a(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t69, NeDsMethodOutput *t70)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[83];\r\n  real_T t1[8];\r\n  real_T t13[8];\r\n  real_T t15[8];\r\n  real_T t17[7];\r\n  real_T t18[7];\r\n  real_T t16[6];\r\n  real_T t3[6];\r\n  real_T t5[5];\r\n  size_t t37;\r\n  (void)t69;\r\n  out = t70->mA;\r\n  t1[0ULL] = 0.6333333333333333;\r\n  t1[1ULL] = -0.0;\r\n  t1[2ULL] = 0.012195121951219513;\r\n  t1[3ULL] = 0.012195121951219513;\r\n  t1[4ULL] = 1.0;\r\n  t1[5ULL] = 1.0012666666666667;\r\n  t1[6ULL] = 1.000000012195122;\r\n  t1[7ULL] = 1.000000012195122;\r\n  t3[0ULL] = 0.00083333333333333339;\r\n  t3[1ULL] = -0.00083333333333333339;\r\n  t3[2ULL] = -0.0;\r\n  t3[3ULL] = 1.6666666666666669E-6;\r\n  t3[4ULL] = -8.3333333333333335E-10;\r\n  t3[5ULL] = 0.001;\r\n  t5[0ULL] = -1.0;\r\n  t5[1ULL] = -1.0;\r\n  t5[2ULL] = 0.0105;\r\n  t5[3ULL] = -1.0E-6;\r\n  t5[4ULL] = -1.0E-6;\r\n  t13[0ULL] = 1.0012666666666667;\r\n  t13[1ULL] = -1.0;\r\n  t13[2ULL] = 2.4390243902439026E-5;\r\n  t13[3ULL] = 2.4390243902439026E-5;\r\n  t13[4ULL] = 0.002;\r\n  t13[5ULL] = 0.004002533333333334;\r\n  t13[6ULL] = 0.0020000000243902438;\r\n  t13[7ULL] = 0.0020000000243902438;\r\n  t15[0ULL] = 1.0;\r\n  t15[1ULL] = -1.0;\r\n  t15[2ULL] = -1.0;\r\n  t15[3ULL] = -1.0;\r\n  t15[4ULL] = 0.002;\r\n  t15[5ULL] = -1.0E-6;\r\n  t15[6ULL] = -1.0E-6;\r\n  t15[7ULL] = -1.0E-6;\r\n  t16[0ULL] = 1.0000000008333334;\r\n  t16[1ULL] = -1.0000000008333334;\r\n  t16[2ULL] = -1.0;\r\n  t16[3ULL] = 0.0020000000016666668;\r\n  t16[4ULL] = -1.0000000008333334E-6;\r\n  t16[5ULL] = 9.9999999999999986E-10;\r\n  t17[0ULL] = -1.0;\r\n  t17[1ULL] = 1.0003658536585365;\r\n  t17[2ULL] = 0.99999999999999989;\r\n  t17[3ULL] = 0.03;\r\n  t17[4ULL] = -0.002;\r\n  t17[5ULL] = 0.030001000365853656;\r\n  t17[6ULL] = 9.9999999999999974E-7;\r\n  t18[0ULL] = -0.012195121951219513;\r\n  t18[1ULL] = -0.012195121951219513;\r\n  t18[2ULL] = 0.0008333333333333335;\r\n  t18[3ULL] = -1.000000012195122;\r\n  t18[4ULL] = -1.000000012195122;\r\n  t18[5ULL] = 1.0000000008333334;\r\n  t18[6ULL] = -0.001;\r\n  for (t37 = 0ULL; t37 < 8ULL; t37++) {\r\n    t0[t37] = t1[t37];\r\n  }\r\n\r\n  t0[8ULL] = -0.0;\r\n  t0[9ULL] = -1.0;\r\n  for (t37 = 0ULL; t37 < 6ULL; t37++) {\r\n    t0[t37 + 10ULL] = t3[t37];\r\n  }\r\n\r\n  t0[16ULL] = -0.0;\r\n  t0[17ULL] = -1.0;\r\n  for (t37 = 0ULL; t37 < 5ULL; t37++) {\r\n    t0[t37 + 18ULL] = t5[t37];\r\n  }\r\n\r\n  t0[23ULL] = -0.0;\r\n  t0[24ULL] = -1.0;\r\n  t0[25ULL] = -0.0;\r\n  t0[26ULL] = -1.0;\r\n  t0[27ULL] = -0.0;\r\n  t0[28ULL] = -1.0;\r\n  t0[29ULL] = -0.0;\r\n  t0[30ULL] = -1.0;\r\n  t0[31ULL] = -0.0;\r\n  t0[32ULL] = 0.001;\r\n  t0[33ULL] = -0.0;\r\n  t0[34ULL] = 1.0;\r\n  t0[35ULL] = -0.0;\r\n  t0[36ULL] = -0.0;\r\n  t0[37ULL] = -0.5;\r\n  t0[38ULL] = -0.001;\r\n  for (t37 = 0ULL; t37 < 8ULL; t37++) {\r\n    t0[t37 + 39ULL] = t13[t37];\r\n  }\r\n\r\n  t0[47ULL] = -1.0;\r\n  t0[48ULL] = -1.0E-6;\r\n  for (t37 = 0ULL; t37 < 8ULL; t37++) {\r\n    t0[t37 + 49ULL] = t15[t37];\r\n  }\r\n\r\n  for (t37 = 0ULL; t37 < 6ULL; t37++) {\r\n    t0[t37 + 57ULL] = t16[t37];\r\n  }\r\n\r\n  for (t37 = 0ULL; t37 < 7ULL; t37++) {\r\n    t0[t37 + 63ULL] = t17[t37];\r\n  }\r\n\r\n  for (t37 = 0ULL; t37 < 7ULL; t37++) {\r\n    t0[t37 + 70ULL] = t18[t37];\r\n  }\r\n\r\n  out.mX[0] = t0[0];\r\n  out.mX[1] = t0[1];\r\n  out.mX[2] = t0[2];\r\n  out.mX[3] = t0[3];\r\n  out.mX[4] = t0[4];\r\n  out.mX[5] = t0[5];\r\n  out.mX[6] = t0[6];\r\n  out.mX[7] = t0[7];\r\n  out.mX[8] = t0[8];\r\n  out.mX[9] = t0[9];\r\n  out.mX[10] = t0[10];\r\n  out.mX[11] = t0[11];\r\n  out.mX[12] = t0[12];\r\n  out.mX[13] = t0[13];\r\n  out.mX[14] = t0[14];\r\n  out.mX[15] = t0[15];\r\n  out.mX[16] = t0[16];\r\n  out.mX[17] = t0[17];\r\n  out.mX[18] = t0[18];\r\n  out.mX[19] = t0[19];\r\n  out.mX[20] = t0[20];\r\n  out.mX[21] = t0[21];\r\n  out.mX[22] = t0[22];\r\n  out.mX[23] = t0[23];\r\n  out.mX[24] = t0[24];\r\n  out.mX[25] = t0[25];\r\n  out.mX[26] = t0[26];\r\n  out.mX[27] = t0[27];\r\n  out.mX[28] = t0[28];\r\n  out.mX[29] = t0[29];\r\n  out.mX[30] = t0[30];\r\n  out.mX[31] = t0[31];\r\n  out.mX[32] = t0[32];\r\n  out.mX[33] = t0[33];\r\n  out.mX[34] = t0[34];\r\n  out.mX[35] = t0[35];\r\n  out.mX[36] = t0[36];\r\n  out.mX[37] = t0[37];\r\n  out.mX[38] = t0[38];\r\n  out.mX[39] = t0[39];\r\n  out.mX[40] = t0[40];\r\n  out.mX[41] = t0[41];\r\n  out.mX[42] = t0[42];\r\n  out.mX[43] = t0[43];\r\n  out.mX[44] = t0[44];\r\n  out.mX[45] = t0[45];\r\n  out.mX[46] = t0[46];\r\n  out.mX[47] = t0[47];\r\n  out.mX[48] = t0[48];\r\n  out.mX[49] = t0[49];\r\n  out.mX[50] = t0[50];\r\n  out.mX[51] = t0[51];\r\n  out.mX[52] = t0[52];\r\n  out.mX[53] = t0[53];\r\n  out.mX[54] = t0[54];\r\n  out.mX[55] = t0[55];\r\n  out.mX[56] = t0[56];\r\n  out.mX[57] = t0[57];\r\n  out.mX[58] = t0[58];\r\n  out.mX[59] = t0[59];\r\n  out.mX[60] = t0[60];\r\n  out.mX[61] = t0[61];\r\n  out.mX[62] = t0[62];\r\n  out.mX[63] = t0[63];\r\n  out.mX[64] = t0[64];\r\n  out.mX[65] = t0[65];\r\n  out.mX[66] = t0[66];\r\n  out.mX[67] = t0[67];\r\n  out.mX[68] = t0[68];\r\n  out.mX[69] = t0[69];\r\n  out.mX[70] = t0[70];\r\n  out.mX[71] = t0[71];\r\n  out.mX[72] = t0[72];\r\n  out.mX[73] = t0[73];\r\n  out.mX[74] = t0[74];\r\n  out.mX[75] = t0[75];\r\n  out.mX[76] = t0[76];\r\n  out.mX[77] = -1.0;\r\n  out.mX[78] = 1.000000001;\r\n  out.mX[79] = -1.0;\r\n  out.mX[80] = 1.0E-6;\r\n  out.mX[81] = -1.0;\r\n  out.mX[82] = -1.0;\r\n  (void)sys;\r\n  (void)t70;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_a.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_a.h - header for method DCDC_Buck_9d5357ce_1_ds_a */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_A_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_A_H    1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_a(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                                 /* #ifndef DCDC_BUCK_9D5357CE_1_DS_A_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_a_p.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_a_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_a_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mA_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 8;\r\n  out.mJc[2] = 10;\r\n  out.mJc[3] = 16;\r\n  out.mJc[4] = 18;\r\n  out.mJc[5] = 23;\r\n  out.mJc[6] = 25;\r\n  out.mJc[7] = 27;\r\n  out.mJc[8] = 29;\r\n  out.mJc[9] = 31;\r\n  out.mJc[10] = 33;\r\n  out.mJc[11] = 35;\r\n  out.mJc[12] = 36;\r\n  out.mJc[13] = 37;\r\n  out.mJc[14] = 39;\r\n  out.mJc[15] = 39;\r\n  out.mJc[16] = 47;\r\n  out.mJc[17] = 49;\r\n  out.mJc[18] = 57;\r\n  out.mJc[19] = 63;\r\n  out.mJc[20] = 70;\r\n  out.mJc[21] = 77;\r\n  out.mJc[22] = 79;\r\n  out.mJc[23] = 81;\r\n  out.mJc[24] = 81;\r\n  out.mJc[25] = 81;\r\n  out.mJc[26] = 82;\r\n  out.mJc[27] = 82;\r\n  out.mJc[28] = 82;\r\n  out.mJc[29] = 83;\r\n  out.mJc[30] = 83;\r\n  out.mJc[31] = 83;\r\n  out.mIr[0] = 1;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 3;\r\n  out.mIr[3] = 4;\r\n  out.mIr[4] = 12;\r\n  out.mIr[5] = 16;\r\n  out.mIr[6] = 17;\r\n  out.mIr[7] = 18;\r\n  out.mIr[8] = 0;\r\n  out.mIr[9] = 15;\r\n  out.mIr[10] = 1;\r\n  out.mIr[11] = 4;\r\n  out.mIr[12] = 7;\r\n  out.mIr[13] = 16;\r\n  out.mIr[14] = 18;\r\n  out.mIr[15] = 21;\r\n  out.mIr[16] = 1;\r\n  out.mIr[17] = 16;\r\n  out.mIr[18] = 3;\r\n  out.mIr[19] = 6;\r\n  out.mIr[20] = 12;\r\n  out.mIr[21] = 17;\r\n  out.mIr[22] = 20;\r\n  out.mIr[23] = 3;\r\n  out.mIr[24] = 17;\r\n  out.mIr[25] = 4;\r\n  out.mIr[26] = 18;\r\n  out.mIr[27] = 5;\r\n  out.mIr[28] = 19;\r\n  out.mIr[29] = 6;\r\n  out.mIr[30] = 20;\r\n  out.mIr[31] = 8;\r\n  out.mIr[32] = 21;\r\n  out.mIr[33] = 9;\r\n  out.mIr[34] = 12;\r\n  out.mIr[35] = 10;\r\n  out.mIr[36] = 11;\r\n  out.mIr[37] = 1;\r\n  out.mIr[38] = 16;\r\n  out.mIr[39] = 1;\r\n  out.mIr[40] = 2;\r\n  out.mIr[41] = 3;\r\n  out.mIr[42] = 4;\r\n  out.mIr[43] = 12;\r\n  out.mIr[44] = 16;\r\n  out.mIr[45] = 17;\r\n  out.mIr[46] = 18;\r\n  out.mIr[47] = 0;\r\n  out.mIr[48] = 15;\r\n  out.mIr[49] = 1;\r\n  out.mIr[50] = 4;\r\n  out.mIr[51] = 5;\r\n  out.mIr[52] = 6;\r\n  out.mIr[53] = 16;\r\n  out.mIr[54] = 18;\r\n  out.mIr[55] = 19;\r\n  out.mIr[56] = 20;\r\n  out.mIr[57] = 1;\r\n  out.mIr[58] = 4;\r\n  out.mIr[59] = 7;\r\n  out.mIr[60] = 16;\r\n  out.mIr[61] = 18;\r\n  out.mIr[62] = 21;\r\n  out.mIr[63] = 1;\r\n  out.mIr[64] = 3;\r\n  out.mIr[65] = 6;\r\n  out.mIr[66] = 12;\r\n  out.mIr[67] = 16;\r\n  out.mIr[68] = 17;\r\n  out.mIr[69] = 20;\r\n  out.mIr[70] = 3;\r\n  out.mIr[71] = 4;\r\n  out.mIr[72] = 6;\r\n  out.mIr[73] = 17;\r\n  out.mIr[74] = 18;\r\n  out.mIr[75] = 20;\r\n  out.mIr[76] = 21;\r\n  out.mIr[77] = 8;\r\n  out.mIr[78] = 21;\r\n  out.mIr[79] = 9;\r\n  out.mIr[80] = 12;\r\n  out.mIr[81] = 10;\r\n  out.mIr[82] = 11;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_a_p.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_a_p.h - header for method DCDC_Buck_9d5357ce_1_ds_a_p */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_A_P_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_A_P_H  1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_a_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                               /* #ifndef DCDC_BUCK_9D5357CE_1_DS_A_P_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_assert.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_assert.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_assert(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmIntVector out;\r\n  (void)t1;\r\n  out = t2->mASSERT;\r\n  out.mX[0] = 1;\r\n  out.mX[1] = 1;\r\n  out.mX[2] = 1;\r\n  out.mX[3] = 1;\r\n  out.mX[4] = 1;\r\n  out.mX[5] = 1;\r\n  out.mX[6] = 1;\r\n  out.mX[7] = 1;\r\n  out.mX[8] = 1;\r\n  out.mX[9] = 1;\r\n  out.mX[10] = 1;\r\n  out.mX[11] = 1;\r\n  out.mX[12] = 1;\r\n  out.mX[13] = 1;\r\n  out.mX[14] = 1;\r\n  out.mX[15] = 1;\r\n  out.mX[16] = 1;\r\n  out.mX[17] = 1;\r\n  out.mX[18] = 1;\r\n  out.mX[19] = 1;\r\n  out.mX[20] = 1;\r\n  out.mX[21] = 1;\r\n  out.mX[22] = 1;\r\n  out.mX[23] = 1;\r\n  out.mX[24] = 1;\r\n  out.mX[25] = 1;\r\n  out.mX[26] = 1;\r\n  out.mX[27] = 1;\r\n  out.mX[28] = 1;\r\n  out.mX[29] = 1;\r\n  out.mX[30] = 1;\r\n  out.mX[31] = 1;\r\n  out.mX[32] = 1;\r\n  out.mX[33] = 1;\r\n  out.mX[34] = 1;\r\n  out.mX[35] = 1;\r\n  out.mX[36] = 1;\r\n  out.mX[37] = 1;\r\n  out.mX[38] = 1;\r\n  out.mX[39] = 1;\r\n  out.mX[40] = 1;\r\n  out.mX[41] = 1;\r\n  out.mX[42] = 1;\r\n  out.mX[43] = 1;\r\n  out.mX[44] = 1;\r\n  out.mX[45] = 1;\r\n  out.mX[46] = 1;\r\n  out.mX[47] = 1;\r\n  out.mX[48] = 1;\r\n  out.mX[49] = 1;\r\n  out.mX[50] = 1;\r\n  out.mX[51] = 1;\r\n  out.mX[52] = 1;\r\n  out.mX[53] = 1;\r\n  out.mX[54] = 1;\r\n  out.mX[55] = 1;\r\n  out.mX[56] = 1;\r\n  out.mX[57] = 1;\r\n  out.mX[58] = 1;\r\n  out.mX[59] = 1;\r\n  out.mX[60] = 1;\r\n  out.mX[61] = 1;\r\n  out.mX[62] = 1;\r\n  out.mX[63] = 1;\r\n  out.mX[64] = 1;\r\n  out.mX[65] = 1;\r\n  out.mX[66] = 1;\r\n  out.mX[67] = 1;\r\n  out.mX[68] = 1;\r\n  out.mX[69] = 1;\r\n  out.mX[70] = 1;\r\n  out.mX[71] = 1;\r\n  out.mX[72] = 1;\r\n  out.mX[73] = 1;\r\n  out.mX[74] = 1;\r\n  out.mX[75] = 1;\r\n  out.mX[76] = 1;\r\n  out.mX[77] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_assert.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_assert.h - header for method DCDC_Buck_9d5357ce_1_ds_assert */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_ASSERT_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_ASSERT_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_assert(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                            /* #ifndef DCDC_BUCK_9D5357CE_1_DS_ASSERT_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_dxf.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_dxf.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_dxf(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t89, NeDsMethodOutput *t90)\r\n{\r\n  PmRealVector out;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_22;\r\n  real_T X_idx_25;\r\n  real_T X_idx_28;\r\n  real_T intrm_sf_mf_14;\r\n  real_T t12;\r\n  real_T t2;\r\n  real_T t3;\r\n  real_T t4;\r\n  real_T t6;\r\n  real_T t7;\r\n  real_T t8;\r\n  real_T t9;\r\n  int32_T M_idx_0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_10;\r\n  int32_T M_idx_2;\r\n  int32_T M_idx_3;\r\n  int32_T M_idx_4;\r\n  int32_T M_idx_5;\r\n  int32_T M_idx_6;\r\n  int32_T M_idx_7;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_0 = t89->mM.mX[0];\r\n  M_idx_1 = t89->mM.mX[1];\r\n  M_idx_2 = t89->mM.mX[2];\r\n  M_idx_3 = t89->mM.mX[3];\r\n  M_idx_4 = t89->mM.mX[4];\r\n  M_idx_5 = t89->mM.mX[5];\r\n  M_idx_6 = t89->mM.mX[6];\r\n  M_idx_7 = t89->mM.mX[7];\r\n  M_idx_8 = t89->mM.mX[8];\r\n  M_idx_9 = t89->mM.mX[9];\r\n  M_idx_10 = t89->mM.mX[10];\r\n  X_idx_10 = t89->mX.mX[10];\r\n  X_idx_11 = t89->mX.mX[11];\r\n  X_idx_12 = t89->mX.mX[12];\r\n  X_idx_22 = t89->mX.mX[22];\r\n  X_idx_25 = t89->mX.mX[25];\r\n  X_idx_28 = t89->mX.mX[28];\r\n  out = t90->mDXF;\r\n  intrm_sf_mf_14 = (X_idx_28 * 1.0E-6 + X_idx_12) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  t8 = (X_idx_22 * 1.0E-6 + X_idx_10) * 1.602176487E-19 / 4.3497335432938027E-21;\r\n  X_idx_12 = (X_idx_25 * 1.0E-6 + X_idx_11) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  X_idx_28 = 1.602176487E-19;\r\n  X_idx_10 = X_idx_28 / 4.3497335432938027E-21;\r\n  X_idx_22 = 1.6021764869999998E-25;\r\n  X_idx_11 = X_idx_22 / 4.3497335432938027E-21;\r\n  X_idx_25 = X_idx_28 / 4.3497335432938027E-21;\r\n  t9 = X_idx_22 / 4.3497335432938027E-21;\r\n  t3 = X_idx_28 / 4.3497335432938027E-21;\r\n  X_idx_28 = X_idx_22 / 4.3497335432938027E-21;\r\n  if (t8 > 80.0) {\r\n    X_idx_22 = -(X_idx_25 * 3.4567260021088461E-12 * 5.54062238439351E+34);\r\n  } else if (M_idx_3 != 0) {\r\n    X_idx_22 = -(X_idx_25 * 3.4567260021088461E-12 * 4.9060947306492808E-35);\r\n  } else {\r\n    X_idx_22 = -(exp(t8) * X_idx_25 * 3.4567260021088461E-12);\r\n  }\r\n\r\n  if (M_idx_6 != 0) {\r\n    X_idx_25 = 1000.0;\r\n  } else {\r\n    X_idx_25 = 1.0E-5;\r\n  }\r\n\r\n  if (X_idx_12 > 80.0) {\r\n    t2 = -(t3 * 3.4567260021088461E-12 * 5.54062238439351E+34);\r\n  } else if (M_idx_4 != 0) {\r\n    t2 = -(t3 * 3.4567260021088461E-12 * 4.9060947306492808E-35);\r\n  } else {\r\n    t2 = -(exp(X_idx_12) * t3 * 3.4567260021088461E-12);\r\n  }\r\n\r\n  if (M_idx_8 != 0) {\r\n    t3 = 1000.0;\r\n  } else {\r\n    t3 = 1.0E-5;\r\n  }\r\n\r\n  if (intrm_sf_mf_14 > 80.0) {\r\n    t4 = -(X_idx_10 * 3.4567260021088461E-12 * 5.54062238439351E+34);\r\n  } else if (M_idx_5 != 0) {\r\n    t4 = -(X_idx_10 * 3.4567260021088461E-12 * 4.9060947306492808E-35);\r\n  } else {\r\n    t4 = -(exp(intrm_sf_mf_14) * X_idx_10 * 3.4567260021088461E-12);\r\n  }\r\n\r\n  if (M_idx_10 != 0) {\r\n    X_idx_10 = 1000.0;\r\n  } else {\r\n    X_idx_10 = 1.0E-5;\r\n  }\r\n\r\n  if (M_idx_0 != 0) {\r\n    t6 = 1000.5;\r\n  } else {\r\n    t6 = 0.50001;\r\n  }\r\n\r\n  if (t8 > 80.0) {\r\n    t7 = -1.0 - t9 * 3.4567260021088461E-12 * 5.54062238439351E+34;\r\n  } else if (M_idx_3 != 0) {\r\n    t7 = -1.0 - t9 * 3.4567260021088461E-12 * 4.9060947306492808E-35;\r\n  } else {\r\n    t7 = -1.0 - exp(t8) * t9 * 3.4567260021088461E-12;\r\n  }\r\n\r\n  if (M_idx_6 != 0) {\r\n    t8 = 0.001;\r\n  } else {\r\n    t8 = 1.0000000000000001E-11;\r\n  }\r\n\r\n  if (X_idx_12 > 80.0) {\r\n    t9 = -1.0 - X_idx_28 * 3.4567260021088461E-12 * 5.54062238439351E+34;\r\n  } else if (M_idx_4 != 0) {\r\n    t9 = -1.0 - X_idx_28 * 3.4567260021088461E-12 * 4.9060947306492808E-35;\r\n  } else {\r\n    t9 = -1.0 - exp(X_idx_12) * X_idx_28 * 3.4567260021088461E-12;\r\n  }\r\n\r\n  if (M_idx_8 != 0) {\r\n    X_idx_12 = 0.001;\r\n  } else {\r\n    X_idx_12 = 1.0000000000000001E-11;\r\n  }\r\n\r\n  if (intrm_sf_mf_14 > 80.0) {\r\n    X_idx_28 = -1.0 - X_idx_11 * 3.4567260021088461E-12 * 5.54062238439351E+34;\r\n  } else if (M_idx_5 != 0) {\r\n    X_idx_28 = -1.0 - X_idx_11 * 3.4567260021088461E-12 * 4.9060947306492808E-35;\r\n  } else {\r\n    X_idx_28 = -1.0 - exp(intrm_sf_mf_14) * X_idx_11 * 3.4567260021088461E-12;\r\n  }\r\n\r\n  if (M_idx_10 != 0) {\r\n    t12 = 0.001;\r\n  } else {\r\n    t12 = 1.0000000000000001E-11;\r\n  }\r\n\r\n  intrm_sf_mf_14 = 1.0E-6;\r\n  X_idx_11 = 1.0E-12;\r\n  out.mX[0] = -0.5;\r\n  out.mX[1] = 1.0;\r\n  out.mX[2] = X_idx_22;\r\n  out.mX[3] = X_idx_25;\r\n  out.mX[4] = intrm_sf_mf_14;\r\n  out.mX[5] = t2;\r\n  out.mX[6] = t3;\r\n  out.mX[7] = intrm_sf_mf_14;\r\n  out.mX[8] = t4;\r\n  out.mX[9] = X_idx_10;\r\n  out.mX[10] = intrm_sf_mf_14;\r\n  out.mX[11] = t6;\r\n  out.mX[12] = intrm_sf_mf_14;\r\n  out.mX[13] = 1.0;\r\n  out.mX[14] = (M_idx_1 != 0 ? -0.2 : -1.0E+6) / 1.0E+6;\r\n  out.mX[15] = -0.001;\r\n  out.mX[16] = t7;\r\n  out.mX[17] = t8;\r\n  out.mX[18] = X_idx_11;\r\n  out.mX[19] = 1.0;\r\n  out.mX[20] = 1.0;\r\n  out.mX[21] = -1.0;\r\n  out.mX[22] = (M_idx_7 != 0 ? -0.009 : -1.0E+6) / 1.0E+6;\r\n  out.mX[23] = t9;\r\n  out.mX[24] = X_idx_12;\r\n  out.mX[25] = X_idx_11;\r\n  out.mX[26] = 1.0;\r\n  out.mX[27] = 1.0;\r\n  out.mX[28] = -1.0;\r\n  out.mX[29] = (M_idx_9 != 0 ? -0.009 : -1.0E+6) / 1.0E+6;\r\n  out.mX[30] = X_idx_28;\r\n  out.mX[31] = t12;\r\n  out.mX[32] = X_idx_11;\r\n  out.mX[33] = 1.0;\r\n  out.mX[34] = 1.0;\r\n  out.mX[35] = -1.0;\r\n  out.mX[36] = (M_idx_2 != 0 ? -0.009 : -1.0E+6) / 1.0E+6;\r\n  (void)sys;\r\n  (void)t90;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_dxf.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_dxf.h - header for method DCDC_Buck_9d5357ce_1_ds_dxf */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_DXF_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_DXF_H  1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_dxf(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                               /* #ifndef DCDC_BUCK_9D5357CE_1_DS_DXF_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_dxf_p.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_dxf_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_dxf_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXF_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 1;\r\n  out.mJc[3] = 1;\r\n  out.mJc[4] = 1;\r\n  out.mJc[5] = 2;\r\n  out.mJc[6] = 2;\r\n  out.mJc[7] = 2;\r\n  out.mJc[8] = 2;\r\n  out.mJc[9] = 2;\r\n  out.mJc[10] = 2;\r\n  out.mJc[11] = 5;\r\n  out.mJc[12] = 8;\r\n  out.mJc[13] = 11;\r\n  out.mJc[14] = 13;\r\n  out.mJc[15] = 15;\r\n  out.mJc[16] = 16;\r\n  out.mJc[17] = 16;\r\n  out.mJc[18] = 16;\r\n  out.mJc[19] = 16;\r\n  out.mJc[20] = 16;\r\n  out.mJc[21] = 16;\r\n  out.mJc[22] = 16;\r\n  out.mJc[23] = 19;\r\n  out.mJc[24] = 21;\r\n  out.mJc[25] = 23;\r\n  out.mJc[26] = 26;\r\n  out.mJc[27] = 28;\r\n  out.mJc[28] = 30;\r\n  out.mJc[29] = 33;\r\n  out.mJc[30] = 35;\r\n  out.mJc[31] = 37;\r\n  out.mIr[0] = 13;\r\n  out.mIr[1] = 22;\r\n  out.mIr[2] = 22;\r\n  out.mIr[3] = 25;\r\n  out.mIr[4] = 26;\r\n  out.mIr[5] = 23;\r\n  out.mIr[6] = 27;\r\n  out.mIr[7] = 28;\r\n  out.mIr[8] = 24;\r\n  out.mIr[9] = 29;\r\n  out.mIr[10] = 30;\r\n  out.mIr[11] = 13;\r\n  out.mIr[12] = 14;\r\n  out.mIr[13] = 13;\r\n  out.mIr[14] = 14;\r\n  out.mIr[15] = 13;\r\n  out.mIr[16] = 22;\r\n  out.mIr[17] = 25;\r\n  out.mIr[18] = 26;\r\n  out.mIr[19] = 22;\r\n  out.mIr[20] = 25;\r\n  out.mIr[21] = 22;\r\n  out.mIr[22] = 26;\r\n  out.mIr[23] = 23;\r\n  out.mIr[24] = 27;\r\n  out.mIr[25] = 28;\r\n  out.mIr[26] = 23;\r\n  out.mIr[27] = 27;\r\n  out.mIr[28] = 23;\r\n  out.mIr[29] = 28;\r\n  out.mIr[30] = 24;\r\n  out.mIr[31] = 29;\r\n  out.mIr[32] = 30;\r\n  out.mIr[33] = 24;\r\n  out.mIr[34] = 29;\r\n  out.mIr[35] = 24;\r\n  out.mIr[36] = 30;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_dxf_p.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_dxf_p.h - header for method DCDC_Buck_9d5357ce_1_ds_dxf_p */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_DXF_P_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_DXF_P_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_dxf_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                             /* #ifndef DCDC_BUCK_9D5357CE_1_DS_DXF_P_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_dxy_p.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_dxy_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_dxy_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXY_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 1;\r\n  out.mJc[3] = 1;\r\n  out.mJc[4] = 1;\r\n  out.mJc[5] = 1;\r\n  out.mJc[6] = 1;\r\n  out.mJc[7] = 1;\r\n  out.mJc[8] = 1;\r\n  out.mJc[9] = 1;\r\n  out.mJc[10] = 2;\r\n  out.mJc[11] = 2;\r\n  out.mJc[12] = 2;\r\n  out.mJc[13] = 2;\r\n  out.mJc[14] = 2;\r\n  out.mJc[15] = 2;\r\n  out.mJc[16] = 3;\r\n  out.mJc[17] = 3;\r\n  out.mJc[18] = 3;\r\n  out.mJc[19] = 3;\r\n  out.mJc[20] = 3;\r\n  out.mJc[21] = 3;\r\n  out.mJc[22] = 4;\r\n  out.mJc[23] = 4;\r\n  out.mJc[24] = 4;\r\n  out.mJc[25] = 4;\r\n  out.mJc[26] = 4;\r\n  out.mJc[27] = 4;\r\n  out.mJc[28] = 4;\r\n  out.mJc[29] = 4;\r\n  out.mJc[30] = 4;\r\n  out.mJc[31] = 4;\r\n  out.mIr[0] = 1;\r\n  out.mIr[1] = 0;\r\n  out.mIr[2] = 1;\r\n  out.mIr[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_dxy_p.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_dxy_p.h - header for method DCDC_Buck_9d5357ce_1_ds_dxy_p */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_DXY_P_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_DXY_P_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_dxy_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                             /* #ifndef DCDC_BUCK_9D5357CE_1_DS_DXY_P_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_external_struct.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#ifndef struct__ExternalFunctionStructTag\r\n#define struct__ExternalFunctionStructTag\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_externals.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_f.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_f.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_f(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t23, NeDsMethodOutput *t24)\r\n{\r\n  PmRealVector out;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_mosfet_equation_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_diode_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_mosfet_equation_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_diode_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_mosfet_equation_v;\r\n  real_T X_idx_0;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_22;\r\n  real_T X_idx_23;\r\n  real_T X_idx_24;\r\n  real_T X_idx_25;\r\n  real_T X_idx_26;\r\n  real_T X_idx_27;\r\n  real_T X_idx_28;\r\n  real_T X_idx_29;\r\n  real_T X_idx_30;\r\n  real_T X_idx_4;\r\n  real_T t1;\r\n  real_T t10;\r\n  real_T t4;\r\n  real_T t7;\r\n  real_T t9;\r\n  int32_T M_idx_0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_10;\r\n  int32_T M_idx_2;\r\n  int32_T M_idx_3;\r\n  int32_T M_idx_4;\r\n  int32_T M_idx_5;\r\n  int32_T M_idx_6;\r\n  int32_T M_idx_7;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_0 = t23->mM.mX[0];\r\n  M_idx_1 = t23->mM.mX[1];\r\n  M_idx_2 = t23->mM.mX[2];\r\n  M_idx_3 = t23->mM.mX[3];\r\n  M_idx_4 = t23->mM.mX[4];\r\n  M_idx_5 = t23->mM.mX[5];\r\n  M_idx_6 = t23->mM.mX[6];\r\n  M_idx_7 = t23->mM.mX[7];\r\n  M_idx_8 = t23->mM.mX[8];\r\n  M_idx_9 = t23->mM.mX[9];\r\n  M_idx_10 = t23->mM.mX[10];\r\n  X_idx_0 = t23->mX.mX[0];\r\n  X_idx_4 = t23->mX.mX[4];\r\n  X_idx_10 = t23->mX.mX[10];\r\n  X_idx_11 = t23->mX.mX[11];\r\n  X_idx_12 = t23->mX.mX[12];\r\n  X_idx_13 = t23->mX.mX[13];\r\n  X_idx_14 = t23->mX.mX[14];\r\n  X_idx_15 = t23->mX.mX[15];\r\n  X_idx_22 = t23->mX.mX[22];\r\n  X_idx_23 = t23->mX.mX[23];\r\n  X_idx_24 = t23->mX.mX[24];\r\n  X_idx_25 = t23->mX.mX[25];\r\n  X_idx_26 = t23->mX.mX[26];\r\n  X_idx_27 = t23->mX.mX[27];\r\n  X_idx_28 = t23->mX.mX[28];\r\n  X_idx_29 = t23->mX.mX[29];\r\n  X_idx_30 = t23->mX.mX[30];\r\n  out = t24->mF;\r\n  t1 = ((X_idx_0 * -0.5 + X_idx_13 * 0.5) + X_idx_15 * -0.001) + X_idx_14;\r\n  t4 = ((-X_idx_22 + -X_idx_24) + X_idx_4) + X_idx_23;\r\n  t7 = (-X_idx_25 + -X_idx_27) + X_idx_26;\r\n  t9 = (-X_idx_28 + -X_idx_30) + X_idx_29;\r\n  X_idx_0 = (-X_idx_10 + X_idx_22 * -1.0E-6) + -9.0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_mosfet_equation_v = (X_idx_22 * 1.0E-6 +\r\n    X_idx_10) + 9.0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_diode_v = (-X_idx_11 + X_idx_25 * -1.0E-6)\r\n    + -9.0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_mosfet_equation_v = (X_idx_25 * 1.0E-6 +\r\n    X_idx_11) + 9.0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_diode_v = (-X_idx_12 + X_idx_28 * -1.0E-6)\r\n    + -9.0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_mosfet_equation_v = (X_idx_28 * 1.0E-6 +\r\n    X_idx_12) + 9.0;\r\n  t10 = (X_idx_28 * 1.0E-6 + X_idx_12) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  X_idx_10 = (X_idx_22 * 1.0E-6 + X_idx_10) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  X_idx_12 = (X_idx_25 * 1.0E-6 + X_idx_11) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  if (M_idx_0 != 0) {\r\n    X_idx_28 = t1 - (-X_idx_13 - 1.599999984) / 0.001;\r\n  } else {\r\n    X_idx_28 = t1 - -X_idx_13 * 1.0E-5;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t1 = X_idx_13 - X_idx_14 * 0.2;\r\n  } else {\r\n    t1 = X_idx_13 - X_idx_14 / 1.0E-6;\r\n  }\r\n\r\n  if (X_idx_10 > 80.0) {\r\n    X_idx_15 = t4 - ((X_idx_10 - 79.0) * 5.54062238439351E+34 - 1.0) *\r\n      3.4567260021088461E-12;\r\n  } else if (M_idx_3 != 0) {\r\n    X_idx_15 = t4 - ((X_idx_10 + 80.0) * 4.9060947306492808E-35 - 1.0) *\r\n      3.4567260021088461E-12;\r\n  } else {\r\n    X_idx_15 = t4 - (exp(X_idx_10) - 1.0) * 3.4567260021088461E-12;\r\n  }\r\n\r\n  if (X_idx_12 > 80.0) {\r\n    X_idx_4 = t7 - ((X_idx_12 - 79.0) * 5.54062238439351E+34 - 1.0) *\r\n      3.4567260021088461E-12;\r\n  } else if (M_idx_4 != 0) {\r\n    X_idx_4 = t7 - ((X_idx_12 + 80.0) * 4.9060947306492808E-35 - 1.0) *\r\n      3.4567260021088461E-12;\r\n  } else {\r\n    X_idx_4 = t7 - (exp(X_idx_12) - 1.0) * 3.4567260021088461E-12;\r\n  }\r\n\r\n  if (t10 > 80.0) {\r\n    t4 = t9 - ((t10 - 79.0) * 5.54062238439351E+34 - 1.0) *\r\n      3.4567260021088461E-12;\r\n  } else if (M_idx_5 != 0) {\r\n    t4 = t9 - ((t10 + 80.0) * 4.9060947306492808E-35 - 1.0) *\r\n      3.4567260021088461E-12;\r\n  } else {\r\n    t4 = t9 - (exp(t10) - 1.0) * 3.4567260021088461E-12;\r\n  }\r\n\r\n  if (M_idx_6 != 0) {\r\n    X_idx_0 = X_idx_23 - (X_idx_0 - 0.84999999149999994) / 0.001;\r\n  } else {\r\n    X_idx_0 = X_idx_23 - X_idx_0 * 1.0E-5;\r\n  }\r\n\r\n  if (M_idx_7 != 0) {\r\n    X_idx_10 = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_mosfet_equation_v - X_idx_24 *\r\n      0.009;\r\n  } else {\r\n    X_idx_10 = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_mosfet_equation_v - X_idx_24 /\r\n      1.0E-6;\r\n  }\r\n\r\n  if (M_idx_8 != 0) {\r\n    t7 = X_idx_26 - (DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_diode_v -\r\n                     0.84999999149999994) / 0.001;\r\n  } else {\r\n    t7 = X_idx_26 - DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_diode_v * 1.0E-5;\r\n  }\r\n\r\n  if (M_idx_9 != 0) {\r\n    X_idx_12 = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_mosfet_equation_v - X_idx_27 *\r\n      0.009;\r\n  } else {\r\n    X_idx_12 = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET2_mosfet_equation_v - X_idx_27 /\r\n      1.0E-6;\r\n  }\r\n\r\n  if (M_idx_10 != 0) {\r\n    t9 = X_idx_29 - (DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_diode_v -\r\n                     0.84999999149999994) / 0.001;\r\n  } else {\r\n    t9 = X_idx_29 - DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_diode_v * 1.0E-5;\r\n  }\r\n\r\n  if (M_idx_2 != 0) {\r\n    t10 = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_mosfet_equation_v - X_idx_30 *\r\n      0.009;\r\n  } else {\r\n    t10 = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET3_mosfet_equation_v - X_idx_30 /\r\n      1.0E-6;\r\n  }\r\n\r\n  out.mX[0] = -0.0;\r\n  out.mX[1] = -0.0;\r\n  out.mX[2] = -0.0;\r\n  out.mX[3] = -0.0;\r\n  out.mX[4] = -0.0;\r\n  out.mX[5] = -0.0;\r\n  out.mX[6] = -0.0;\r\n  out.mX[7] = -0.0;\r\n  out.mX[8] = -0.0;\r\n  out.mX[9] = -0.0;\r\n  out.mX[10] = -0.0;\r\n  out.mX[11] = -0.0;\r\n  out.mX[12] = -0.0;\r\n  out.mX[13] = X_idx_28;\r\n  out.mX[14] = t1 / 1.0E+6;\r\n  out.mX[15] = 9.0;\r\n  out.mX[16] = 0.0;\r\n  out.mX[17] = 0.0;\r\n  out.mX[18] = 0.0;\r\n  out.mX[19] = 0.0;\r\n  out.mX[20] = 0.0;\r\n  out.mX[21] = 0.0;\r\n  out.mX[22] = X_idx_15;\r\n  out.mX[23] = X_idx_4;\r\n  out.mX[24] = t4;\r\n  out.mX[25] = X_idx_0;\r\n  out.mX[26] = X_idx_10 / 1.0E+6;\r\n  out.mX[27] = t7;\r\n  out.mX[28] = X_idx_12 / 1.0E+6;\r\n  out.mX[29] = t9;\r\n  out.mX[30] = t10 / 1.0E+6;\r\n  (void)sys;\r\n  (void)t24;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_f.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_f.h - header for method DCDC_Buck_9d5357ce_1_ds_f */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_F_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_F_H    1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_f(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                                 /* #ifndef DCDC_BUCK_9D5357CE_1_DS_F_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_imax.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_imax.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_imax(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMAX;\r\n  out.mX[0] = pmf_get_inf();\r\n  out.mX[1] = pmf_get_inf();\r\n  out.mX[2] = pmf_get_inf();\r\n  out.mX[3] = pmf_get_inf();\r\n  out.mX[4] = pmf_get_inf();\r\n  out.mX[5] = pmf_get_inf();\r\n  out.mX[6] = pmf_get_inf();\r\n  out.mX[7] = pmf_get_inf();\r\n  out.mX[8] = pmf_get_inf();\r\n  out.mX[9] = pmf_get_inf();\r\n  out.mX[10] = pmf_get_inf();\r\n  out.mX[11] = pmf_get_inf();\r\n  out.mX[12] = pmf_get_inf();\r\n  out.mX[13] = pmf_get_inf();\r\n  out.mX[14] = pmf_get_inf();\r\n  out.mX[15] = pmf_get_inf();\r\n  out.mX[16] = pmf_get_inf();\r\n  out.mX[17] = pmf_get_inf();\r\n  out.mX[18] = pmf_get_inf();\r\n  out.mX[19] = pmf_get_inf();\r\n  out.mX[20] = pmf_get_inf();\r\n  out.mX[21] = pmf_get_inf();\r\n  out.mX[22] = pmf_get_inf();\r\n  out.mX[23] = pmf_get_inf();\r\n  out.mX[24] = pmf_get_inf();\r\n  out.mX[25] = pmf_get_inf();\r\n  out.mX[26] = pmf_get_inf();\r\n  out.mX[27] = pmf_get_inf();\r\n  out.mX[28] = pmf_get_inf();\r\n  out.mX[29] = pmf_get_inf();\r\n  out.mX[30] = pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_imax.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_imax.h - header for method DCDC_Buck_9d5357ce_1_ds_imax */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_IMAX_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_IMAX_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_imax(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                              /* #ifndef DCDC_BUCK_9D5357CE_1_DS_IMAX_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_imin.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_imin.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_imin(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMIN;\r\n  out.mX[0] = -pmf_get_inf();\r\n  out.mX[1] = -pmf_get_inf();\r\n  out.mX[2] = -pmf_get_inf();\r\n  out.mX[3] = -pmf_get_inf();\r\n  out.mX[4] = -pmf_get_inf();\r\n  out.mX[5] = -pmf_get_inf();\r\n  out.mX[6] = -pmf_get_inf();\r\n  out.mX[7] = -pmf_get_inf();\r\n  out.mX[8] = -pmf_get_inf();\r\n  out.mX[9] = -pmf_get_inf();\r\n  out.mX[10] = -pmf_get_inf();\r\n  out.mX[11] = -pmf_get_inf();\r\n  out.mX[12] = -pmf_get_inf();\r\n  out.mX[13] = -pmf_get_inf();\r\n  out.mX[14] = -pmf_get_inf();\r\n  out.mX[15] = -pmf_get_inf();\r\n  out.mX[16] = -pmf_get_inf();\r\n  out.mX[17] = -pmf_get_inf();\r\n  out.mX[18] = -pmf_get_inf();\r\n  out.mX[19] = -pmf_get_inf();\r\n  out.mX[20] = -pmf_get_inf();\r\n  out.mX[21] = -pmf_get_inf();\r\n  out.mX[22] = -pmf_get_inf();\r\n  out.mX[23] = -pmf_get_inf();\r\n  out.mX[24] = -pmf_get_inf();\r\n  out.mX[25] = -pmf_get_inf();\r\n  out.mX[26] = -pmf_get_inf();\r\n  out.mX[27] = -pmf_get_inf();\r\n  out.mX[28] = -pmf_get_inf();\r\n  out.mX[29] = -pmf_get_inf();\r\n  out.mX[30] = -pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_imin.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_imin.h - header for method DCDC_Buck_9d5357ce_1_ds_imin */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_IMIN_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_IMIN_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_imin(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                              /* #ifndef DCDC_BUCK_9D5357CE_1_DS_IMIN_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_log.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_log.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_log(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t18, NeDsMethodOutput *t19)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[208];\r\n  real_T DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C11_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C13_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  real_T DC_DC_Buck_PLANT_PR2_i;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_16;\r\n  real_T X_idx_17;\r\n  real_T X_idx_18;\r\n  real_T X_idx_19;\r\n  real_T X_idx_2;\r\n  real_T X_idx_20;\r\n  real_T X_idx_21;\r\n  real_T X_idx_22;\r\n  real_T X_idx_23;\r\n  real_T X_idx_24;\r\n  real_T X_idx_25;\r\n  real_T X_idx_26;\r\n  real_T X_idx_27;\r\n  real_T X_idx_28;\r\n  real_T X_idx_29;\r\n  real_T X_idx_3;\r\n  real_T X_idx_30;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t10;\r\n  real_T t12;\r\n  real_T t13;\r\n  real_T t15;\r\n  real_T t17;\r\n  real_T t4;\r\n  real_T t5;\r\n  real_T t6;\r\n  real_T t9;\r\n  int32_T b;\r\n  U_idx_0 = t18->mU.mX[0];\r\n  U_idx_1 = t18->mU.mX[1];\r\n  U_idx_2 = t18->mU.mX[2];\r\n  U_idx_3 = t18->mU.mX[3];\r\n  X_idx_0 = t18->mX.mX[0];\r\n  X_idx_1 = t18->mX.mX[1];\r\n  X_idx_2 = t18->mX.mX[2];\r\n  X_idx_3 = t18->mX.mX[3];\r\n  X_idx_4 = t18->mX.mX[4];\r\n  X_idx_5 = t18->mX.mX[5];\r\n  X_idx_6 = t18->mX.mX[6];\r\n  X_idx_7 = t18->mX.mX[7];\r\n  X_idx_8 = t18->mX.mX[8];\r\n  X_idx_9 = t18->mX.mX[9];\r\n  X_idx_10 = t18->mX.mX[10];\r\n  X_idx_11 = t18->mX.mX[11];\r\n  X_idx_12 = t18->mX.mX[12];\r\n  X_idx_13 = t18->mX.mX[13];\r\n  X_idx_14 = t18->mX.mX[14];\r\n  X_idx_15 = t18->mX.mX[15];\r\n  X_idx_16 = t18->mX.mX[16];\r\n  X_idx_17 = t18->mX.mX[17];\r\n  X_idx_18 = t18->mX.mX[18];\r\n  X_idx_19 = t18->mX.mX[19];\r\n  X_idx_20 = t18->mX.mX[20];\r\n  X_idx_21 = t18->mX.mX[21];\r\n  X_idx_22 = t18->mX.mX[22];\r\n  X_idx_23 = t18->mX.mX[23];\r\n  X_idx_24 = t18->mX.mX[24];\r\n  X_idx_25 = t18->mX.mX[25];\r\n  X_idx_26 = t18->mX.mX[26];\r\n  X_idx_27 = t18->mX.mX[27];\r\n  X_idx_28 = t18->mX.mX[28];\r\n  X_idx_29 = t18->mX.mX[29];\r\n  X_idx_30 = t18->mX.mX[30];\r\n  out = t19->mLOG;\r\n  DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i = ((X_idx_0 * -0.5 + X_idx_13 *\r\n    0.5) + X_idx_15 * -0.001) + X_idx_14;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_i = (((((X_idx_0 * -0.6333333333333333 +\r\n    X_idx_2 * -0.00083333333333333339) + X_idx_13 * 0.5) + X_idx_15 *\r\n    -1.0012666666666667) + -X_idx_17) + X_idx_18 * -1.0000000008333334) +\r\n    X_idx_19;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v = X_idx_15 * 0.002 + X_idx_0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_i = (((X_idx_0 *\r\n    -0.012195121951219513 + X_idx_15 * -2.4390243902439026E-5) + X_idx_20 *\r\n    0.012195121951219513) + X_idx_19 * -1.0003658536585365) + X_idx_4;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v = (X_idx_15 * 0.002 +\r\n    X_idx_19 * 0.03) + X_idx_0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C11_i = ((((X_idx_0 *\r\n    -0.012195121951219513 + X_idx_2 * 0.00083333333333333339) + X_idx_15 *\r\n    -2.4390243902439026E-5) + X_idx_20 * 0.012195121951219513) + X_idx_18 *\r\n    1.0000000008333334) + X_idx_17;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C13_i = ((X_idx_20 *\r\n    -0.0008333333333333335 + X_idx_19 * -0.99999999999999989) + X_idx_17) +\r\n    X_idx_4;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v = (-X_idx_2 + X_idx_18 *\r\n    -1.0E-6) + X_idx_20;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v = X_idx_21 * 1.0E-6 +\r\n    X_idx_9;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i = X_idx_20 *\r\n    0.00083333333333333339;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i = X_idx_2 *\r\n    0.00083333333333333339 + X_idx_18 * 8.3333333333333335E-10;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i = ((X_idx_0 *\r\n    0.012195121951219513 + X_idx_15 * 2.4390243902439026E-5) + X_idx_20 *\r\n    -0.012195121951219513) + X_idx_19 * 0.00036585365853658537;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i = (X_idx_0 *\r\n    0.012195121951219513 + X_idx_15 * 2.4390243902439026E-5) + X_idx_20 *\r\n    -0.012195121951219513;\r\n  t4 = ((-X_idx_22 + -X_idx_24) + X_idx_4) + X_idx_23;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v = -X_idx_10 + X_idx_22 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v = X_idx_22 * 1.0E-6 + X_idx_10;\r\n  t5 = (-X_idx_25 + -X_idx_27) + X_idx_26;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v = -X_idx_11 + X_idx_25 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v = X_idx_25 * 1.0E-6 + X_idx_11;\r\n  t6 = (-X_idx_28 + -X_idx_30) + X_idx_29;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v = -X_idx_12 + X_idx_28 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v = X_idx_28 * 1.0E-6 + X_idx_12;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v = (-X_idx_10 + X_idx_22 * -1.0E-6)\r\n    + -9.0;\r\n  t9 = (X_idx_22 * 1.0E-6 + X_idx_10) + 9.0;\r\n  t10 = (-X_idx_11 + X_idx_25 * -1.0E-6) + -9.0;\r\n  t12 = (X_idx_25 * 1.0E-6 + X_idx_11) + 9.0;\r\n  t13 = (-X_idx_12 + X_idx_28 * -1.0E-6) + -9.0;\r\n  t15 = (X_idx_28 * 1.0E-6 + X_idx_12) + 9.0;\r\n  t17 = X_idx_0 * 0.13333333333333333 + X_idx_15 * 0.00026666666666666668;\r\n  DC_DC_Buck_PLANT_PR2_i = (X_idx_0 * 0.5 + X_idx_13 * -0.5) + X_idx_15 * 0.001;\r\n  t0[0ULL] = X_idx_13;\r\n  t0[1ULL] = U_idx_0;\r\n  t0[2ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  t0[3ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  t0[4ULL] = -X_idx_13;\r\n  t0[5ULL] = X_idx_13;\r\n  t0[6ULL] = X_idx_13;\r\n  t0[7ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i * -X_idx_13 * 0.001 *\r\n    1000.0;\r\n  t0[8ULL] = -X_idx_13;\r\n  t0[9ULL] = U_idx_0;\r\n  t0[10ULL] = X_idx_14;\r\n  t0[11ULL] = -(-U_idx_0 + 3.0);\r\n  t0[12ULL] = X_idx_13;\r\n  t0[13ULL] = X_idx_13;\r\n  t0[14ULL] = X_idx_14 * X_idx_13 * 0.001 * 1000.0;\r\n  t0[15ULL] = U_idx_0;\r\n  t0[16ULL] = X_idx_13;\r\n  t0[17ULL] = X_idx_16;\r\n  t0[18ULL] = X_idx_1;\r\n  t0[19ULL] = X_idx_16 * X_idx_16 * 1.0E-9;\r\n  t0[20ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_i;\r\n  t0[21ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[22ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[23ULL] = X_idx_3;\r\n  t0[24ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_i * 2.0E-6;\r\n  t0[25ULL] = X_idx_15;\r\n  t0[26ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[27ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[28ULL] = X_idx_0;\r\n  t0[29ULL] = X_idx_15 * X_idx_15 * 2.0E-6;\r\n  t0[30ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[31ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_i;\r\n  t0[32ULL] = X_idx_20;\r\n  t0[33ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[34ULL] = ((X_idx_15 * 0.002 + -X_idx_20) + X_idx_19 * 0.03) + X_idx_0;\r\n  t0[35ULL] = X_idx_5;\r\n  t0[36ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_i * 1.0E-9;\r\n  t0[37ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C11_i;\r\n  t0[38ULL] = X_idx_20;\r\n  t0[39ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[40ULL] = (X_idx_15 * 0.002 + -X_idx_20) + X_idx_0;\r\n  t0[41ULL] = X_idx_6;\r\n  t0[42ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C11_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C11_i * 1.0E-9;\r\n  t0[43ULL] = X_idx_17;\r\n  t0[44ULL] = X_idx_20;\r\n  t0[45ULL] = X_idx_20;\r\n  t0[46ULL] = X_idx_7;\r\n  t0[47ULL] = X_idx_17 * X_idx_17 * 1.0E-9;\r\n  t0[48ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C13_i;\r\n  t0[49ULL] = X_idx_20;\r\n  t0[50ULL] = X_idx_20;\r\n  t0[51ULL] = X_idx_8;\r\n  t0[52ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C13_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C13_i * 1.0E-9;\r\n  t0[53ULL] = X_idx_18;\r\n  t0[54ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[55ULL] = X_idx_20;\r\n  t0[56ULL] = X_idx_18 * 1.0E-6 + X_idx_2;\r\n  t0[57ULL] = X_idx_2;\r\n  t0[58ULL] = X_idx_18 * X_idx_18 * 1.0E-9;\r\n  t0[59ULL] = X_idx_21;\r\n  t0[60ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[61ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[62ULL] = X_idx_9;\r\n  t0[63ULL] = X_idx_21 * X_idx_21 * 1.0E-9;\r\n  t0[64ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[65ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[66ULL] = X_idx_20;\r\n  t0[67ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[68ULL] = (X_idx_2 * 0.00083333333333333339 + X_idx_18 * 1.0000000008333334)\r\n    + -X_idx_21;\r\n  t0[69ULL] = X_idx_20;\r\n  t0[70ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i;\r\n  t0[71ULL] = X_idx_20;\r\n  t0[72ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i * 1200.0;\r\n  t0[73ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i * 1200.0;\r\n  t0[74ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i;\r\n  t0[75ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[76ULL] = X_idx_20;\r\n  t0[77ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i * 1200.0;\r\n  t0[78ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i * 1200.0;\r\n  t0[79ULL] = X_idx_21;\r\n  t0[80ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[81ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[82ULL] = X_idx_21 * 1000.0;\r\n  t0[83ULL] = X_idx_21 * X_idx_21 * 1000.0;\r\n  t0[84ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i;\r\n  t0[85ULL] = X_idx_20;\r\n  t0[86ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[87ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i * 82.0;\r\n  t0[88ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i * 82.0;\r\n  t0[89ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i;\r\n  t0[90ULL] = X_idx_20;\r\n  t0[91ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[92ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i * 82.0;\r\n  t0[93ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i *\r\n    DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i * 82.0;\r\n  t0[94ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[95ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[96ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[97ULL] = X_idx_22;\r\n  t0[98ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[99ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[100ULL] = X_idx_10;\r\n  t0[101ULL] = t4;\r\n  t0[102ULL] = X_idx_22;\r\n  t0[103ULL] = t4;\r\n  t0[104ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[105ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[106ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[107ULL] = (-X_idx_24 + X_idx_4) + X_idx_23;\r\n  t0[108ULL] = t4 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v * 0.001 * 1000.0;\r\n  t0[109ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[110ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[111ULL] = X_idx_25;\r\n  t0[112ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[113ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[114ULL] = X_idx_11;\r\n  t0[115ULL] = t5;\r\n  t0[116ULL] = X_idx_25;\r\n  t0[117ULL] = t5;\r\n  t0[118ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[119ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[120ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[121ULL] = -X_idx_27 + X_idx_26;\r\n  t0[122ULL] = t5 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v * 0.001 * 1000.0;\r\n  t0[123ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[124ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[125ULL] = X_idx_28;\r\n  t0[126ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[127ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[128ULL] = X_idx_12;\r\n  t0[129ULL] = t6;\r\n  t0[130ULL] = X_idx_28;\r\n  t0[131ULL] = t6;\r\n  t0[132ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[133ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[134ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[135ULL] = -X_idx_30 + X_idx_29;\r\n  t0[136ULL] = t6 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v * 0.001 * 1000.0;\r\n  t0[137ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[138ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[139ULL] = X_idx_4;\r\n  t0[140ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[141ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[142ULL] = (((-X_idx_0 + -X_idx_10) + X_idx_15 * -0.002) + X_idx_22 *\r\n                -1.0E-6) + X_idx_19 * -0.03;\r\n  t0[143ULL] = X_idx_4;\r\n  t0[144ULL] = X_idx_4 * X_idx_4 * 1.0500000000000001E-5;\r\n  t0[145ULL] = U_idx_1;\r\n  t0[146ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[147ULL] = X_idx_23;\r\n  t0[148ULL] = X_idx_23;\r\n  t0[149ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  t0[150ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[151ULL] = X_idx_23 * DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v * 0.001 *\r\n    1000.0;\r\n  t0[152ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  t0[153ULL] = U_idx_1;\r\n  t0[154ULL] = X_idx_24;\r\n  t0[155ULL] = -(-U_idx_1 + 1.5);\r\n  t0[156ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[157ULL] = t9;\r\n  t0[158ULL] = X_idx_24 * t9 * 0.001 * 1000.0;\r\n  t0[159ULL] = U_idx_2;\r\n  t0[160ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[161ULL] = X_idx_26;\r\n  t0[162ULL] = X_idx_26;\r\n  t0[163ULL] = t10;\r\n  t0[164ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[165ULL] = X_idx_26 * t10 * 0.001 * 1000.0;\r\n  t0[166ULL] = t10;\r\n  t0[167ULL] = U_idx_2;\r\n  t0[168ULL] = X_idx_27;\r\n  t0[169ULL] = -(-U_idx_2 + 1.5);\r\n  t0[170ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[171ULL] = t12;\r\n  t0[172ULL] = X_idx_27 * t12 * 0.001 * 1000.0;\r\n  t0[173ULL] = U_idx_3;\r\n  t0[174ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[175ULL] = X_idx_29;\r\n  t0[176ULL] = X_idx_29;\r\n  t0[177ULL] = t13;\r\n  t0[178ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[179ULL] = X_idx_29 * t13 * 0.001 * 1000.0;\r\n  t0[180ULL] = t13;\r\n  t0[181ULL] = U_idx_3;\r\n  t0[182ULL] = X_idx_30;\r\n  t0[183ULL] = -(-U_idx_3 + 1.5);\r\n  t0[184ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[185ULL] = t15;\r\n  t0[186ULL] = X_idx_30 * t15 * 0.001 * 1000.0;\r\n  t0[187ULL] = X_idx_19;\r\n  t0[188ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[189ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[190ULL] = X_idx_19 * 0.03;\r\n  t0[191ULL] = X_idx_19 * X_idx_19 * 0.03;\r\n  t0[192ULL] = U_idx_1;\r\n  t0[193ULL] = U_idx_3;\r\n  t0[194ULL] = U_idx_2;\r\n  t0[195ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[196ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[197ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[198ULL] = t17;\r\n  t0[199ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[200ULL] = t17 * 7.5;\r\n  t0[201ULL] = t17 * t17 * 7.5;\r\n  t0[202ULL] = DC_DC_Buck_PLANT_PR2_i;\r\n  t0[203ULL] = X_idx_13;\r\n  t0[204ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[205ULL] = DC_DC_Buck_PLANT_PR2_i * 2.0;\r\n  t0[206ULL] = DC_DC_Buck_PLANT_PR2_i * DC_DC_Buck_PLANT_PR2_i * 2.0;\r\n  t0[207ULL] = (((((-X_idx_16 + -X_idx_24) + -X_idx_27) + -X_idx_30) + X_idx_23)\r\n                + X_idx_26) + X_idx_29;\r\n  for (b = 0; b < 208; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t19;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_log.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_log.h - header for method DCDC_Buck_9d5357ce_1_ds_log */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_LOG_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_LOG_H  1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_log(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                               /* #ifndef DCDC_BUCK_9D5357CE_1_DS_LOG_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_m_p.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_m_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_m_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mM_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 3;\r\n  out.mJc[4] = 4;\r\n  out.mJc[5] = 5;\r\n  out.mJc[6] = 6;\r\n  out.mJc[7] = 7;\r\n  out.mJc[8] = 8;\r\n  out.mJc[9] = 9;\r\n  out.mJc[10] = 10;\r\n  out.mJc[11] = 11;\r\n  out.mJc[12] = 12;\r\n  out.mJc[13] = 13;\r\n  out.mJc[14] = 13;\r\n  out.mJc[15] = 13;\r\n  out.mJc[16] = 13;\r\n  out.mJc[17] = 13;\r\n  out.mJc[18] = 13;\r\n  out.mJc[19] = 13;\r\n  out.mJc[20] = 13;\r\n  out.mJc[21] = 13;\r\n  out.mJc[22] = 13;\r\n  out.mJc[23] = 13;\r\n  out.mJc[24] = 13;\r\n  out.mJc[25] = 13;\r\n  out.mJc[26] = 13;\r\n  out.mJc[27] = 13;\r\n  out.mJc[28] = 13;\r\n  out.mJc[29] = 13;\r\n  out.mJc[30] = 13;\r\n  out.mJc[31] = 13;\r\n  out.mIr[0] = 2;\r\n  out.mIr[1] = 0;\r\n  out.mIr[2] = 7;\r\n  out.mIr[3] = 1;\r\n  out.mIr[4] = 12;\r\n  out.mIr[5] = 3;\r\n  out.mIr[6] = 4;\r\n  out.mIr[7] = 5;\r\n  out.mIr[8] = 6;\r\n  out.mIr[9] = 8;\r\n  out.mIr[10] = 9;\r\n  out.mIr[11] = 10;\r\n  out.mIr[12] = 11;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_m_p.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_m_p.h - header for method DCDC_Buck_9d5357ce_1_ds_m_p */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_M_P_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_M_P_H  1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_m_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                               /* #ifndef DCDC_BUCK_9D5357CE_1_DS_M_P_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_mode.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_mode.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_mode(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t3, NeDsMethodOutput *t4)\r\n{\r\n  PmIntVector out;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_22;\r\n  real_T X_idx_25;\r\n  real_T X_idx_28;\r\n  U_idx_0 = t3->mU.mX[0];\r\n  U_idx_1 = t3->mU.mX[1];\r\n  U_idx_2 = t3->mU.mX[2];\r\n  U_idx_3 = t3->mU.mX[3];\r\n  X_idx_10 = t3->mX.mX[10];\r\n  X_idx_11 = t3->mX.mX[11];\r\n  X_idx_12 = t3->mX.mX[12];\r\n  X_idx_13 = t3->mX.mX[13];\r\n  X_idx_22 = t3->mX.mX[22];\r\n  X_idx_25 = t3->mX.mX[25];\r\n  X_idx_28 = t3->mX.mX[28];\r\n  out = t4->mMODE;\r\n  out.mX[0] = (int32_T)(-X_idx_13 > 1.6);\r\n  out.mX[1] = (int32_T)(U_idx_0 > 3.0);\r\n  out.mX[2] = (int32_T)(U_idx_3 > 1.5);\r\n  out.mX[3] = (int32_T)((X_idx_22 * 1.0E-6 + X_idx_10) * 1.602176487E-19 /\r\n                        4.3497335432938027E-21 < -79.0);\r\n  out.mX[4] = (int32_T)((X_idx_25 * 1.0E-6 + X_idx_11) * 1.602176487E-19 /\r\n                        4.3497335432938027E-21 < -79.0);\r\n  out.mX[5] = (int32_T)((X_idx_28 * 1.0E-6 + X_idx_12) * 1.602176487E-19 /\r\n                        4.3497335432938027E-21 < -79.0);\r\n  out.mX[6] = (int32_T)((-X_idx_10 + X_idx_22 * -1.0E-6) + -9.0 > 0.85);\r\n  out.mX[7] = (int32_T)(U_idx_1 > 1.5);\r\n  out.mX[8] = (int32_T)((-X_idx_11 + X_idx_25 * -1.0E-6) + -9.0 > 0.85);\r\n  out.mX[9] = (int32_T)(U_idx_2 > 1.5);\r\n  out.mX[10] = (int32_T)((-X_idx_12 + X_idx_28 * -1.0E-6) + -9.0 > 0.85);\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_mode.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_mode.h - header for method DCDC_Buck_9d5357ce_1_ds_mode */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_MODE_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_MODE_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_mode(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                              /* #ifndef DCDC_BUCK_9D5357CE_1_DS_MODE_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_act.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_act.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_obs_act(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t18, NeDsMethodOutput *t19)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[260];\r\n  real_T DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  real_T DC_DC_Buck_PLANT_PR2_i;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_16;\r\n  real_T X_idx_17;\r\n  real_T X_idx_18;\r\n  real_T X_idx_19;\r\n  real_T X_idx_2;\r\n  real_T X_idx_20;\r\n  real_T X_idx_21;\r\n  real_T X_idx_22;\r\n  real_T X_idx_23;\r\n  real_T X_idx_24;\r\n  real_T X_idx_25;\r\n  real_T X_idx_26;\r\n  real_T X_idx_27;\r\n  real_T X_idx_28;\r\n  real_T X_idx_29;\r\n  real_T X_idx_3;\r\n  real_T X_idx_30;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t10;\r\n  real_T t12;\r\n  real_T t13;\r\n  real_T t15;\r\n  real_T t17;\r\n  real_T t4;\r\n  real_T t5;\r\n  real_T t6;\r\n  real_T t9;\r\n  int32_T b;\r\n  U_idx_0 = t18->mU.mX[0];\r\n  U_idx_1 = t18->mU.mX[1];\r\n  U_idx_2 = t18->mU.mX[2];\r\n  U_idx_3 = t18->mU.mX[3];\r\n  X_idx_0 = t18->mX.mX[0];\r\n  X_idx_1 = t18->mX.mX[1];\r\n  X_idx_2 = t18->mX.mX[2];\r\n  X_idx_3 = t18->mX.mX[3];\r\n  X_idx_4 = t18->mX.mX[4];\r\n  X_idx_5 = t18->mX.mX[5];\r\n  X_idx_6 = t18->mX.mX[6];\r\n  X_idx_7 = t18->mX.mX[7];\r\n  X_idx_8 = t18->mX.mX[8];\r\n  X_idx_9 = t18->mX.mX[9];\r\n  X_idx_10 = t18->mX.mX[10];\r\n  X_idx_11 = t18->mX.mX[11];\r\n  X_idx_12 = t18->mX.mX[12];\r\n  X_idx_13 = t18->mX.mX[13];\r\n  X_idx_14 = t18->mX.mX[14];\r\n  X_idx_15 = t18->mX.mX[15];\r\n  X_idx_16 = t18->mX.mX[16];\r\n  X_idx_17 = t18->mX.mX[17];\r\n  X_idx_18 = t18->mX.mX[18];\r\n  X_idx_19 = t18->mX.mX[19];\r\n  X_idx_20 = t18->mX.mX[20];\r\n  X_idx_21 = t18->mX.mX[21];\r\n  X_idx_22 = t18->mX.mX[22];\r\n  X_idx_23 = t18->mX.mX[23];\r\n  X_idx_24 = t18->mX.mX[24];\r\n  X_idx_25 = t18->mX.mX[25];\r\n  X_idx_26 = t18->mX.mX[26];\r\n  X_idx_27 = t18->mX.mX[27];\r\n  X_idx_28 = t18->mX.mX[28];\r\n  X_idx_29 = t18->mX.mX[29];\r\n  X_idx_30 = t18->mX.mX[30];\r\n  out = t19->mOBS_ACT;\r\n  DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i = ((X_idx_0 * -0.5 + X_idx_13 *\r\n    0.5) + X_idx_15 * -0.001) + X_idx_14;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v = X_idx_15 * 0.002 + X_idx_0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v = (X_idx_15 * 0.002 +\r\n    X_idx_19 * 0.03) + X_idx_0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v = (-X_idx_2 + X_idx_18 *\r\n    -1.0E-6) + X_idx_20;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v = X_idx_21 * 1.0E-6 +\r\n    X_idx_9;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i = X_idx_20 *\r\n    0.00083333333333333339;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i = X_idx_2 *\r\n    0.00083333333333333339 + X_idx_18 * 8.3333333333333335E-10;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i = ((X_idx_0 *\r\n    0.012195121951219513 + X_idx_15 * 2.4390243902439026E-5) + X_idx_20 *\r\n    -0.012195121951219513) + X_idx_19 * 0.00036585365853658537;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i = (X_idx_0 *\r\n    0.012195121951219513 + X_idx_15 * 2.4390243902439026E-5) + X_idx_20 *\r\n    -0.012195121951219513;\r\n  t4 = ((-X_idx_22 + -X_idx_24) + X_idx_4) + X_idx_23;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v = -X_idx_10 + X_idx_22 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v = X_idx_22 * 1.0E-6 + X_idx_10;\r\n  t5 = (-X_idx_25 + -X_idx_27) + X_idx_26;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v = -X_idx_11 + X_idx_25 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v = X_idx_25 * 1.0E-6 + X_idx_11;\r\n  t6 = (-X_idx_28 + -X_idx_30) + X_idx_29;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v = -X_idx_12 + X_idx_28 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v = X_idx_28 * 1.0E-6 + X_idx_12;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v = (-X_idx_10 + X_idx_22 * -1.0E-6)\r\n    + -9.0;\r\n  t9 = (X_idx_22 * 1.0E-6 + X_idx_10) + 9.0;\r\n  t10 = (-X_idx_11 + X_idx_25 * -1.0E-6) + -9.0;\r\n  t12 = (X_idx_25 * 1.0E-6 + X_idx_11) + 9.0;\r\n  t13 = (-X_idx_12 + X_idx_28 * -1.0E-6) + -9.0;\r\n  t15 = (X_idx_28 * 1.0E-6 + X_idx_12) + 9.0;\r\n  t17 = X_idx_0 * 0.13333333333333333 + X_idx_15 * 0.00026666666666666668;\r\n  DC_DC_Buck_PLANT_PR2_i = (X_idx_0 * 0.5 + X_idx_13 * -0.5) + X_idx_15 * 0.001;\r\n  t0[0ULL] = X_idx_13;\r\n  t0[1ULL] = U_idx_0;\r\n  t0[2ULL] = 0.0;\r\n  t0[3ULL] = 298.15;\r\n  t0[4ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  t0[5ULL] = 0.0;\r\n  t0[6ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  t0[7ULL] = -X_idx_13;\r\n  t0[8ULL] = X_idx_13;\r\n  t0[9ULL] = X_idx_13;\r\n  t0[10ULL] = 0.0;\r\n  t0[11ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i * -X_idx_13 * 0.001 *\r\n    1000.0;\r\n  t0[12ULL] = -X_idx_13;\r\n  t0[13ULL] = 0.0;\r\n  t0[14ULL] = U_idx_0;\r\n  t0[15ULL] = X_idx_14;\r\n  t0[16ULL] = -(-U_idx_0 + 3.0);\r\n  t0[17ULL] = 0.0;\r\n  t0[18ULL] = X_idx_13;\r\n  t0[19ULL] = X_idx_13;\r\n  t0[20ULL] = X_idx_14 * X_idx_13 * 0.001 * 1000.0;\r\n  t0[21ULL] = U_idx_0;\r\n  t0[22ULL] = X_idx_13;\r\n  t0[23ULL] = 0.0;\r\n  t0[24ULL] = X_idx_16;\r\n  t0[25ULL] = 0.0;\r\n  t0[26ULL] = 9.0;\r\n  t0[27ULL] = 9.0;\r\n  t0[28ULL] = X_idx_1;\r\n  t0[29ULL] = (((((X_idx_0 * -0.6333333333333333 + X_idx_2 *\r\n                   -0.00083333333333333339) + X_idx_13 * 0.5) + X_idx_15 *\r\n                 -1.0012666666666667) + -X_idx_17) + X_idx_18 *\r\n               -1.0000000008333334) + X_idx_19;\r\n  t0[30ULL] = 0.0;\r\n  t0[31ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[32ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[33ULL] = X_idx_3;\r\n  t0[34ULL] = X_idx_15;\r\n  t0[35ULL] = 0.0;\r\n  t0[36ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[37ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[38ULL] = X_idx_0;\r\n  t0[39ULL] = 9.0;\r\n  t0[40ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[41ULL] = 0.0;\r\n  t0[42ULL] = (((X_idx_0 * -0.012195121951219513 + X_idx_15 *\r\n                 -2.4390243902439026E-5) + X_idx_20 * 0.012195121951219513) +\r\n               X_idx_19 * -1.0003658536585365) + X_idx_4;\r\n  t0[43ULL] = X_idx_20;\r\n  t0[44ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[45ULL] = ((X_idx_15 * 0.002 + -X_idx_20) + X_idx_19 * 0.03) + X_idx_0;\r\n  t0[46ULL] = X_idx_5;\r\n  t0[47ULL] = ((((X_idx_0 * -0.012195121951219513 + X_idx_2 *\r\n                  0.00083333333333333339) + X_idx_15 * -2.4390243902439026E-5) +\r\n                X_idx_20 * 0.012195121951219513) + X_idx_18 * 1.0000000008333334)\r\n    + X_idx_17;\r\n  t0[48ULL] = X_idx_20;\r\n  t0[49ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[50ULL] = (X_idx_15 * 0.002 + -X_idx_20) + X_idx_0;\r\n  t0[51ULL] = X_idx_6;\r\n  t0[52ULL] = X_idx_17;\r\n  t0[53ULL] = X_idx_20;\r\n  t0[54ULL] = X_idx_20;\r\n  t0[55ULL] = 0.0;\r\n  t0[56ULL] = X_idx_7;\r\n  t0[57ULL] = ((X_idx_20 * -0.0008333333333333335 + X_idx_19 *\r\n                -0.99999999999999989) + X_idx_17) + X_idx_4;\r\n  t0[58ULL] = 0.0;\r\n  t0[59ULL] = X_idx_20;\r\n  t0[60ULL] = X_idx_20;\r\n  t0[61ULL] = X_idx_8;\r\n  t0[62ULL] = X_idx_18;\r\n  t0[63ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[64ULL] = X_idx_20;\r\n  t0[65ULL] = X_idx_18 * 1.0E-6 + X_idx_2;\r\n  t0[66ULL] = X_idx_2;\r\n  t0[67ULL] = X_idx_21;\r\n  t0[68ULL] = 0.0;\r\n  t0[69ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[70ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[71ULL] = X_idx_9;\r\n  t0[72ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[73ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[74ULL] = 0.0;\r\n  t0[75ULL] = 0.0;\r\n  t0[76ULL] = X_idx_20;\r\n  t0[77ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[78ULL] = (X_idx_2 * 0.00083333333333333339 + X_idx_18 * 1.0000000008333334)\r\n    + -X_idx_21;\r\n  t0[79ULL] = X_idx_20;\r\n  t0[80ULL] = 0.0;\r\n  t0[81ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i;\r\n  t0[82ULL] = 0.0;\r\n  t0[83ULL] = X_idx_20;\r\n  t0[84ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i * 1200.0;\r\n  t0[85ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i;\r\n  t0[86ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[87ULL] = X_idx_20;\r\n  t0[88ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i * 1200.0;\r\n  t0[89ULL] = X_idx_21;\r\n  t0[90ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[91ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[92ULL] = X_idx_21 * 1000.0;\r\n  t0[93ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i;\r\n  t0[94ULL] = X_idx_20;\r\n  t0[95ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[96ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i * 82.0;\r\n  t0[97ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i;\r\n  t0[98ULL] = X_idx_20;\r\n  t0[99ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[100ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i * 82.0;\r\n  t0[101ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[102ULL] = 0.0;\r\n  t0[103ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[104ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[105ULL] = X_idx_22;\r\n  t0[106ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[107ULL] = 0.0;\r\n  t0[108ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[109ULL] = X_idx_10;\r\n  t0[110ULL] = 298.15;\r\n  t0[111ULL] = t4;\r\n  t0[112ULL] = X_idx_22;\r\n  t0[113ULL] = t4;\r\n  t0[114ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[115ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[116ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[117ULL] = (-X_idx_24 + X_idx_4) + X_idx_23;\r\n  t0[118ULL] = 0.0;\r\n  t0[119ULL] = 0.0;\r\n  t0[120ULL] = 0.0;\r\n  t0[121ULL] = 0.0;\r\n  t0[122ULL] = 0.0;\r\n  t0[123ULL] = t4 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v * 0.001 * 1000.0;\r\n  t0[124ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[125ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[126ULL] = X_idx_25;\r\n  t0[127ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[128ULL] = 0.0;\r\n  t0[129ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[130ULL] = X_idx_11;\r\n  t0[131ULL] = 298.15;\r\n  t0[132ULL] = t5;\r\n  t0[133ULL] = X_idx_25;\r\n  t0[134ULL] = t5;\r\n  t0[135ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[136ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[137ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[138ULL] = -X_idx_27 + X_idx_26;\r\n  t0[139ULL] = 0.0;\r\n  t0[140ULL] = 0.0;\r\n  t0[141ULL] = 0.0;\r\n  t0[142ULL] = 0.0;\r\n  t0[143ULL] = 0.0;\r\n  t0[144ULL] = t5 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v * 0.001 * 1000.0;\r\n  t0[145ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[146ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[147ULL] = X_idx_28;\r\n  t0[148ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[149ULL] = 0.0;\r\n  t0[150ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[151ULL] = X_idx_12;\r\n  t0[152ULL] = 298.15;\r\n  t0[153ULL] = t6;\r\n  t0[154ULL] = X_idx_28;\r\n  t0[155ULL] = t6;\r\n  t0[156ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[157ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[158ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[159ULL] = -X_idx_30 + X_idx_29;\r\n  t0[160ULL] = 0.0;\r\n  t0[161ULL] = 0.0;\r\n  t0[162ULL] = 0.0;\r\n  t0[163ULL] = 0.0;\r\n  t0[164ULL] = 0.0;\r\n  t0[165ULL] = t6 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v * 0.001 * 1000.0;\r\n  t0[166ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[167ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[168ULL] = X_idx_4;\r\n  t0[169ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[170ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[171ULL] = (((-X_idx_0 + -X_idx_10) + X_idx_15 * -0.002) + X_idx_22 *\r\n                -1.0E-6) + X_idx_19 * -0.03;\r\n  t0[172ULL] = X_idx_4;\r\n  t0[173ULL] = 9.0;\r\n  t0[174ULL] = U_idx_1;\r\n  t0[175ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[176ULL] = 298.15;\r\n  t0[177ULL] = X_idx_23;\r\n  t0[178ULL] = 0.0;\r\n  t0[179ULL] = X_idx_23;\r\n  t0[180ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  t0[181ULL] = 9.0;\r\n  t0[182ULL] = 9.0;\r\n  t0[183ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[184ULL] = X_idx_23 * DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v * 0.001 *\r\n    1000.0;\r\n  t0[185ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  t0[186ULL] = 0.0;\r\n  t0[187ULL] = U_idx_1;\r\n  t0[188ULL] = X_idx_24;\r\n  t0[189ULL] = -(-U_idx_1 + 1.5);\r\n  t0[190ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[191ULL] = 9.0;\r\n  t0[192ULL] = t9;\r\n  t0[193ULL] = X_idx_24 * t9 * 0.001 * 1000.0;\r\n  t0[194ULL] = 9.0;\r\n  t0[195ULL] = U_idx_2;\r\n  t0[196ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[197ULL] = 298.15;\r\n  t0[198ULL] = X_idx_26;\r\n  t0[199ULL] = 0.0;\r\n  t0[200ULL] = X_idx_26;\r\n  t0[201ULL] = t10;\r\n  t0[202ULL] = 9.0;\r\n  t0[203ULL] = 9.0;\r\n  t0[204ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[205ULL] = X_idx_26 * t10 * 0.001 * 1000.0;\r\n  t0[206ULL] = t10;\r\n  t0[207ULL] = 0.0;\r\n  t0[208ULL] = U_idx_2;\r\n  t0[209ULL] = X_idx_27;\r\n  t0[210ULL] = -(-U_idx_2 + 1.5);\r\n  t0[211ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[212ULL] = 9.0;\r\n  t0[213ULL] = t12;\r\n  t0[214ULL] = X_idx_27 * t12 * 0.001 * 1000.0;\r\n  t0[215ULL] = 9.0;\r\n  t0[216ULL] = U_idx_3;\r\n  t0[217ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[218ULL] = 298.15;\r\n  t0[219ULL] = X_idx_29;\r\n  t0[220ULL] = 0.0;\r\n  t0[221ULL] = X_idx_29;\r\n  t0[222ULL] = t13;\r\n  t0[223ULL] = 9.0;\r\n  t0[224ULL] = 9.0;\r\n  t0[225ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[226ULL] = X_idx_29 * t13 * 0.001 * 1000.0;\r\n  t0[227ULL] = t13;\r\n  t0[228ULL] = 0.0;\r\n  t0[229ULL] = U_idx_3;\r\n  t0[230ULL] = X_idx_30;\r\n  t0[231ULL] = -(-U_idx_3 + 1.5);\r\n  t0[232ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[233ULL] = 9.0;\r\n  t0[234ULL] = t15;\r\n  t0[235ULL] = X_idx_30 * t15 * 0.001 * 1000.0;\r\n  t0[236ULL] = X_idx_19;\r\n  t0[237ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[238ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[239ULL] = X_idx_19 * 0.03;\r\n  t0[240ULL] = U_idx_1;\r\n  t0[241ULL] = U_idx_3;\r\n  t0[242ULL] = U_idx_2;\r\n  t0[243ULL] = 0.0;\r\n  t0[244ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[245ULL] = 0.0;\r\n  t0[246ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[247ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[248ULL] = t17;\r\n  t0[249ULL] = 0.0;\r\n  t0[250ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[251ULL] = t17 * 7.5;\r\n  t0[252ULL] = DC_DC_Buck_PLANT_PR2_i;\r\n  t0[253ULL] = X_idx_13;\r\n  t0[254ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[255ULL] = DC_DC_Buck_PLANT_PR2_i * 2.0;\r\n  t0[256ULL] = (((((-X_idx_16 + -X_idx_24) + -X_idx_27) + -X_idx_30) + X_idx_23)\r\n                + X_idx_26) + X_idx_29;\r\n  t0[257ULL] = 0.0;\r\n  t0[258ULL] = 9.0;\r\n  t0[259ULL] = 9.0;\r\n  for (b = 0; b < 260; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t19;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_act.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_obs_act.h - header for method DCDC_Buck_9d5357ce_1_ds_obs_act */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_ACT_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_OBS_ACT_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_obs_act(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                           /* #ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_ACT_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_all.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_all.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_obs_all(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t18, NeDsMethodOutput *t19)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[260];\r\n  real_T DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  real_T DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  real_T DC_DC_Buck_PLANT_PR2_i;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_16;\r\n  real_T X_idx_17;\r\n  real_T X_idx_18;\r\n  real_T X_idx_19;\r\n  real_T X_idx_2;\r\n  real_T X_idx_20;\r\n  real_T X_idx_21;\r\n  real_T X_idx_22;\r\n  real_T X_idx_23;\r\n  real_T X_idx_24;\r\n  real_T X_idx_25;\r\n  real_T X_idx_26;\r\n  real_T X_idx_27;\r\n  real_T X_idx_28;\r\n  real_T X_idx_29;\r\n  real_T X_idx_3;\r\n  real_T X_idx_30;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t10;\r\n  real_T t12;\r\n  real_T t13;\r\n  real_T t15;\r\n  real_T t17;\r\n  real_T t4;\r\n  real_T t5;\r\n  real_T t6;\r\n  real_T t9;\r\n  int32_T b;\r\n  U_idx_0 = t18->mU.mX[0];\r\n  U_idx_1 = t18->mU.mX[1];\r\n  U_idx_2 = t18->mU.mX[2];\r\n  U_idx_3 = t18->mU.mX[3];\r\n  X_idx_0 = t18->mX.mX[0];\r\n  X_idx_1 = t18->mX.mX[1];\r\n  X_idx_2 = t18->mX.mX[2];\r\n  X_idx_3 = t18->mX.mX[3];\r\n  X_idx_4 = t18->mX.mX[4];\r\n  X_idx_5 = t18->mX.mX[5];\r\n  X_idx_6 = t18->mX.mX[6];\r\n  X_idx_7 = t18->mX.mX[7];\r\n  X_idx_8 = t18->mX.mX[8];\r\n  X_idx_9 = t18->mX.mX[9];\r\n  X_idx_10 = t18->mX.mX[10];\r\n  X_idx_11 = t18->mX.mX[11];\r\n  X_idx_12 = t18->mX.mX[12];\r\n  X_idx_13 = t18->mX.mX[13];\r\n  X_idx_14 = t18->mX.mX[14];\r\n  X_idx_15 = t18->mX.mX[15];\r\n  X_idx_16 = t18->mX.mX[16];\r\n  X_idx_17 = t18->mX.mX[17];\r\n  X_idx_18 = t18->mX.mX[18];\r\n  X_idx_19 = t18->mX.mX[19];\r\n  X_idx_20 = t18->mX.mX[20];\r\n  X_idx_21 = t18->mX.mX[21];\r\n  X_idx_22 = t18->mX.mX[22];\r\n  X_idx_23 = t18->mX.mX[23];\r\n  X_idx_24 = t18->mX.mX[24];\r\n  X_idx_25 = t18->mX.mX[25];\r\n  X_idx_26 = t18->mX.mX[26];\r\n  X_idx_27 = t18->mX.mX[27];\r\n  X_idx_28 = t18->mX.mX[28];\r\n  X_idx_29 = t18->mX.mX[29];\r\n  X_idx_30 = t18->mX.mX[30];\r\n  out = t19->mOBS_ALL;\r\n  DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i = ((X_idx_0 * -0.5 + X_idx_13 *\r\n    0.5) + X_idx_15 * -0.001) + X_idx_14;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v = X_idx_15 * 0.002 + X_idx_0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v = (X_idx_15 * 0.002 +\r\n    X_idx_19 * 0.03) + X_idx_0;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v = (-X_idx_2 + X_idx_18 *\r\n    -1.0E-6) + X_idx_20;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v = X_idx_21 * 1.0E-6 +\r\n    X_idx_9;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i = X_idx_20 *\r\n    0.00083333333333333339;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i = X_idx_2 *\r\n    0.00083333333333333339 + X_idx_18 * 8.3333333333333335E-10;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i = ((X_idx_0 *\r\n    0.012195121951219513 + X_idx_15 * 2.4390243902439026E-5) + X_idx_20 *\r\n    -0.012195121951219513) + X_idx_19 * 0.00036585365853658537;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i = (X_idx_0 *\r\n    0.012195121951219513 + X_idx_15 * 2.4390243902439026E-5) + X_idx_20 *\r\n    -0.012195121951219513;\r\n  t4 = ((-X_idx_22 + -X_idx_24) + X_idx_4) + X_idx_23;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v = -X_idx_10 + X_idx_22 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v = X_idx_22 * 1.0E-6 + X_idx_10;\r\n  t5 = (-X_idx_25 + -X_idx_27) + X_idx_26;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v = -X_idx_11 + X_idx_25 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v = X_idx_25 * 1.0E-6 + X_idx_11;\r\n  t6 = (-X_idx_28 + -X_idx_30) + X_idx_29;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v = -X_idx_12 + X_idx_28 * -1.0E-6;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v = X_idx_28 * 1.0E-6 + X_idx_12;\r\n  DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v = (-X_idx_10 + X_idx_22 * -1.0E-6)\r\n    + -9.0;\r\n  t9 = (X_idx_22 * 1.0E-6 + X_idx_10) + 9.0;\r\n  t10 = (-X_idx_11 + X_idx_25 * -1.0E-6) + -9.0;\r\n  t12 = (X_idx_25 * 1.0E-6 + X_idx_11) + 9.0;\r\n  t13 = (-X_idx_12 + X_idx_28 * -1.0E-6) + -9.0;\r\n  t15 = (X_idx_28 * 1.0E-6 + X_idx_12) + 9.0;\r\n  t17 = X_idx_0 * 0.13333333333333333 + X_idx_15 * 0.00026666666666666668;\r\n  DC_DC_Buck_PLANT_PR2_i = (X_idx_0 * 0.5 + X_idx_13 * -0.5) + X_idx_15 * 0.001;\r\n  t0[0ULL] = X_idx_13;\r\n  t0[1ULL] = U_idx_0;\r\n  t0[2ULL] = 0.0;\r\n  t0[3ULL] = 298.15;\r\n  t0[4ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  t0[5ULL] = 0.0;\r\n  t0[6ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i;\r\n  t0[7ULL] = -X_idx_13;\r\n  t0[8ULL] = X_idx_13;\r\n  t0[9ULL] = X_idx_13;\r\n  t0[10ULL] = 0.0;\r\n  t0[11ULL] = DC_DC_Buck_PLANT_Active_Load_MOSFET_diode_i * -X_idx_13 * 0.001 *\r\n    1000.0;\r\n  t0[12ULL] = -X_idx_13;\r\n  t0[13ULL] = 0.0;\r\n  t0[14ULL] = U_idx_0;\r\n  t0[15ULL] = X_idx_14;\r\n  t0[16ULL] = -(-U_idx_0 + 3.0);\r\n  t0[17ULL] = 0.0;\r\n  t0[18ULL] = X_idx_13;\r\n  t0[19ULL] = X_idx_13;\r\n  t0[20ULL] = X_idx_14 * X_idx_13 * 0.001 * 1000.0;\r\n  t0[21ULL] = U_idx_0;\r\n  t0[22ULL] = X_idx_13;\r\n  t0[23ULL] = 0.0;\r\n  t0[24ULL] = X_idx_16;\r\n  t0[25ULL] = 0.0;\r\n  t0[26ULL] = 9.0;\r\n  t0[27ULL] = 9.0;\r\n  t0[28ULL] = X_idx_1;\r\n  t0[29ULL] = (((((X_idx_0 * -0.6333333333333333 + X_idx_2 *\r\n                   -0.00083333333333333339) + X_idx_13 * 0.5) + X_idx_15 *\r\n                 -1.0012666666666667) + -X_idx_17) + X_idx_18 *\r\n               -1.0000000008333334) + X_idx_19;\r\n  t0[30ULL] = 0.0;\r\n  t0[31ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[32ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[33ULL] = X_idx_3;\r\n  t0[34ULL] = X_idx_15;\r\n  t0[35ULL] = 0.0;\r\n  t0[36ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[37ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[38ULL] = X_idx_0;\r\n  t0[39ULL] = 9.0;\r\n  t0[40ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[41ULL] = 0.0;\r\n  t0[42ULL] = (((X_idx_0 * -0.012195121951219513 + X_idx_15 *\r\n                 -2.4390243902439026E-5) + X_idx_20 * 0.012195121951219513) +\r\n               X_idx_19 * -1.0003658536585365) + X_idx_4;\r\n  t0[43ULL] = X_idx_20;\r\n  t0[44ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[45ULL] = ((X_idx_15 * 0.002 + -X_idx_20) + X_idx_19 * 0.03) + X_idx_0;\r\n  t0[46ULL] = X_idx_5;\r\n  t0[47ULL] = ((((X_idx_0 * -0.012195121951219513 + X_idx_2 *\r\n                  0.00083333333333333339) + X_idx_15 * -2.4390243902439026E-5) +\r\n                X_idx_20 * 0.012195121951219513) + X_idx_18 * 1.0000000008333334)\r\n    + X_idx_17;\r\n  t0[48ULL] = X_idx_20;\r\n  t0[49ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[50ULL] = (X_idx_15 * 0.002 + -X_idx_20) + X_idx_0;\r\n  t0[51ULL] = X_idx_6;\r\n  t0[52ULL] = X_idx_17;\r\n  t0[53ULL] = X_idx_20;\r\n  t0[54ULL] = X_idx_20;\r\n  t0[55ULL] = 0.0;\r\n  t0[56ULL] = X_idx_7;\r\n  t0[57ULL] = ((X_idx_20 * -0.0008333333333333335 + X_idx_19 *\r\n                -0.99999999999999989) + X_idx_17) + X_idx_4;\r\n  t0[58ULL] = 0.0;\r\n  t0[59ULL] = X_idx_20;\r\n  t0[60ULL] = X_idx_20;\r\n  t0[61ULL] = X_idx_8;\r\n  t0[62ULL] = X_idx_18;\r\n  t0[63ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[64ULL] = X_idx_20;\r\n  t0[65ULL] = X_idx_18 * 1.0E-6 + X_idx_2;\r\n  t0[66ULL] = X_idx_2;\r\n  t0[67ULL] = X_idx_21;\r\n  t0[68ULL] = 0.0;\r\n  t0[69ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[70ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[71ULL] = X_idx_9;\r\n  t0[72ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[73ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[74ULL] = 0.0;\r\n  t0[75ULL] = 0.0;\r\n  t0[76ULL] = X_idx_20;\r\n  t0[77ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[78ULL] = (X_idx_2 * 0.00083333333333333339 + X_idx_18 * 1.0000000008333334)\r\n    + -X_idx_21;\r\n  t0[79ULL] = X_idx_20;\r\n  t0[80ULL] = 0.0;\r\n  t0[81ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i;\r\n  t0[82ULL] = 0.0;\r\n  t0[83ULL] = X_idx_20;\r\n  t0[84ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R10_i * 1200.0;\r\n  t0[85ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i;\r\n  t0[86ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[87ULL] = X_idx_20;\r\n  t0[88ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R11_i * 1200.0;\r\n  t0[89ULL] = X_idx_21;\r\n  t0[90ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[91ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C14_n_v;\r\n  t0[92ULL] = X_idx_21 * 1000.0;\r\n  t0[93ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i;\r\n  t0[94ULL] = X_idx_20;\r\n  t0[95ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[96ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R8_i * 82.0;\r\n  t0[97ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i;\r\n  t0[98ULL] = X_idx_20;\r\n  t0[99ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[100ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_R9_i * 82.0;\r\n  t0[101ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[102ULL] = 0.0;\r\n  t0[103ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[104ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C22_p_v;\r\n  t0[105ULL] = X_idx_22;\r\n  t0[106ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[107ULL] = 0.0;\r\n  t0[108ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[109ULL] = X_idx_10;\r\n  t0[110ULL] = 298.15;\r\n  t0[111ULL] = t4;\r\n  t0[112ULL] = X_idx_22;\r\n  t0[113ULL] = t4;\r\n  t0[114ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[115ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[116ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[117ULL] = (-X_idx_24 + X_idx_4) + X_idx_23;\r\n  t0[118ULL] = 0.0;\r\n  t0[119ULL] = 0.0;\r\n  t0[120ULL] = 0.0;\r\n  t0[121ULL] = 0.0;\r\n  t0[122ULL] = 0.0;\r\n  t0[123ULL] = t4 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v * 0.001 * 1000.0;\r\n  t0[124ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[125ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_v;\r\n  t0[126ULL] = X_idx_25;\r\n  t0[127ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[128ULL] = 0.0;\r\n  t0[129ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[130ULL] = X_idx_11;\r\n  t0[131ULL] = 298.15;\r\n  t0[132ULL] = t5;\r\n  t0[133ULL] = X_idx_25;\r\n  t0[134ULL] = t5;\r\n  t0[135ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[136ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[137ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[138ULL] = -X_idx_27 + X_idx_26;\r\n  t0[139ULL] = 0.0;\r\n  t0[140ULL] = 0.0;\r\n  t0[141ULL] = 0.0;\r\n  t0[142ULL] = 0.0;\r\n  t0[143ULL] = 0.0;\r\n  t0[144ULL] = t5 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v * 0.001 * 1000.0;\r\n  t0[145ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[146ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_v;\r\n  t0[147ULL] = X_idx_28;\r\n  t0[148ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[149ULL] = 0.0;\r\n  t0[150ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[151ULL] = X_idx_12;\r\n  t0[152ULL] = 298.15;\r\n  t0[153ULL] = t6;\r\n  t0[154ULL] = X_idx_28;\r\n  t0[155ULL] = t6;\r\n  t0[156ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[157ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[158ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[159ULL] = -X_idx_30 + X_idx_29;\r\n  t0[160ULL] = 0.0;\r\n  t0[161ULL] = 0.0;\r\n  t0[162ULL] = 0.0;\r\n  t0[163ULL] = 0.0;\r\n  t0[164ULL] = 0.0;\r\n  t0[165ULL] = t6 * DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v * 0.001 * 1000.0;\r\n  t0[166ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[167ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_v;\r\n  t0[168ULL] = X_idx_4;\r\n  t0[169ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[170ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[171ULL] = (((-X_idx_0 + -X_idx_10) + X_idx_15 * -0.002) + X_idx_22 *\r\n                -1.0E-6) + X_idx_19 * -0.03;\r\n  t0[172ULL] = X_idx_4;\r\n  t0[173ULL] = 9.0;\r\n  t0[174ULL] = U_idx_1;\r\n  t0[175ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[176ULL] = 298.15;\r\n  t0[177ULL] = X_idx_23;\r\n  t0[178ULL] = 0.0;\r\n  t0[179ULL] = X_idx_23;\r\n  t0[180ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  t0[181ULL] = 9.0;\r\n  t0[182ULL] = 9.0;\r\n  t0[183ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[184ULL] = X_idx_23 * DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v * 0.001 *\r\n    1000.0;\r\n  t0[185ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_MOSFET1_diode_v;\r\n  t0[186ULL] = 0.0;\r\n  t0[187ULL] = U_idx_1;\r\n  t0[188ULL] = X_idx_24;\r\n  t0[189ULL] = -(-U_idx_1 + 1.5);\r\n  t0[190ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode_n_v;\r\n  t0[191ULL] = 9.0;\r\n  t0[192ULL] = t9;\r\n  t0[193ULL] = X_idx_24 * t9 * 0.001 * 1000.0;\r\n  t0[194ULL] = 9.0;\r\n  t0[195ULL] = U_idx_2;\r\n  t0[196ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[197ULL] = 298.15;\r\n  t0[198ULL] = X_idx_26;\r\n  t0[199ULL] = 0.0;\r\n  t0[200ULL] = X_idx_26;\r\n  t0[201ULL] = t10;\r\n  t0[202ULL] = 9.0;\r\n  t0[203ULL] = 9.0;\r\n  t0[204ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[205ULL] = X_idx_26 * t10 * 0.001 * 1000.0;\r\n  t0[206ULL] = t10;\r\n  t0[207ULL] = 0.0;\r\n  t0[208ULL] = U_idx_2;\r\n  t0[209ULL] = X_idx_27;\r\n  t0[210ULL] = -(-U_idx_2 + 1.5);\r\n  t0[211ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode1_n_v;\r\n  t0[212ULL] = 9.0;\r\n  t0[213ULL] = t12;\r\n  t0[214ULL] = X_idx_27 * t12 * 0.001 * 1000.0;\r\n  t0[215ULL] = 9.0;\r\n  t0[216ULL] = U_idx_3;\r\n  t0[217ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[218ULL] = 298.15;\r\n  t0[219ULL] = X_idx_29;\r\n  t0[220ULL] = 0.0;\r\n  t0[221ULL] = X_idx_29;\r\n  t0[222ULL] = t13;\r\n  t0[223ULL] = 9.0;\r\n  t0[224ULL] = 9.0;\r\n  t0[225ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[226ULL] = X_idx_29 * t13 * 0.001 * 1000.0;\r\n  t0[227ULL] = t13;\r\n  t0[228ULL] = 0.0;\r\n  t0[229ULL] = U_idx_3;\r\n  t0[230ULL] = X_idx_30;\r\n  t0[231ULL] = -(-U_idx_3 + 1.5);\r\n  t0[232ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Diode2_n_v;\r\n  t0[233ULL] = 9.0;\r\n  t0[234ULL] = t15;\r\n  t0[235ULL] = X_idx_30 * t15 * 0.001 * 1000.0;\r\n  t0[236ULL] = X_idx_19;\r\n  t0[237ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[238ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_Current_Sensor_C10_p_v;\r\n  t0[239ULL] = X_idx_19 * 0.03;\r\n  t0[240ULL] = U_idx_1;\r\n  t0[241ULL] = U_idx_3;\r\n  t0[242ULL] = U_idx_2;\r\n  t0[243ULL] = 0.0;\r\n  t0[244ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[245ULL] = 0.0;\r\n  t0[246ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[247ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[248ULL] = t17;\r\n  t0[249ULL] = 0.0;\r\n  t0[250ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[251ULL] = t17 * 7.5;\r\n  t0[252ULL] = DC_DC_Buck_PLANT_PR2_i;\r\n  t0[253ULL] = X_idx_13;\r\n  t0[254ULL] = DC_DC_Buck_PLANT_DC_DC_Buck_C4C5C6_p_v;\r\n  t0[255ULL] = DC_DC_Buck_PLANT_PR2_i * 2.0;\r\n  t0[256ULL] = (((((-X_idx_16 + -X_idx_24) + -X_idx_27) + -X_idx_30) + X_idx_23)\r\n                + X_idx_26) + X_idx_29;\r\n  t0[257ULL] = 0.0;\r\n  t0[258ULL] = 9.0;\r\n  t0[259ULL] = 9.0;\r\n  for (b = 0; b < 260; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t19;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_all.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_obs_all.h - header for method DCDC_Buck_9d5357ce_1_ds_obs_all */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_ALL_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_OBS_ALL_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_obs_all(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                           /* #ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_ALL_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_exp.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_exp.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_obs_exp(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  static real_T _cg_const_1[260] = { 0.0, 0.0, 0.0, 298.15, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 298.15, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 298.15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 298.15, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 298.15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 298.15, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    298.15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\r\n\r\n  PmRealVector out;\r\n  real_T t0[260];\r\n  int32_T b;\r\n  (void)t1;\r\n  out = t2->mOBS_EXP;\r\n  for (b = 0; b < 260; b++) {\r\n    t0[b] = _cg_const_1[b];\r\n  }\r\n\r\n  for (b = 0; b < 260; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_exp.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_obs_exp.h - header for method DCDC_Buck_9d5357ce_1_ds_obs_exp */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_EXP_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_OBS_EXP_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_obs_exp(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                           /* #ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_EXP_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_il.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_obs_il.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  static boolean_T _cg_const_1[260] = { true, false, true, true, true, true,\r\n    true, true, true, true, true, false, true, true, false, true, false, true,\r\n    true, true, false, false, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, false, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, true, true, true, true, false,\r\n    true, true, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true, true, false, true, true, true, true,\r\n    true, true, true, true, false, true, true, true, true, true, true, true,\r\n    true, true, false, true, true, false, true, false, true, true, true, false,\r\n    true, false, true, true, true, true, true, true, true, true, true, false,\r\n    true, true, false, true, false, true, true, true, false, true, false, true,\r\n    true, true, true, true, true, true, true, true, false, true, true, false,\r\n    true, false, true, true, true, false, true, true, true, true, false, false,\r\n    false, true, true, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, true, true, true };\r\n\r\n  PmBoolVector out;\r\n  int32_T b;\r\n  boolean_T t0[260];\r\n  (void)t1;\r\n  out = t2->mOBS_IL;\r\n  for (b = 0; b < 260; b++) {\r\n    t0[b] = _cg_const_1[b];\r\n  }\r\n\r\n  for (b = 0; b < 260; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_obs_il.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_obs_il.h - header for method DCDC_Buck_9d5357ce_1_ds_obs_il */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_IL_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_OBS_IL_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                            /* #ifndef DCDC_BUCK_9D5357CE_1_DS_OBS_IL_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_sys_struct.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#ifndef struct__NeDynamicSystemTag\r\n#define struct__NeDynamicSystemTag\r\n\r\ntypedef struct _NeDynamicSystemTag {\r\n  NeDynamicSystem mBase;\r\n  int32_T mRefCnt;\r\n  PmAllocator mAlloc;\r\n} _NeDynamicSystem;\r\n\r\n#else\r\n\r\ntypedef struct _NeDynamicSystemTag _NeDynamicSystem;\r\n\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_tdxf_p.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_tdxf_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_tdxf_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  static int32_T _cg_const_2[120] = { 1, 2, 3, 4, 12, 13, 16, 17, 18, 0, 15, 1,\r\n    4, 7, 16, 18, 21, 1, 16, 3, 6, 12, 17, 20, 22, 3, 17, 4, 18, 5, 19, 6, 20, 8,\r\n    21, 9, 12, 22, 25, 26, 10, 23, 27, 28, 11, 24, 29, 30, 1, 13, 14, 16, 13, 14,\r\n    1, 2, 3, 4, 12, 13, 16, 17, 18, 0, 15, 1, 4, 5, 6, 16, 18, 19, 20, 1, 4, 7,\r\n    16, 18, 21, 1, 3, 6, 12, 16, 17, 20, 3, 4, 6, 17, 18, 20, 21, 8, 21, 9, 12,\r\n    22, 25, 26, 22, 25, 22, 26, 10, 23, 27, 28, 23, 27, 23, 28, 11, 24, 29, 30,\r\n    24, 29, 24, 30 };\r\n\r\n  PmSparsityPattern out;\r\n  int32_T b;\r\n  (void)t1;\r\n  out = t2->mTDXF_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 31ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 9;\r\n  out.mJc[2] = 11;\r\n  out.mJc[3] = 17;\r\n  out.mJc[4] = 19;\r\n  out.mJc[5] = 25;\r\n  out.mJc[6] = 27;\r\n  out.mJc[7] = 29;\r\n  out.mJc[8] = 31;\r\n  out.mJc[9] = 33;\r\n  out.mJc[10] = 35;\r\n  out.mJc[11] = 40;\r\n  out.mJc[12] = 44;\r\n  out.mJc[13] = 48;\r\n  out.mJc[14] = 52;\r\n  out.mJc[15] = 54;\r\n  out.mJc[16] = 63;\r\n  out.mJc[17] = 65;\r\n  out.mJc[18] = 73;\r\n  out.mJc[19] = 79;\r\n  out.mJc[20] = 86;\r\n  out.mJc[21] = 93;\r\n  out.mJc[22] = 95;\r\n  out.mJc[23] = 100;\r\n  out.mJc[24] = 102;\r\n  out.mJc[25] = 104;\r\n  out.mJc[26] = 108;\r\n  out.mJc[27] = 110;\r\n  out.mJc[28] = 112;\r\n  out.mJc[29] = 116;\r\n  out.mJc[30] = 118;\r\n  out.mJc[31] = 120;\r\n  for (b = 0; b < 120; b++) {\r\n    out.mIr[b] = _cg_const_2[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_tdxf_p.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_tdxf_p.h - header for method DCDC_Buck_9d5357ce_1_ds_tdxf_p */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_TDXF_P_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_TDXF_P_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_tdxf_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                            /* #ifndef DCDC_BUCK_9D5357CE_1_DS_TDXF_P_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_tdxy_p.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_tdxy_p.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_tdxy_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDXY_P;\r\n  out.mNumCol = 31ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 1;\r\n  out.mJc[3] = 1;\r\n  out.mJc[4] = 1;\r\n  out.mJc[5] = 1;\r\n  out.mJc[6] = 1;\r\n  out.mJc[7] = 1;\r\n  out.mJc[8] = 1;\r\n  out.mJc[9] = 1;\r\n  out.mJc[10] = 2;\r\n  out.mJc[11] = 2;\r\n  out.mJc[12] = 2;\r\n  out.mJc[13] = 2;\r\n  out.mJc[14] = 2;\r\n  out.mJc[15] = 2;\r\n  out.mJc[16] = 3;\r\n  out.mJc[17] = 3;\r\n  out.mJc[18] = 3;\r\n  out.mJc[19] = 3;\r\n  out.mJc[20] = 3;\r\n  out.mJc[21] = 3;\r\n  out.mJc[22] = 4;\r\n  out.mJc[23] = 4;\r\n  out.mJc[24] = 4;\r\n  out.mJc[25] = 4;\r\n  out.mJc[26] = 4;\r\n  out.mJc[27] = 4;\r\n  out.mJc[28] = 4;\r\n  out.mJc[29] = 4;\r\n  out.mJc[30] = 4;\r\n  out.mJc[31] = 4;\r\n  out.mIr[0] = 1;\r\n  out.mIr[1] = 0;\r\n  out.mIr[2] = 1;\r\n  out.mIr[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_tdxy_p.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_tdxy_p.h - header for method DCDC_Buck_9d5357ce_1_ds_tdxy_p */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_TDXY_P_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_TDXY_P_H 1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_tdxy_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                            /* #ifndef DCDC_BUCK_9D5357CE_1_DS_TDXY_P_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_zc.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_sys_struct.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_zc.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_externals.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCDC_Buck_9d5357ce_1_ds_zc(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t3, NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_22;\r\n  real_T X_idx_25;\r\n  real_T X_idx_28;\r\n  U_idx_0 = t3->mU.mX[0];\r\n  U_idx_1 = t3->mU.mX[1];\r\n  U_idx_2 = t3->mU.mX[2];\r\n  U_idx_3 = t3->mU.mX[3];\r\n  X_idx_10 = t3->mX.mX[10];\r\n  X_idx_11 = t3->mX.mX[11];\r\n  X_idx_12 = t3->mX.mX[12];\r\n  X_idx_13 = t3->mX.mX[13];\r\n  X_idx_22 = t3->mX.mX[22];\r\n  X_idx_25 = t3->mX.mX[25];\r\n  X_idx_28 = t3->mX.mX[28];\r\n  out = t4->mZC;\r\n  out.mX[0] = -X_idx_13 - 1.6;\r\n  out.mX[1] = -79.0 - (X_idx_22 * 1.0E-6 + X_idx_10) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  out.mX[2] = -79.0 - (X_idx_25 * 1.0E-6 + X_idx_11) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  out.mX[3] = -79.0 - (X_idx_28 * 1.0E-6 + X_idx_12) * 1.602176487E-19 /\r\n    4.3497335432938027E-21;\r\n  out.mX[4] = ((-X_idx_10 + X_idx_22 * -1.0E-6) + -9.0) - 0.85;\r\n  out.mX[5] = ((-X_idx_11 + X_idx_25 * -1.0E-6) + -9.0) - 0.85;\r\n  out.mX[6] = ((-X_idx_12 + X_idx_28 * -1.0E-6) + -9.0) - 0.85;\r\n  out.mX[7] = U_idx_0 - 3.0;\r\n  out.mX[8] = U_idx_1 - 1.5;\r\n  out.mX[9] = U_idx_2 - 1.5;\r\n  out.mX[10] = U_idx_3 - 1.5;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_ds_zc.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n/* DCDC_Buck_9d5357ce_1_ds_zc.h - header for method DCDC_Buck_9d5357ce_1_ds_zc */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCDC_BUCK_9D5357CE_1_DS_ZC_H\r\n#define DCDC_BUCK_9D5357CE_1_DS_ZC_H   1\r\n\r\n  int32_T DCDC_Buck_9d5357ce_1_ds_zc(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                                /* #ifndef DCDC_BUCK_9D5357CE_1_DS_ZC_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCDC_Buck_9d5357ce_1_gateway.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#ifdef MATLAB_MEX_FILE\r\n#include \"tmwtypes.h\"\r\n#else\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n#include \"nesl_rtw.h\"\r\n#include \"DCDC_Buck_9d5357ce_1.h\"\r\n#include \"DCDC_Buck_9d5357ce_1_gateway.h\"\r\n\r\nvoid DCDC_Buck_9d5357ce_1_gateway(void)\r\n{\r\n  NeModelParameters modelparams = { (NeSolverType) 0, 0.001, 0, 0, 0.001, 0, 0,\r\n    0, 0, (SscLoggingSetting) 0, 632502036, 0, };\r\n\r\n  NeSolverParameters solverparams = { 0, 0, 1, 0, 0, 0.001, 1e-06, 1e-09, 0, 0,\r\n    100, 0, 1, 0, 1e-08, 0, (NeLocalSolverChoice) 1, 5e-09, 0, 3, 2, 0, 2,\r\n    (NeLinearAlgebraChoice) 1, (NeEquationFormulationChoice) 0, 1024, 1, 0.001,\r\n    (NePartitionStorageMethod) 0, 1024, (NePartitionMethod) 1, };\r\n\r\n  const NeOutputParameters* outputparameters = NULL;\r\n  NeDae* dae;\r\n  size_t numOutputs = 0;\r\n  int* rtpDaes = NULL;\r\n  int* rtwLogDaes = NULL;\r\n\r\n  {\r\n    static const NeOutputParameters outputparameters_init[] = { { 0, 0, }, };\r\n\r\n    outputparameters = outputparameters_init;\r\n    numOutputs = sizeof(outputparameters_init)/sizeof(outputparameters_init[0]);\r\n  }\r\n\r\n  DCDC_Buck_9d5357ce_1_dae(&dae,\r\n    &modelparams,\r\n    &solverparams);\r\n  nesl_register_simulator_group(\r\n    \"DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration_1\",\r\n    1,\r\n    &dae,\r\n    &solverparams,\r\n    &modelparams,\r\n    numOutputs,\r\n    outputparameters,\r\n    0,\r\n    rtpDaes,\r\n    0,\r\n    rtwLogDaes);\r\n}\r\n"},{"name":"DCDC_Buck_9d5357ce_1_gateway.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#ifndef __DCDC_Buck_9d5357ce_1_gateway_h__\r\n#define __DCDC_Buck_9d5357ce_1_gateway_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void DCDC_Buck_9d5357ce_1_gateway(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif                          /* #ifndef __DCDC_Buck_9d5357ce_1_gateway_h__ */\r\n"},{"name":"DSP2833x_ADC_cal.asm","type":"other","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":";; TI File Revision: /main/1 \n;; Checkin Date: July 30, 2007   10:29:23 \n;;###########################################################################\n;;\n;; FILE:    ADC_cal.asm\n;;\n;; TITLE:   2833x Boot Rom ADC Cal routine.\n;;\n;; Functions:\n;;\n;;     _ADC_cal - Copies device specific calibration data into ADCREFSEL and ADCOFFTRIM registers \n;; Notes:\n;;\n;;###########################################################################\n;; $TI Release: DSP2833x Header Files V1.10 $\n;; $Release Date: February 15, 2008 $\n;;###########################################################################\n\n    .def _ADC_cal\n\t.asg \"0x711C\",   ADCREFSEL_LOC\n\n;-----------------------------------------------\n; _ADC_cal\n;-----------------------------------------------\n;-----------------------------------------------\n; This is the ADC cal routine.This routine is programmed into \n; reserved memory by the factory. 0xAAAA and 0xBBBB are place- \n; holders for calibration data.  \n;The actual values programmed by TI are device specific. \n;\n; This function assumes that the clocks have been\n; enabled to the ADC module.\n;-----------------------------------------------\n\n    .sect \".adc_cal\"\n\n_ADC_cal\n    MOVW  DP,   #ADCREFSEL_LOC >> 6\n    MOV   @28,  #0xAAAA            ; actual value may not be 0xAAAA\n    MOV   @29,  #0xBBBB             ; actual value may not be 0xBBBB\n    LRETR\n;eof ----------\n"},{"name":"DSP2833x_CodeStartBranch.asm","type":"other","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":";// TI File Revision: /main/1 \n;// Checkin Date: August 18, 2006   13:45:55 \n;//###########################################################################\n;//\n;// FILE:  DSP2833x_CodeStartBranch.asm\t\n;//\n;// TITLE: Branch for redirecting code execution after boot. \n;//\n;// For these examples, code_start is the first code that is executed after\n;// exiting the boot ROM code. \n;//\n;// The codestart section in the linker cmd file is used to physically place\n;// this code at the correct memory location.  This section should be placed \n;// at the location the BOOT ROM will re-direct the code to.  For example, \n;// for boot to FLASH this code will be located at 0x3f7ff6. \n;//\n;// In addition, the example DSP2833x projects are setup such that the codegen\n;// entry point is also set to the code_start label.  This is done by linker \n;// option -e in the project build options.  When the debugger loads the code,\n;// it will automatically set the PC to the \"entry point\" address indicated by\n;// the -e linker option.  In this case the debugger is simply assigning the PC, \n;// it is not the same as a full reset of the device. \n;// \n;// The compiler may warn that the entry point for the project is other then\n;//  _c_init00.  _c_init00 is the C environment setup and is run before \n;// main() is entered. The code_start code will re-direct the execution \n;// to _c_init00 and thus there is no worry and this warning can be ignored. \n;// \n;//###########################################################################\n;// $TI Release: DSP2833x Header Files V1.10 $\n;// $Release Date: February 15, 2008 $\n;//###########################################################################\n\n\n***********************************************************************\n\nWD_DISABLE\t.set\t1\t\t;set to 1 to disable WD, else set to 0\n\n    .ref _c_int00\n    .global code_start\n\n***********************************************************************\n* Function: codestart section\n*\n* Description: Branch to code starting point\n***********************************************************************\n\n    .sect \"codestart\"\n\ncode_start:\n    .if WD_DISABLE == 1\n        LB wd_disable       ;Branch to watchdog disable code\n    .else\n        LB _c_int00         ;Branch to start of boot.asm in RTS library\n    .endif\n\n;end codestart section\n\n\n***********************************************************************\n* Function: wd_disable\n*\n* Description: Disables the watchdog timer\n***********************************************************************\n    .if WD_DISABLE == 1\n\n    .text\nwd_disable:\n    SETC OBJMODE        ;Set OBJMODE for 28x object code\n    EALLOW              ;Enable EALLOW protected register access\n    MOVZ DP, #7029h>>6  ;Set data page for WDCR register\n    MOV @7029h, #0068h  ;Set WDDIS bit in WDCR to disable WD\n    EDIS                ;Disable EALLOW protected register access\n    LB _c_int00         ;Branch to start of boot.asm in RTS library\n\n    .endif\n\n;end wd_disable\n\n\n\n\t.end\n\t\n;//===========================================================================\n;// End of file.\n;//===========================================================================\n"},{"name":"DSP2833x_CpuTimers.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"// TI File Revision: /main/3 \n// Checkin Date: March 16, 2007   08:37:30 \n//###########################################################################\n//\n// FILE:\tDSP2833x_CpuTimers.c\n//\n// TITLE:\tCPU 32-bit Timers Initialization & Support Functions.\n//\n// NOTES:   CpuTimer1 and CpuTimer2 are reserved for use with DSP BIOS and\n//          other realtime operating systems.\n//\n//          Do not use these two timers in your application if you ever plan\n//          on integrating DSP-BIOS or another realtime OS.\n//\n//\n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n#include \"DSP2833x_Device.h\"     // Headerfile Include File\n#include \"DSP2833x_Examples.h\"   // Examples Include File\n\nstruct CPUTIMER_VARS CpuTimer0;\n\n// CpuTimer 1 and CpuTimer2 are used by DSP BIOS & other RTOS. Comment out if using DSP BIOS or other RTOS.\nstruct CPUTIMER_VARS CpuTimer1;\nstruct CPUTIMER_VARS CpuTimer2;\n\n//---------------------------------------------------------------------------\n// InitCpuTimers:\n//---------------------------------------------------------------------------\n// This function initializes all three CPU timers to a known state.\n//\nvoid InitCpuTimers(void)\n{\n    // CPU Timer 0\n\t// Initialize address pointers to respective timer registers:\n\tCpuTimer0.RegsAddr = &CpuTimer0Regs;\n\t// Initialize timer period to maximum:\n\tCpuTimer0Regs.PRD.all  = 0xFFFFFFFF;\n\t// Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\n\tCpuTimer0Regs.TPR.all  = 0;\n\tCpuTimer0Regs.TPRH.all = 0;\n\t// Make sure timer is stopped:\n\tCpuTimer0Regs.TCR.bit.TSS = 1;\n\t// Reload all counter register with period value:\n\tCpuTimer0Regs.TCR.bit.TRB = 1;\n\t// Reset interrupt counters:\n\tCpuTimer0.InterruptCount = 0;\n\n\n// CpuTimer 1 and CpuTimer2 are reserved for DSP BIOS & other RTOS\n// Do not use these two timers if you ever plan on integrating\n// DSP-BIOS or another realtime OS.\n//\n// Initialize address pointers to respective timer registers:\n\tCpuTimer1.RegsAddr = &CpuTimer1Regs;\n\tCpuTimer2.RegsAddr = &CpuTimer2Regs;\n\t// Initialize timer period to maximum:\n\tCpuTimer1Regs.PRD.all  = 0xFFFFFFFF;\n\tCpuTimer2Regs.PRD.all  = 0xFFFFFFFF;\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\n\tCpuTimer1Regs.TPR.all  = 0;\n\tCpuTimer1Regs.TPRH.all = 0;\n\tCpuTimer2Regs.TPR.all  = 0;\n\tCpuTimer2Regs.TPRH.all = 0;\n    // Make sure timers are stopped:\n\tCpuTimer1Regs.TCR.bit.TSS = 1;\n\tCpuTimer2Regs.TCR.bit.TSS = 1;\n\t// Reload all counter register with period value:\n\tCpuTimer1Regs.TCR.bit.TRB = 1;\n\tCpuTimer2Regs.TCR.bit.TRB = 1;\n\t// Reset interrupt counters:\n\tCpuTimer1.InterruptCount = 0;\n\tCpuTimer2.InterruptCount = 0;\n\n}\n\n//---------------------------------------------------------------------------\n// ConfigCpuTimer:\n//---------------------------------------------------------------------------\n// This function initializes the selected timer to the period specified\n// by the \"Freq\" and \"Period\" parameters. The \"Freq\" is entered as \"MHz\"\n// and the period in \"uSeconds\". The timer is held in the stopped state\n// after configuration.\n//\nvoid ConfigCpuTimer(struct CPUTIMER_VARS *Timer, float Freq, float Period)\n{\n\tUint32 \ttemp;\n\n\t// Initialize timer period:\n\tTimer->CPUFreqInMHz = Freq;\n\tTimer->PeriodInUSec = Period;\n\ttemp = (long) (Freq * Period);\n\tTimer->RegsAddr->PRD.all = temp;\n\n\t// Set pre-scale counter to divide by 1 (SYSCLKOUT):\n\tTimer->RegsAddr->TPR.all  = 0;\n\tTimer->RegsAddr->TPRH.all  = 0;\n\n\t// Initialize timer control register:\n\tTimer->RegsAddr->TCR.bit.TSS = 1;      // 1 = Stop timer, 0 = Start/Restart Timer\n\tTimer->RegsAddr->TCR.bit.TRB = 1;      // 1 = reload timer\n\tTimer->RegsAddr->TCR.bit.SOFT = 0;\n\tTimer->RegsAddr->TCR.bit.FREE = 0;     // Timer Free Run Disabled\n\tTimer->RegsAddr->TCR.bit.TIE = 1;      // 0 = Disable/ 1 = Enable Timer Interrupt\n\n\t// Reset interrupt counter:\n\tTimer->InterruptCount = 0;\n}\n\n//===========================================================================\n// End of file.\n//===========================================================================\n"},{"name":"DSP2833x_DMA.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:\tDSP2833x_DMA.c\n//\n// TITLE:\tDSP2833x Device DMA Initialization & Support Functions.\n//\n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n#include \"DSP2833x_Device.h\"     // Headerfile Include File\n#include \"DSP2833x_Examples.h\"   // Examples Include File\n\n// This function initializes the DMA to a known state.\n//\nvoid DMAInitialize(void)\n{\n\tEALLOW;\n\n\t// Perform a hard reset on DMA\n\tDmaRegs.DMACTRL.bit.HARDRESET = 1;\n\n\t// Allow DMA to run free on emulation suspend\n\tDmaRegs.DEBUGCTRL.bit.FREE = 1;\n\t\n\tEDIS;\n}\n\n  \nvoid DMACH1AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n\tEALLOW;\n\t// Set up SOURCE address:\n\tDmaRegs.CH1.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;\t// Point to beginning of source buffer\n\tDmaRegs.CH1.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n\t// Set up DESTINATION address:\n\tDmaRegs.CH1.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;\t    // Point to beginning of destination buffer\n\tDmaRegs.CH1.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n\t\n\tEDIS;\n}\n\nvoid DMACH1BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n\tEALLOW;\n\t\n\t// Set up BURST registers:\n\tDmaRegs.CH1.BURST_SIZE.all = bsize;\t                // Number of words(X-1) x-ferred in a burst\n\tDmaRegs.CH1.SRC_BURST_STEP = srcbstep;\t\t\t    // Increment source addr between each word x-ferred\n\tDmaRegs.CH1.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\n\n\n\tEDIS;\n}\n\nvoid DMACH1TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n\tEALLOW;\n\t\n\t// Set up TRANSFER registers:\n\tDmaRegs.CH1.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\n\tDmaRegs.CH1.SRC_TRANSFER_STEP = srctstep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\tDmaRegs.CH1.DST_TRANSFER_STEP = deststep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\n\tEDIS;\n}\n\nvoid DMACH1WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\n{\n\tEALLOW;\n\t\n\t\t// Set up WRAP registers:\n\tDmaRegs.CH1.SRC_WRAP_SIZE = srcwsize;\t\t\t\t// Wrap source address after N bursts\n    DmaRegs.CH1.SRC_WRAP_STEP = srcwstep;\t\t\t    // Step for source wrap\n\n\tDmaRegs.CH1.DST_WRAP_SIZE = deswsize;\t\t\t\t// Wrap destination address after N bursts\n\tDmaRegs.CH1.DST_WRAP_STEP = deswstep;\t\t\t\t// Step for destination wrap\n\t\n\tEDIS;\n}\n\n\nvoid DMACH1ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\n{\n\tEALLOW;\n\t    \n\t// Set up MODE Register:\n\tDmaRegs.CH1.MODE.bit.PERINTSEL = persel;\t    // Passed DMA channel as peripheral interrupt source\n\tDmaRegs.CH1.MODE.bit.PERINTE = perinte;       \t// Peripheral interrupt enable\n\tDmaRegs.CH1.MODE.bit.ONESHOT = oneshot;       \t// Oneshot enable\n\tDmaRegs.CH1.MODE.bit.CONTINUOUS = cont;    \t\t// Continous enable\n\tDmaRegs.CH1.MODE.bit.SYNCE = synce;         \t// Peripheral sync enable/disable\n\tDmaRegs.CH1.MODE.bit.SYNCSEL = syncsel;       \t// Sync effects source or destination\n\tDmaRegs.CH1.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\n\tDmaRegs.CH1.MODE.bit.DATASIZE = datasize;      \t// 16-bit/32-bit data size transfers\n\tDmaRegs.CH1.MODE.bit.CHINTMODE = chintmode;\t\t// Generate interrupt to CPU at beginning/end of transfer\n\tDmaRegs.CH1.MODE.bit.CHINTE = chinte;        \t// Channel Interrupt to CPU enable\n\n\t// Clear any spurious flags:\n\tDmaRegs.CH1.CONTROL.bit.PERINTCLR = 1;  \t\t// Clear any spurious interrupt flags\n\tDmaRegs.CH1.CONTROL.bit.SYNCCLR = 1;    \t\t// Clear any spurious sync flags\n\tDmaRegs.CH1.CONTROL.bit.ERRCLR = 1; \t     \t// Clear any spurious sync error flags\n\n\t// Initialize PIE vector for CPU interrupt:\n\tPieCtrlRegs.PIEIER7.bit.INTx1 = 1;              // Enable DMA CH1 interrupt in PIE\n\n\tEDIS;\n}\n\n// This function starts DMA Channel 1. \nvoid StartDMACH1(void)\n{\n\tEALLOW;\n\tDmaRegs.CH1.CONTROL.bit.RUN = 1;\n\tEDIS;\n}\n\nvoid DMACH2AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n\tEALLOW;\n\t\n\t// Set up SOURCE address:\n\tDmaRegs.CH2.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;\t// Point to beginning of source buffer\n\tDmaRegs.CH2.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n\t// Set up DESTINATION address:\n\tDmaRegs.CH2.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;\t    // Point to beginning of destination buffer\n\tDmaRegs.CH2.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n\t\n\tEDIS;\n}\n\nvoid DMACH2BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n\tEALLOW;\n\n\t// Set up BURST registers:\n\tDmaRegs.CH2.BURST_SIZE.all = bsize;\t                // Number of words(X-1) x-ferred in a burst\n\tDmaRegs.CH2.SRC_BURST_STEP = srcbstep;\t\t\t    // Increment source addr between each word x-ferred\n\tDmaRegs.CH2.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\n\n\n\tEDIS;\n}\n\nvoid DMACH2TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n\tEALLOW;\n\t\n\t\t// Set up TRANSFER registers:\n\tDmaRegs.CH2.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\n\tDmaRegs.CH2.SRC_TRANSFER_STEP = srctstep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\tDmaRegs.CH2.DST_TRANSFER_STEP = deststep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\n\tEDIS;\n}\n\nvoid DMACH2WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\n{\n\tEALLOW;\n\t\n\t\t// Set up WRAP registers:\n\tDmaRegs.CH2.SRC_WRAP_SIZE = srcwsize;\t\t\t\t// Wrap source address after N bursts\n    DmaRegs.CH2.SRC_WRAP_STEP = srcwstep;\t\t\t    // Step for source wrap\n\n\tDmaRegs.CH2.DST_WRAP_SIZE = deswsize;\t\t\t\t// Wrap destination address after N bursts\n\tDmaRegs.CH2.DST_WRAP_STEP = deswstep;\t\t\t\t// Step for destination wrap\n\t\n\tEDIS;\n}\n\n\nvoid DMACH2ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\n{\n\tEALLOW;\n\t\n\t\t// Set up MODE Register:\n\tDmaRegs.CH2.MODE.bit.PERINTSEL = persel;\t    // Passed DMA channel as peripheral interrupt source\n\tDmaRegs.CH2.MODE.bit.PERINTE = perinte;       \t// Peripheral interrupt enable\n\tDmaRegs.CH2.MODE.bit.ONESHOT = oneshot;       \t// Oneshot enable\n\tDmaRegs.CH2.MODE.bit.CONTINUOUS = cont;    \t\t// Continous enable\n\tDmaRegs.CH2.MODE.bit.SYNCE = synce;         \t// Peripheral sync enable/disable\n\tDmaRegs.CH2.MODE.bit.SYNCSEL = syncsel;       \t// Sync effects source or destination\n\tDmaRegs.CH2.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\n\tDmaRegs.CH2.MODE.bit.DATASIZE = datasize;      \t// 16-bit/32-bit data size transfers\n\tDmaRegs.CH2.MODE.bit.CHINTMODE = chintmode;\t\t// Generate interrupt to CPU at beginning/end of transfer\n\tDmaRegs.CH2.MODE.bit.CHINTE = chinte;        \t// Channel Interrupt to CPU enable\n\n\t// Clear any spurious flags:\n\tDmaRegs.CH2.CONTROL.bit.PERINTCLR = 1;  \t\t// Clear any spurious interrupt flags\n\tDmaRegs.CH2.CONTROL.bit.SYNCCLR = 1;    \t\t// Clear any spurious sync flags\n\tDmaRegs.CH2.CONTROL.bit.ERRCLR = 1; \t     \t// Clear any spurious sync error flags\n\n\t// Initialize PIE vector for CPU interrupt:\n\tPieCtrlRegs.PIEIER7.bit.INTx2 = 1;              // Enable DMA CH2 interrupt in PIE\n\n\tEDIS;\n}\n\n\n\n// This function starts DMA Channel 2. \t\nvoid StartDMACH2(void)\n{\n\tEALLOW;\n\tDmaRegs.CH2.CONTROL.bit.RUN = 1;\n\tEDIS;\n}\n\n\n\nvoid DMACH3AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n\tEALLOW;\n\t\n\t// Set up SOURCE address:\n\tDmaRegs.CH3.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;\t// Point to beginning of source buffer\n\tDmaRegs.CH3.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n\t// Set up DESTINATION address:\n\tDmaRegs.CH3.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;\t    // Point to beginning of destination buffer\n\tDmaRegs.CH3.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n\t\n\tEDIS;\n}\n\nvoid DMACH3BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n\tEALLOW;\n\n\t// Set up BURST registers:\n\tDmaRegs.CH3.BURST_SIZE.all = bsize;\t                // Number of words(X-1) x-ferred in a burst\n\tDmaRegs.CH3.SRC_BURST_STEP = srcbstep;\t\t\t    // Increment source addr between each word x-ferred\n\tDmaRegs.CH3.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\n\n\n\tEDIS;\n}\n\nvoid DMACH3TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n\tEALLOW;\n\n\t\t// Set up TRANSFER registers:\n\tDmaRegs.CH3.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\n\tDmaRegs.CH3.SRC_TRANSFER_STEP = srctstep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\tDmaRegs.CH3.DST_TRANSFER_STEP = deststep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\t\n\tEDIS;\n}\n\nvoid DMACH3WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\n{\n\tEALLOW;\n\t\n\t\t\t// Set up WRAP registers:\n\tDmaRegs.CH3.SRC_WRAP_SIZE = srcwsize;\t\t\t\t// Wrap source address after N bursts\n    DmaRegs.CH3.SRC_WRAP_STEP = srcwstep;\t\t\t    // Step for source wrap\n\n\tDmaRegs.CH3.DST_WRAP_SIZE = deswsize;\t\t\t\t// Wrap destination address after N bursts\n\tDmaRegs.CH3.DST_WRAP_STEP = deswstep;\t\t\t\t// Step for destination wrap\n\t\n\tEDIS;\n}\n\n\nvoid DMACH3ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\n{\n\tEALLOW;\n\t\n\t// Set up MODE Register:\n\tDmaRegs.CH3.MODE.bit.PERINTSEL = persel;\t    // Passed DMA channel as peripheral interrupt source\n\tDmaRegs.CH3.MODE.bit.PERINTE = perinte;       \t// Peripheral interrupt enable\n\tDmaRegs.CH3.MODE.bit.ONESHOT = oneshot;       \t// Oneshot enable\n\tDmaRegs.CH3.MODE.bit.CONTINUOUS = cont;    \t\t// Continous enable\n\tDmaRegs.CH3.MODE.bit.SYNCE = synce;         \t// Peripheral sync enable/disable\n\tDmaRegs.CH3.MODE.bit.SYNCSEL = syncsel;       \t// Sync effects source or destination\n\tDmaRegs.CH3.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\n\tDmaRegs.CH3.MODE.bit.DATASIZE = datasize;      \t// 16-bit/32-bit data size transfers\n\tDmaRegs.CH3.MODE.bit.CHINTMODE = chintmode;\t\t// Generate interrupt to CPU at beginning/end of transfer\n\tDmaRegs.CH3.MODE.bit.CHINTE = chinte;        \t// Channel Interrupt to CPU enable\n\n\t// Clear any spurious flags:\n\tDmaRegs.CH3.CONTROL.bit.PERINTCLR = 1;  \t\t// Clear any spurious interrupt flags\n\tDmaRegs.CH3.CONTROL.bit.SYNCCLR = 1;    \t\t// Clear any spurious sync flags\n\tDmaRegs.CH3.CONTROL.bit.ERRCLR = 1; \t     \t// Clear any spurious sync error flags\n\n\t// Initialize PIE vector for CPU interrupt:\n\tPieCtrlRegs.PIEIER7.bit.INTx3 = 1;              // Enable DMA CH3 interrupt in PIE\n\n\tEDIS;\n}\n\n// This function starts DMA Channel 3. \t\nvoid StartDMACH3(void)\n{\n\tEALLOW;\n\tDmaRegs.CH3.CONTROL.bit.RUN = 1;\n\tEDIS;\n}\n\n\nvoid DMACH4AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n\tEALLOW;\n\n\t// Set up SOURCE address:\n\tDmaRegs.CH4.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;\t// Point to beginning of source buffer\n\tDmaRegs.CH4.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n\t// Set up DESTINATION address:\n\tDmaRegs.CH4.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;\t    // Point to beginning of destination buffer\n\tDmaRegs.CH4.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n\t\n\tEDIS;\n}\n\nvoid DMACH4BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n\tEALLOW;\n\n\t// Set up BURST registers:\n\tDmaRegs.CH4.BURST_SIZE.all = bsize;\t                // Number of words(X-1) x-ferred in a burst\n\tDmaRegs.CH4.SRC_BURST_STEP = srcbstep;\t\t\t    // Increment source addr between each word x-ferred\n\tDmaRegs.CH4.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\n\n\n\tEDIS;\n}\n\nvoid DMACH4TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n\tEALLOW;\n\t\n\t// Set up TRANSFER registers:\n\tDmaRegs.CH4.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\n\tDmaRegs.CH4.SRC_TRANSFER_STEP = srctstep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\tDmaRegs.CH4.DST_TRANSFER_STEP = deststep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\t\n\tEDIS;\n}\n\nvoid DMACH4WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\n{\n\tEALLOW;\n\t\n\t\t// Set up WRAP registers:\n\tDmaRegs.CH4.SRC_WRAP_SIZE = srcwsize;\t\t\t\t// Wrap source address after N bursts\n    DmaRegs.CH4.SRC_WRAP_STEP = srcwstep;\t\t\t    // Step for source wrap\n\n\tDmaRegs.CH4.DST_WRAP_SIZE = deswsize;\t\t\t\t// Wrap destination address after N bursts\n\tDmaRegs.CH4.DST_WRAP_STEP = deswstep;\t\t\t\t// Step for destination wrap\n\t\n\tEDIS;\n}\n\n\nvoid DMACH4ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\n{\n\tEALLOW;\n\t\n\t\t// Set up MODE Register:\n\tDmaRegs.CH4.MODE.bit.PERINTSEL = persel;\t    // Passed DMA channel as peripheral interrupt source\n\tDmaRegs.CH4.MODE.bit.PERINTE = perinte;       \t// Peripheral interrupt enable\n\tDmaRegs.CH4.MODE.bit.ONESHOT = oneshot;       \t// Oneshot enable\n\tDmaRegs.CH4.MODE.bit.CONTINUOUS = cont;    \t\t// Continous enable\n\tDmaRegs.CH4.MODE.bit.SYNCE = synce;         \t// Peripheral sync enable/disable\n\tDmaRegs.CH4.MODE.bit.SYNCSEL = syncsel;       \t// Sync effects source or destination\n\tDmaRegs.CH4.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\n\tDmaRegs.CH4.MODE.bit.DATASIZE = datasize;      \t// 16-bit/32-bit data size transfers\n\tDmaRegs.CH4.MODE.bit.CHINTMODE = chintmode;\t\t// Generate interrupt to CPU at beginning/end of transfer\n\tDmaRegs.CH4.MODE.bit.CHINTE = chinte;        \t// Channel Interrupt to CPU enable\n\n\t// Clear any spurious flags:\n\tDmaRegs.CH4.CONTROL.bit.PERINTCLR = 1;  \t\t// Clear any spurious interrupt flags\n\tDmaRegs.CH4.CONTROL.bit.SYNCCLR = 1;    \t\t// Clear any spurious sync flags\n\tDmaRegs.CH4.CONTROL.bit.ERRCLR = 1; \t     \t// Clear any spurious sync error flags\n\n\t// Initialize PIE vector for CPU interrupt:\n\tPieCtrlRegs.PIEIER7.bit.INTx4 = 1;              // Enable DMA CH4 interrupt in PIE\n\n\tEDIS;\n}\n\n\n// This function starts DMA Channel 4. \t\nvoid StartDMACH4(void)\n{\n\tEALLOW;\n\tDmaRegs.CH4.CONTROL.bit.RUN = 1;\n\tEDIS;\n}\n\n\nvoid DMACH5AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n\tEALLOW;\n\t\n\t// Set up SOURCE address:\n\tDmaRegs.CH5.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;\t// Point to beginning of source buffer\n\tDmaRegs.CH5.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n\t// Set up DESTINATION address:\n\tDmaRegs.CH5.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;\t    // Point to beginning of destination buffer\n\tDmaRegs.CH5.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n\t\n\tEDIS;\n}\n\nvoid DMACH5BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n\tEALLOW;\n\n\n\t// Set up BURST registers:\n\tDmaRegs.CH5.BURST_SIZE.all = bsize;\t                // Number of words(X-1) x-ferred in a burst\n\tDmaRegs.CH5.SRC_BURST_STEP = srcbstep;\t\t\t    // Increment source addr between each word x-ferred\n\tDmaRegs.CH5.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\n\n\tEDIS;\n}\n\nvoid DMACH5TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n\tEALLOW;\n\t\n\n\t\t// Set up TRANSFER registers:\n\tDmaRegs.CH5.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\n\tDmaRegs.CH5.SRC_TRANSFER_STEP = srctstep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\tDmaRegs.CH5.DST_TRANSFER_STEP = deststep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\t\n\tEDIS;\n}\n\nvoid DMACH5WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\n{\n\tEALLOW;\n\t\n\n\t\t// Set up WRAP registers:\n\tDmaRegs.CH5.SRC_WRAP_SIZE = srcwsize;\t\t\t\t// Wrap source address after N bursts\n    DmaRegs.CH5.SRC_WRAP_STEP = srcwstep;\t\t\t    // Step for source wrap\n\n\tDmaRegs.CH5.DST_WRAP_SIZE = deswsize;\t\t\t\t// Wrap destination address after N bursts\n\tDmaRegs.CH5.DST_WRAP_STEP = deswstep;\t\t\t\t// Step for destination wrap\n\t\n\tEDIS;\n}\n\n\nvoid DMACH5ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\n{\n\tEALLOW;\n\t\n\t\t// Set up MODE Register:\n\tDmaRegs.CH5.MODE.bit.PERINTSEL = persel;\t    // Passed DMA channel as peripheral interrupt source\n\tDmaRegs.CH5.MODE.bit.PERINTE = perinte;       \t// Peripheral interrupt enable\n\tDmaRegs.CH5.MODE.bit.ONESHOT = oneshot;       \t// Oneshot enable\n\tDmaRegs.CH5.MODE.bit.CONTINUOUS = cont;    \t\t// Continous enable\n\tDmaRegs.CH5.MODE.bit.SYNCE = synce;         \t// Peripheral sync enable/disable\n\tDmaRegs.CH5.MODE.bit.SYNCSEL = syncsel;       \t// Sync effects source or destination\n\tDmaRegs.CH5.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\n\tDmaRegs.CH5.MODE.bit.DATASIZE = datasize;      \t// 16-bit/32-bit data size transfers\n\tDmaRegs.CH5.MODE.bit.CHINTMODE = chintmode;\t\t// Generate interrupt to CPU at beginning/end of transfer\n\tDmaRegs.CH5.MODE.bit.CHINTE = chinte;        \t// Channel Interrupt to CPU enable\n\n\t// Clear any spurious flags:\n\tDmaRegs.CH5.CONTROL.bit.PERINTCLR = 1;  \t\t// Clear any spurious interrupt flags\n\tDmaRegs.CH5.CONTROL.bit.SYNCCLR = 1;    \t\t// Clear any spurious sync flags\n\tDmaRegs.CH5.CONTROL.bit.ERRCLR = 1; \t     \t// Clear any spurious sync error flags\n\n\t// Initialize PIE vector for CPU interrupt:\n\tPieCtrlRegs.PIEIER7.bit.INTx5 = 1;              // Enable DMA CH5 interrupt in PIE\n\n\tEDIS;\n}\n\n// This function starts DMA Channel 5. \t\nvoid StartDMACH5(void)\n{\n\tEALLOW;\n\tDmaRegs.CH5.CONTROL.bit.RUN = 1;\n\tEDIS;\n}\n\n\n\nvoid DMACH6AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n\tEALLOW;\n\t\n\t// Set up SOURCE address:\n\tDmaRegs.CH6.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;\t// Point to beginning of source buffer\n\tDmaRegs.CH6.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n\t// Set up DESTINATION address:\n\tDmaRegs.CH6.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;\t    // Point to beginning of destination buffer\n\tDmaRegs.CH6.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n\t\n\tEDIS;\n}\n\nvoid DMACH6BurstConfig(Uint16 bsize,Uint16 srcbstep, int16 desbstep)\n{\n\tEALLOW;\n\n\t// Set up BURST registers:\n\tDmaRegs.CH6.BURST_SIZE.all = bsize;\t                // Number of words(X-1) x-ferred in a burst\n\tDmaRegs.CH6.SRC_BURST_STEP = srcbstep;\t\t\t\t    // Increment source addr between each word x-ferred\n\tDmaRegs.CH6.DST_BURST_STEP = desbstep;                // Increment dest addr between each word x-ferred\n\n\n\tEDIS;\n}\n\nvoid DMACH6TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n\tEALLOW;\n\n\t// Set up TRANSFER registers:\n\tDmaRegs.CH6.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\n\tDmaRegs.CH6.SRC_TRANSFER_STEP = srctstep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\tDmaRegs.CH6.DST_TRANSFER_STEP = deststep;\t\t\t// TRANSFER_STEP is ignored when WRAP occurs\n\t\n\tEDIS;\n}\n\nvoid DMACH6WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\n{\n\tEALLOW;\n\n\t\t// Set up WRAP registers:\n\tDmaRegs.CH6.SRC_WRAP_SIZE = srcwsize;\t\t\t\t// Wrap source address after N bursts\n    DmaRegs.CH6.SRC_WRAP_STEP = srcwstep;\t\t\t    // Step for source wrap\n\n\tDmaRegs.CH6.DST_WRAP_SIZE = deswsize;\t\t\t\t// Wrap destination address after N bursts\n\tDmaRegs.CH6.DST_WRAP_STEP = deswstep;\t\t\t\t// Step for destination wrap\n\t\n\tEDIS;\n}\n\n\nvoid DMACH6ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\n{\n\tEALLOW;\n\n\t\t// Set up MODE Register:\n\tDmaRegs.CH6.MODE.bit.PERINTSEL = persel;\t    // Passed DMA channel as peripheral interrupt source\n\tDmaRegs.CH6.MODE.bit.PERINTE = perinte;       \t// Peripheral interrupt enable\n\tDmaRegs.CH6.MODE.bit.ONESHOT = oneshot;       \t// Oneshot enable\n\tDmaRegs.CH6.MODE.bit.CONTINUOUS = cont;    \t\t// Continous enable\n\tDmaRegs.CH6.MODE.bit.SYNCE = synce;         \t// Peripheral sync enable/disable\n\tDmaRegs.CH6.MODE.bit.SYNCSEL = syncsel;       \t// Sync effects source or destination\n\tDmaRegs.CH6.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\n\tDmaRegs.CH6.MODE.bit.DATASIZE = datasize;      \t// 16-bit/32-bit data size transfers\n\tDmaRegs.CH6.MODE.bit.CHINTMODE = chintmode;\t\t// Generate interrupt to CPU at beginning/end of transfer\n\tDmaRegs.CH6.MODE.bit.CHINTE = chinte;        \t// Channel Interrupt to CPU enable\n\n\t// Clear any spurious flags:\n\tDmaRegs.CH6.CONTROL.bit.PERINTCLR = 1;  \t\t// Clear any spurious interrupt flags\n\tDmaRegs.CH6.CONTROL.bit.SYNCCLR = 1;    \t\t// Clear any spurious sync flags\n\tDmaRegs.CH6.CONTROL.bit.ERRCLR = 1; \t     \t// Clear any spurious sync error flags\n\n\t// Initialize PIE vector for CPU interrupt:\n\tPieCtrlRegs.PIEIER7.bit.INTx6 = 1;              // Enable DMA CH6 interrupt in PIE\n\n\tEDIS;\n}\n\n// This function starts DMA Channel 6. \t\nvoid StartDMACH6(void)\n{\n\tEALLOW;\n\tDmaRegs.CH6.CONTROL.bit.RUN = 1;\n\tEDIS;\n}\n\n//===========================================================================\n// No more.\n//===========================================================================\n"},{"name":"DSP2833x_DefaultIsr.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"// TI File Revision: /main/2 \n// Checkin Date: January 14, 2008   11:17:46 \n//###########################################################################\n//\n// FILE:\tDSP2833x_DefaultIsr.c\n//\n// TITLE:\tDSP2833x Device Default Interrupt Service Routines.\n//\n// This file contains shell ISR routines for the 2833x PIE vector table.\n// Typically these shell ISR routines can be used to populate the entire PIE \n// vector table during device debug.  In this manner if an interrupt is taken\n// during firmware development, there will always be an ISR to catch it.  \n//\n// As develpment progresses, these ISR rotuines can be eliminated and replaced\n// with the user's own ISR routines for each interrupt.  Since these shell ISRs\n// include infinite loops they will typically not be included as-is in the final\n// production firmware. \n//\n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n#include \"DSP2833x_Device.h\"     // DSP2833x Headerfile Include File\n#include \"DSP2833x_Examples.h\"   // DSP2833x Examples Include File\n\n\n// Connected to INT13 of CPU (use MINT13 mask):\n// Note CPU-Timer1 is reserved for TI use, however XINT13\n// ISR can be used by the user. \ninterrupt void INT13_ISR(void)     // INT13 or CPU-Timer1\n{\n  // Insert ISR Code here\n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// Note CPU-Timer2 is reserved for TI use.\ninterrupt void INT14_ISR(void)     // CPU-Timer2\n{\n  // Insert ISR Code here\n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void DATALOG_ISR(void)   // Datalogging interrupt\n{\n   // Insert ISR Code here\n \n   // Next two lines for debug only to halt the processor here\n   // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\ninterrupt void RTOSINT_ISR(void)   // RTOS interrupt\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void EMUINT_ISR(void)    // Emulation interrupt\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void NMI_ISR(void)       // Non-maskable interrupt\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void ILLEGAL_ISR(void)   // Illegal operation TRAP\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm(\"          ESTOP0\");\n  for(;;);\n\n}\n\n\ninterrupt void USER1_ISR(void)     // User Defined trap 1\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\ninterrupt void USER2_ISR(void)     // User Defined trap 2\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n\n}\n\ninterrupt void USER3_ISR(void)     // User Defined trap 3\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER4_ISR(void)     // User Defined trap 4\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER5_ISR(void)     // User Defined trap 5\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER6_ISR(void)     // User Defined trap 6\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER7_ISR(void)     // User Defined trap 7\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER8_ISR(void)     // User Defined trap 8\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER9_ISR(void)     // User Defined trap 9\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER10_ISR(void)    // User Defined trap 10\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER11_ISR(void)    // User Defined trap 11\n{\n  // Insert ISR Code here\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void USER12_ISR(void)     // User Defined trap 12\n{\n // Insert ISR Code here\n \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// -----------------------------------------------------------\n// PIE Group 1 - MUXed into CPU INT1\n// -----------------------------------------------------------\n\n// INT1.1 \ninterrupt void SEQ1INT_ISR(void)   //SEQ1 ADC\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}     \n\n// INT1.2 \ninterrupt void SEQ2INT_ISR(void)  //SEQ2 ADC\n{\n\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  \n  asm(\"\t  ESTOP0\");\n  for(;;);\n\t\n}\n// INT1.3 - Reserved\n\n// INT1.4\ninterrupt void  XINT1_ISR(void)\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}     \n\n// INT1.5\ninterrupt void  XINT2_ISR(void)\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT1.6\ninterrupt void  ADCINT_ISR(void)     // ADC\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; \n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT1.7\ninterrupt void  TINT0_ISR(void)      // CPU-Timer 0\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; \n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n\n// INT1.8\ninterrupt void  WAKEINT_ISR(void)    // WD, LOW Power\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; \n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n\n// -----------------------------------------------------------\n// PIE Group 2 - MUXed into CPU INT2\n// -----------------------------------------------------------\n\n// INT2.1\ninterrupt void EPWM1_TZINT_ISR(void)    // EPWM-1\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT2.2\ninterrupt void EPWM2_TZINT_ISR(void)    // EPWM-2\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT2.3\ninterrupt void EPWM3_TZINT_ISR(void)    // EPWM-3\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n\n// INT2.4\ninterrupt void EPWM4_TZINT_ISR(void)    // EPWM-4\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n\n// INT2.5\ninterrupt void EPWM5_TZINT_ISR(void)    // EPWM-5\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT2.6\ninterrupt void EPWM6_TZINT_ISR(void)   // EPWM-6\n{\n  // Insert ISR Code here\n\n   \n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT2.7 - Reserved\n// INT2.8 - Reserved\n\n// -----------------------------------------------------------\n// PIE Group 3 - MUXed into CPU INT3\n// -----------------------------------------------------------\n   \n// INT 3.1         \ninterrupt void EPWM1_INT_ISR(void)     // EPWM-1\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT3.2\ninterrupt void EPWM2_INT_ISR(void)     // EPWM-2\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT3.3\ninterrupt void EPWM3_INT_ISR(void)    // EPWM-3\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT3.4\ninterrupt void EPWM4_INT_ISR(void)    // EPWM-4\n{\n  // Insert ISR Code here\n  \n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;  \n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT3.5\ninterrupt void EPWM5_INT_ISR(void)    // EPWM-5\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;  \n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT3.6\ninterrupt void EPWM6_INT_ISR(void)    // EPWM-6\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT3.7 - Reserved\n// INT3.8 - Reserved\n\n\n// -----------------------------------------------------------\n// PIE Group 4 - MUXed into CPU INT4\n// -----------------------------------------------------------\n\n// INT 4.1\ninterrupt void ECAP1_INT_ISR(void)    // ECAP-1\n{\n  // Insert ISR Code here\n  \n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;  \n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT4.2\ninterrupt void ECAP2_INT_ISR(void)    // ECAP-2\n{\n  // Insert ISR Code here\n  \n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT4.3\ninterrupt void ECAP3_INT_ISR(void)    // ECAP-3\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n  \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT4.4\ninterrupt void ECAP4_INT_ISR(void)     // ECAP-4\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT4.5\ninterrupt void ECAP5_INT_ISR(void)     // ECAP-5\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n// INT4.6\ninterrupt void ECAP6_INT_ISR(void)     // ECAP-6\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n// INT4.7 - Reserved\n// INT4.8 - Reserved\n\n// -----------------------------------------------------------\n// PIE Group 5 - MUXed into CPU INT5\n// -----------------------------------------------------------\n\n// INT 5.1\ninterrupt void EQEP1_INT_ISR(void)    // EQEP-1\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT5.2\ninterrupt void EQEP2_INT_ISR(void)    // EQEP-2\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n \n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT5.3 - Reserved\n// INT5.4 - Reserved\n// INT5.5 - Reserved\n// INT5.6 - Reserved\n// INT5.7 - Reserved\n// INT5.8 - Reserved\n\n// -----------------------------------------------------------\n// PIE Group 6 - MUXed into CPU INT6\n// -----------------------------------------------------------\n\n// INT6.1\ninterrupt void SPIRXINTA_ISR(void)    // SPI-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT6.2\ninterrupt void SPITXINTA_ISR(void)     // SPI-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT6.3 \ninterrupt void MRINTB_ISR(void)     // McBSP-B\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT6.4\ninterrupt void MXINTB_ISR(void)     // McBSP-B\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT6.5\ninterrupt void MRINTA_ISR(void)     // McBSP-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT6.6\ninterrupt void MXINTA_ISR(void)     // McBSP-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT6.7 - Reserved\n// INT6.8 - Reserved\n\n\n\n\n// -----------------------------------------------------------\n// PIE Group 7 - MUXed into CPU INT7\n// -----------------------------------------------------------\n\n// INT7.1\ninterrupt void DINTCH1_ISR(void)     // DMA\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT7.2\ninterrupt void DINTCH2_ISR(void)     // DMA\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT7.3\ninterrupt void DINTCH3_ISR(void)     // DMA\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT7.4\ninterrupt void DINTCH4_ISR(void)     // DMA\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT7.5\ninterrupt void DINTCH5_ISR(void)     // DMA\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT7.6\ninterrupt void DINTCH6_ISR(void)     // DMA\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n   asm (\"      ESTOP0\");\n   for(;;);\n}\n\n// INT7.7 - Reserved\n// INT7.8 - Reserved\n\n// -----------------------------------------------------------\n// PIE Group 8 - MUXed into CPU INT8\n// -----------------------------------------------------------\n\n// INT8.1\ninterrupt void I2CINT1A_ISR(void)     // I2C-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT8.2\ninterrupt void I2CINT2A_ISR(void)     // I2C-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n// INT8.3 - Reserved\n// INT8.4 - Reserved\n\n// INT8.5\ninterrupt void SCIRXINTC_ISR(void)     // SCI-C\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT8.6\ninterrupt void SCITXINTC_ISR(void)     // SCI-C\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT8.7 - Reserved\n// INT8.8 - Reserved\n\n\n// -----------------------------------------------------------\n// PIE Group 9 - MUXed into CPU INT9\n// -----------------------------------------------------------\n\n// INT9.1\ninterrupt void SCIRXINTA_ISR(void)     // SCI-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT9.2\ninterrupt void SCITXINTA_ISR(void)     // SCI-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n\n// INT9.3\ninterrupt void SCIRXINTB_ISR(void)     // SCI-B\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT9.4\ninterrupt void SCITXINTB_ISR(void)     // SCI-B\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT9.5\ninterrupt void ECAN0INTA_ISR(void)  // eCAN-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT9.6\ninterrupt void ECAN1INTA_ISR(void)  // eCAN-A\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT9.7\ninterrupt void ECAN0INTB_ISR(void)  // eCAN-B\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT9.8\ninterrupt void ECAN1INTB_ISR(void)  // eCAN-B\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// -----------------------------------------------------------\n// PIE Group 10 - MUXed into CPU INT10\n// -----------------------------------------------------------\n\n// INT10.1 - Reserved\n// INT10.2 - Reserved\n// INT10.3 - Reserved\n// INT10.4 - Reserved\n// INT10.5 - Reserved\n// INT10.6 - Reserved\n// INT10.7 - Reserved\n// INT10.8 - Reserved\n\n\n// -----------------------------------------------------------\n// PIE Group 11 - MUXed into CPU INT11\n// -----------------------------------------------------------\n\n// INT11.1 - Reserved\n// INT11.2 - Reserved\n// INT11.3 - Reserved\n// INT11.4 - Reserved\n// INT11.5 - Reserved\n// INT11.6 - Reserved\n// INT11.7 - Reserved\n// INT11.8 - Reserved\n\n// -----------------------------------------------------------\n// PIE Group 12 - MUXed into CPU INT12\n// -----------------------------------------------------------\n\n// INT12.1\ninterrupt void XINT3_ISR(void)  // External Interrupt\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT12.2\ninterrupt void XINT4_ISR(void)  // External Interrupt\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT12.3\ninterrupt void XINT5_ISR(void)  // External Interrupt\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n// INT12.4\ninterrupt void XINT6_ISR(void)  // External Interrupt\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT12.5\ninterrupt void XINT7_ISR(void)  // External Interrupt\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n// INT12.6 - Reserved\n// INT12.7\ninterrupt void LVF_ISR(void)  // Latched overflow\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n// INT12.8\ninterrupt void LUF_ISR(void)  // Latched underflow\n{\n  // Insert ISR Code here\n\n  // To receive more interrupts from this PIE group, acknowledge this interrupt \n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n  // Next two lines for debug only to halt the processor here\n  // Remove after inserting ISR Code\n  asm (\"      ESTOP0\");\n  for(;;);\n\n}\n\n//---------------------------------------------------------------------------\n// Catch All Default ISRs: \n//\n\ninterrupt void PIE_RESERVED(void)  // Reserved space.  For test.\n{\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\ninterrupt void rsvd_ISR(void)      // For test\n{\n  asm (\"      ESTOP0\");\n  for(;;);\n}\n\n//===========================================================================\n// End of file.\n//===========================================================================\n\n"},{"name":"DSP2833x_GlobalVariableDefs.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"// TI File Revision: /main/2 \n// Checkin Date: March 5, 2007   12:20:33 \n//###########################################################################\n//\n// FILE:\tDSP2833x_GlobalVariableDefs.c\n//\n// TITLE:\tDSP2833x Global Variables and Data Section Pragmas.\n//\n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n#include \"DSP2833x_Device.h\"     // DSP2833x Headerfile Include File\n\n//---------------------------------------------------------------------------\n// Define Global Peripheral Variables:\n//\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcRegsFile\")\n#else\n#pragma DATA_SECTION(AdcRegs,\"AdcRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcMirrorFile\")\n#else\n#pragma DATA_SECTION(AdcMirror,\"AdcMirrorFile\");\n#endif\nvolatile struct ADC_RESULT_MIRROR_REGS AdcMirror;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer0RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer0Regs,\"CpuTimer0RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer0Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer1RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer1Regs,\"CpuTimer1RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer1Regs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer2RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer2Regs,\"CpuTimer2RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer2Regs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CsmPwlFile\")\n#else\n#pragma DATA_SECTION(CsmPwl,\"CsmPwlFile\");\n#endif\nvolatile struct CSM_PWL CsmPwl;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CsmRegsFile\")\n#else\n#pragma DATA_SECTION(CsmRegs,\"CsmRegsFile\");\n#endif\nvolatile struct CSM_REGS CsmRegs;\n\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DevEmuRegsFile\")\n#else\n#pragma DATA_SECTION(DevEmuRegs,\"DevEmuRegsFile\");\n#endif\nvolatile struct DEV_EMU_REGS DevEmuRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DmaRegsFile\")\n#else\n#pragma DATA_SECTION(DmaRegs,\"DmaRegsFile\");\n#endif\nvolatile struct DMA_REGS DmaRegs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanaRegsFile\")\n#else\n#pragma DATA_SECTION(ECanaRegs,\"ECanaRegsFile\");\n#endif\nvolatile struct ECAN_REGS ECanaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanaMboxesFile\")\n#else\n#pragma DATA_SECTION(ECanaMboxes,\"ECanaMboxesFile\");\n#endif\nvolatile struct ECAN_MBOXES ECanaMboxes;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanaLAMRegsFile\")\n#else\n#pragma DATA_SECTION(ECanaLAMRegs,\"ECanaLAMRegsFile\");\n#endif\nvolatile struct LAM_REGS ECanaLAMRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanaMOTSRegsFile\")\n#else\n#pragma DATA_SECTION(ECanaMOTSRegs,\"ECanaMOTSRegsFile\");\n#endif\nvolatile struct MOTS_REGS ECanaMOTSRegs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanaMOTORegsFile\")\n#else\n#pragma DATA_SECTION(ECanaMOTORegs,\"ECanaMOTORegsFile\");\n#endif\nvolatile struct MOTO_REGS ECanaMOTORegs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanbRegsFile\")\n#else\n#pragma DATA_SECTION(ECanbRegs,\"ECanbRegsFile\");\n#endif\nvolatile struct ECAN_REGS ECanbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanbMboxesFile\")\n#else\n#pragma DATA_SECTION(ECanbMboxes,\"ECanbMboxesFile\");\n#endif\nvolatile struct ECAN_MBOXES ECanbMboxes;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanbLAMRegsFile\")\n#else\n#pragma DATA_SECTION(ECanbLAMRegs,\"ECanbLAMRegsFile\");\n#endif\nvolatile struct LAM_REGS ECanbLAMRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanbMOTSRegsFile\")\n#else\n#pragma DATA_SECTION(ECanbMOTSRegs,\"ECanbMOTSRegsFile\");\n#endif\nvolatile struct MOTS_REGS ECanbMOTSRegs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECanbMOTORegsFile\")\n#else\n#pragma DATA_SECTION(ECanbMOTORegs,\"ECanbMOTORegsFile\");\n#endif\nvolatile struct MOTO_REGS ECanbMOTORegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm1RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm1Regs,\"EPwm1RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm1Regs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm2RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm2Regs,\"EPwm2RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm3RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm3Regs,\"EPwm3RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm4RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm4Regs,\"EPwm4RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm5RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm5Regs,\"EPwm5RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm6RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm6Regs,\"EPwm6RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm6Regs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap1RegsFile\")\n#else\n#pragma DATA_SECTION(ECap1Regs,\"ECap1RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap1Regs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap2RegsFile\")\n#else\n#pragma DATA_SECTION(ECap2Regs,\"ECap2RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap3RegsFile\")\n#else\n#pragma DATA_SECTION(ECap3Regs,\"ECap3RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap4RegsFile\")\n#else\n#pragma DATA_SECTION(ECap4Regs,\"ECap4RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap5RegsFile\")\n#else\n#pragma DATA_SECTION(ECap5Regs,\"ECap5RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap6RegsFile\")\n#else\n#pragma DATA_SECTION(ECap6Regs,\"ECap6RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep1RegsFile\")\n#else\n#pragma DATA_SECTION(EQep1Regs,\"EQep1RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep2RegsFile\")\n#else\n#pragma DATA_SECTION(EQep2Regs,\"EQep2RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(GpioCtrlRegs,\"GpioCtrlRegsFile\");\n#endif\nvolatile struct GPIO_CTRL_REGS GpioCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioDataRegsFile\")\n#else\n#pragma DATA_SECTION(GpioDataRegs,\"GpioDataRegsFile\");\n#endif\nvolatile struct GPIO_DATA_REGS GpioDataRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioIntRegsFile\")\n#else\n#pragma DATA_SECTION(GpioIntRegs,\"GpioIntRegsFile\");\n#endif\nvolatile struct GPIO_INT_REGS GpioIntRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"I2caRegsFile\")\n#else\n#pragma DATA_SECTION(I2caRegs,\"I2caRegsFile\");\n#endif\nvolatile struct I2C_REGS I2caRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"McbspaRegsFile\")\n#else\n#pragma DATA_SECTION(McbspaRegs,\"McbspaRegsFile\");\n#endif\nvolatile struct MCBSP_REGS McbspaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"McbspbRegsFile\")\n#else\n#pragma DATA_SECTION(McbspbRegs,\"McbspbRegsFile\");\n#endif\nvolatile struct MCBSP_REGS McbspbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(PieCtrlRegs,\"PieCtrlRegsFile\");\n#endif\nvolatile struct PIE_CTRL_REGS PieCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieVectTableFile\")\n#else\n#pragma DATA_SECTION(PieVectTable,\"PieVectTableFile\");\n#endif\nstruct PIE_VECT_TABLE PieVectTable;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SciaRegsFile\")\n#else\n#pragma DATA_SECTION(SciaRegs,\"SciaRegsFile\");\n#endif\nvolatile struct SCI_REGS SciaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScibRegsFile\")\n#else\n#pragma DATA_SECTION(ScibRegs,\"ScibRegsFile\");\n#endif\nvolatile struct SCI_REGS ScibRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScicRegsFile\")\n#else\n#pragma DATA_SECTION(ScicRegs,\"ScicRegsFile\");\n#endif\nvolatile struct SCI_REGS ScicRegs;\n\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpiaRegsFile\")\n#else\n#pragma DATA_SECTION(SpiaRegs,\"SpiaRegsFile\");\n#endif\nvolatile struct SPI_REGS SpiaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SysCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(SysCtrlRegs,\"SysCtrlRegsFile\");\n#endif\nvolatile struct SYS_CTRL_REGS SysCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"FlashRegsFile\")\n#else\n#pragma DATA_SECTION(FlashRegs,\"FlashRegsFile\");\n#endif\nvolatile struct FLASH_REGS FlashRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XIntruptRegsFile\")\n#else\n#pragma DATA_SECTION(XIntruptRegs,\"XIntruptRegsFile\");\n#endif\nvolatile struct XINTRUPT_REGS XIntruptRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XintfRegsFile\")\n#else\n#pragma DATA_SECTION(XintfRegs,\"XintfRegsFile\");\n#endif\nvolatile struct XINTF_REGS XintfRegs;\n\n\n\n//===========================================================================\n// End of file.\n//===========================================================================\n\n\n\n\n\n\n\n\n\n"},{"name":"DSP2833x_MemCopy.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"// TI File Revision: /main/1 \n// Checkin Date: August 18, 2006   13:46:33 \n//###########################################################################\n//\n// FILE:\tDSP2833x_MemCopy.c\n//\n// TITLE:\tMemory Copy Utility\n//\n// ASSUMPTIONS:\n//\n//          \n//\n// DESCRIPTION:\n//\n//          This function will copy the specified memory contents from\n//          one location to another. \n// \n//          Uint16 *SourceAddr        Pointer to the first word to be moved\n//                                    SourceAddr < SourceEndAddr\n//          Uint16* SourceEndAddr     Pointer to the last word to be moved\n//          Uint16* DestAddr          Pointer to the first destination word\n//\n//          No checks are made for invalid memory locations or that the\n//          end address is > then the first start address.\n// \n//          \n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n#include \"DSP2833x_Device.h\"\n\nvoid MemCopy(Uint16 *SourceAddr, Uint16* SourceEndAddr, Uint16* DestAddr)\n{\n    while(SourceAddr < SourceEndAddr)\n    { \n       *DestAddr++ = *SourceAddr++;\n    }\n    return;\n}\n\n//===========================================================================\n// End of file.\n//===========================================================================\n"},{"name":"DSP2833x_PieCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"// TI File Revision: /main/1 \n// Checkin Date: August 18, 2006   13:46:35 \n//###########################################################################\n//\n// FILE:\tDSP2833x_PieCtrl.c\n//\n// TITLE:\tDSP2833x Device PIE Control Register Initialization Functions.\n//\n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n#include \"DSP2833x_Device.h\"     // DSP2833x Headerfile Include File\n#include \"DSP2833x_Examples.h\"   // DSP2833x Examples Include File\n\n//---------------------------------------------------------------------------\n// InitPieCtrl: \n//---------------------------------------------------------------------------\n// This function initializes the PIE control registers to a known state.\n//\nvoid InitPieCtrl(void)\n{\n    // Disable Interrupts at the CPU level:\n    DINT;\n\n    // Disable the PIE\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 0;\n\n\t// Clear all PIEIER registers:\n\tPieCtrlRegs.PIEIER1.all = 0;\n\tPieCtrlRegs.PIEIER2.all = 0;\n\tPieCtrlRegs.PIEIER3.all = 0;\t\n\tPieCtrlRegs.PIEIER4.all = 0;\n\tPieCtrlRegs.PIEIER5.all = 0;\n\tPieCtrlRegs.PIEIER6.all = 0;\n\tPieCtrlRegs.PIEIER7.all = 0;\n\tPieCtrlRegs.PIEIER8.all = 0;\n\tPieCtrlRegs.PIEIER9.all = 0;\n\tPieCtrlRegs.PIEIER10.all = 0;\n\tPieCtrlRegs.PIEIER11.all = 0;\n\tPieCtrlRegs.PIEIER12.all = 0;\n\n\t// Clear all PIEIFR registers:\n\tPieCtrlRegs.PIEIFR1.all = 0;\n\tPieCtrlRegs.PIEIFR2.all = 0;\n\tPieCtrlRegs.PIEIFR3.all = 0;\t\n\tPieCtrlRegs.PIEIFR4.all = 0;\n\tPieCtrlRegs.PIEIFR5.all = 0;\n\tPieCtrlRegs.PIEIFR6.all = 0;\n\tPieCtrlRegs.PIEIFR7.all = 0;\n\tPieCtrlRegs.PIEIFR8.all = 0;\n\tPieCtrlRegs.PIEIFR9.all = 0;\n\tPieCtrlRegs.PIEIFR10.all = 0;\n\tPieCtrlRegs.PIEIFR11.all = 0;\n\tPieCtrlRegs.PIEIFR12.all = 0;\n\n\n}\t\n\n//---------------------------------------------------------------------------\n// EnableInterrupts: \n//---------------------------------------------------------------------------\n// This function enables the PIE module and CPU interrupts\n//\nvoid EnableInterrupts()\n{\n\n    // Enable the PIE\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\n    \t\t\n\t// Enables PIE to drive a pulse into the CPU \n\tPieCtrlRegs.PIEACK.all = 0xFFFF;  \n\n\t// Enable Interrupts at the CPU level \n    EINT;\n\n}\n\n\n//===========================================================================\n// End of file.\n//===========================================================================\n"},{"name":"DSP2833x_PieVect.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"// TI File Revision: /main/1 \n// Checkin Date: August 18, 2006   13:46:38 \n//###########################################################################\n//\n// FILE:\tDSP2833x_PieVect.c\n//\n// TITLE:\tDSP2833x Devices PIE Vector Table Initialization Functions.\n//\n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n#include \"DSP2833x_Device.h\"     // DSP2833x Headerfile Include File\n#include \"DSP2833x_Examples.h\"   // DSP2833x Examples Include File\n\n\nconst struct PIE_VECT_TABLE PieVectTableInit = {\n\n      PIE_RESERVED,  // 0  Reserved space\n      PIE_RESERVED,  // 1  Reserved space \n      PIE_RESERVED,  // 2  Reserved space \n      PIE_RESERVED,  // 3  Reserved space \n      PIE_RESERVED,  // 4  Reserved space \n      PIE_RESERVED,  // 5  Reserved space \n      PIE_RESERVED,  // 6  Reserved space \n      PIE_RESERVED,  // 7  Reserved space \n      PIE_RESERVED,  // 8  Reserved space \n      PIE_RESERVED,  // 9  Reserved space \n      PIE_RESERVED,  // 10 Reserved space \n      PIE_RESERVED,  // 11 Reserved space \n      PIE_RESERVED,  // 12 Reserved space \n\n\n// Non-Peripheral Interrupts\n      INT13_ISR,     // XINT13 or CPU-Timer 1\n      INT14_ISR,     // CPU-Timer2\n      DATALOG_ISR,   // Datalogging interrupt\n      RTOSINT_ISR,   // RTOS interrupt\n      EMUINT_ISR,    // Emulation interrupt\n      NMI_ISR,       // Non-maskable interrupt\n      ILLEGAL_ISR,   // Illegal operation TRAP\n      USER1_ISR,     // User Defined trap 1\n      USER2_ISR,     // User Defined trap 2\n      USER3_ISR,     // User Defined trap 3\n      USER4_ISR,     // User Defined trap 4\n      USER5_ISR,     // User Defined trap 5\n      USER6_ISR,     // User Defined trap 6\n      USER7_ISR,     // User Defined trap 7\n      USER8_ISR,     // User Defined trap 8\n      USER9_ISR,     // User Defined trap 9\n      USER10_ISR,    // User Defined trap 10\n      USER11_ISR,    // User Defined trap 11\n      USER12_ISR,    // User Defined trap 12\n\n// Group 1 PIE Vectors\n      SEQ1INT_ISR,     // 1.1 ADC  \n      SEQ2INT_ISR,     // 1.2 ADC  \n      rsvd_ISR,        // 1.3\n      XINT1_ISR,       // 1.4     \n      XINT2_ISR,       // 1.5\n      ADCINT_ISR,      // 1.6 ADC\n      TINT0_ISR,       // 1.7 Timer 0\n      WAKEINT_ISR,     // 1.8 WD, Low Power\n\n// Group 2 PIE Vectors\n      EPWM1_TZINT_ISR, // 2.1 EPWM-1 Trip Zone\n      EPWM2_TZINT_ISR, // 2.2 EPWM-2 Trip Zone\n      EPWM3_TZINT_ISR, // 2.3 EPWM-3 Trip Zone\n      EPWM4_TZINT_ISR, // 2.4 EPWM-4 Trip Zone\n      EPWM5_TZINT_ISR, // 2.5 EPWM-5 Trip Zone\n      EPWM6_TZINT_ISR, // 2.6 EPWM-6 Trip Zone                        \n      rsvd_ISR,        // 2.7\n      rsvd_ISR,        // 2.8\n      \n// Group 3 PIE Vectors\n      EPWM1_INT_ISR,   // 3.1 EPWM-1 Interrupt\n      EPWM2_INT_ISR,   // 3.2 EPWM-2 Interrupt\n      EPWM3_INT_ISR,   // 3.3 EPWM-3 Interrupt\n      EPWM4_INT_ISR,   // 3.4 EPWM-4 Interrupt\n      EPWM5_INT_ISR,   // 3.5 EPWM-5 Interrupt\n      EPWM6_INT_ISR,   // 3.6 EPWM-6 Interrupt                        \n      rsvd_ISR,        // 3.7\n      rsvd_ISR,        // 3.8\n      \n// Group 4 PIE Vectors\n      ECAP1_INT_ISR,   // 4.1 ECAP-1\n      ECAP2_INT_ISR,   // 4.2 ECAP-2\n      ECAP3_INT_ISR,   // 4.3 ECAP-3\n      ECAP4_INT_ISR,   // 4.4 ECAP-4            \n      ECAP5_INT_ISR,   // 4.5 ECAP-5     \n      ECAP6_INT_ISR,   // 4.6 ECAP-6          \n      rsvd_ISR,        // 4.7      \n      rsvd_ISR,        // 4.8      \n      \n// Group 5 PIE Vectors\n      EQEP1_INT_ISR,   // 5.1 EQEP-1\n      EQEP2_INT_ISR,   // 5.2 EQEP-2\n      rsvd_ISR,        // 5.3      \n      rsvd_ISR,        // 5.4           \n      rsvd_ISR,        // 5.5      \n      rsvd_ISR,        // 5.6      \n      rsvd_ISR,        // 5.7      \n      rsvd_ISR,        // 5.8   \n\n\n// Group 6 PIE Vectors\n      SPIRXINTA_ISR,   // 6.1 SPI-A\n      SPITXINTA_ISR,   // 6.2 SPI-A\n      MRINTA_ISR,      // 6.3 McBSP-A\n      MXINTA_ISR,      // 6.4 McBSP-A\n      MRINTB_ISR,      // 6.5 McBSP-B\n      MXINTB_ISR,      // 6.6 McBSP-B\n      rsvd_ISR,        // 6.7 \n      rsvd_ISR,        // 6.8                  \n\n      \n// Group 7 PIE Vectors\n      DINTCH1_ISR,     // 7.1  DMA channel 1    \n      DINTCH2_ISR,     // 7.2  DMA channel 2\n      DINTCH3_ISR,     // 7.3  DMA channel 3      \n      DINTCH4_ISR,     // 7.4  DMA channel 4           \n      DINTCH5_ISR,     // 7.5  DMA channel 5      \n      DINTCH6_ISR,     // 7.6  DMA channel 6      \n      rsvd_ISR,        // 7.7      \n      rsvd_ISR,        // 7.8   \n\n// Group 8 PIE Vectors\n      I2CINT1A_ISR,    // 8.1  I2C    \n      I2CINT2A_ISR,    // 8.2  I2C\n      rsvd_ISR,        // 8.3      \n      rsvd_ISR,        // 8.4           \n      SCIRXINTC_ISR,   // 8.5  SCI-C\n      SCITXINTC_ISR,   // 8.6  SCI-C      \n      rsvd_ISR,        // 8.7      \n      rsvd_ISR,        // 8.8    \n      \n// Group 9 PIE Vectors     \n      SCIRXINTA_ISR,   // 9.1 SCI-A\n      SCITXINTA_ISR,   // 9.2 SCI-A\n      SCIRXINTB_ISR,   // 9.3 SCI-B\n      SCITXINTB_ISR,   // 9.4 SCI-B\n      ECAN0INTA_ISR,   // 9.5 eCAN-A\n      ECAN1INTA_ISR,   // 9.6 eCAN-A\n      ECAN0INTB_ISR,   // 9.7 eCAN-B\n      ECAN1INTB_ISR,   // 9.8 eCAN-B\n      \n// Group 10 PIE Vectors\n      rsvd_ISR,        // 10.1      \n      rsvd_ISR,        // 10.2\n      rsvd_ISR,        // 10.3      \n      rsvd_ISR,        // 10.4           \n      rsvd_ISR,        // 10.5      \n      rsvd_ISR,        // 10.6      \n      rsvd_ISR,        // 10.7      \n      rsvd_ISR,        // 10.8    \n            \n// Group 11 PIE Vectors\n      rsvd_ISR,        // 11.1      \n      rsvd_ISR,        // 11.2\n      rsvd_ISR,        // 11.3      \n      rsvd_ISR,        // 11.4           \n      rsvd_ISR,        // 11.5      \n      rsvd_ISR,        // 11.6      \n      rsvd_ISR,        // 11.7      \n      rsvd_ISR,        // 11.8\n        \n// Group 12 PIE Vectors\n      XINT3_ISR,       // 12.1      \n      XINT4_ISR,       // 12.2\n      XINT5_ISR,       // 12.3      \n      XINT6_ISR,       // 12.4           \n      XINT7_ISR,       // 12.5      \n      rsvd_ISR,        // 12.6      \n      LVF_ISR,         // 12.7      \n      LUF_ISR,         // 12.8   \n};\n\n\n//---------------------------------------------------------------------------\n// InitPieVectTable: \n//---------------------------------------------------------------------------\n// This function initializes the PIE vector table to a known state.\n// This function must be executed after boot time.\n//\n\nvoid InitPieVectTable(void)\n{\n\tint16\ti;\n\tUint32 *Source = (void *) &PieVectTableInit;\n\tUint32 *Dest = (void *) &PieVectTable;\n\t\t\n\tEALLOW;\t\n\tfor(i=0; i < 128; i++)\n\t\t*Dest++ = *Source++;\t\n\tEDIS;\n\n\t// Enable the PIE Vector Table\n\tPieCtrlRegs.PIECTRL.bit.ENPIE = 1;\t\n\t\t\t\n}\n\n//===========================================================================\n// End of file.\n//===========================================================================\n"},{"name":"DSP2833x_SysCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"// TI File Revision: /main/7 \n// Checkin Date: September 20, 2007   13:30:31 \n//###########################################################################\n//\n// FILE:   DSP2833x_SysCtrl.c\n//\n// TITLE:  DSP2833x Device System Control Initialization & Support Functions.\n//\n// DESCRIPTION:\n//\n//         Example initialization of system resources.\n//\n//###########################################################################\n// $TI Release: DSP2833x Header Files V1.10 $\n// $Release Date: February 15, 2008 $\n//###########################################################################\n\n\n#include \"DSP2833x_Device.h\"     // Headerfile Include File\n#include \"DSP2833x_Examples.h\"   // Examples Include File\n\n// Functions that will be run from RAM need to be assigned to\n// a different section.  This section will then be mapped to a load and\n// run address using the linker cmd file.\n\n#pragma CODE_SECTION(InitFlash, \"ramfuncs\");\n\n//---------------------------------------------------------------------------\n// InitSysCtrl:\n//---------------------------------------------------------------------------\n// This function initializes the System Control registers to a known state.\n// - Disables the watchdog\n// - Set the PLLCR for proper SYSCLKOUT frequency\n// - Set the pre-scaler for the high and low frequency peripheral clocks\n// - Enable the clocks to the peripherals\n\nvoid InitSysCtrl(void)\n{\n\n   // Disable the watchdog\n   DisableDog();\n\n   // Initialize the PLL control: PLLCR and DIVSEL\n   // DSP28_PLLCR and DSP28_DIVSEL are defined in DSP2833x_Examples.h\n   InitPll(DSP28_PLLCR,DSP28_DIVSEL);\n\n   // Initialize the peripheral clocks\n   InitPeripheralClocks();\n}\n\n\n//---------------------------------------------------------------------------\n// Example: InitFlash:\n//---------------------------------------------------------------------------\n// This function initializes the Flash Control registers\n\n//                   CAUTION\n// This function MUST be executed out of RAM. Executing it\n// out of OTP/Flash will yield unpredictable results\n\nvoid InitFlash(void)\n{\n   EALLOW;\n   //Enable Flash Pipeline mode to improve performance\n   //of code executed from Flash.\n   FlashRegs.FOPT.bit.ENPIPE = 1;\n\n   //                CAUTION\n   //Minimum waitstates required for the flash operating\n   //at a given CPU rate must be characterized by TI.\n   //Refer to the datasheet for the latest information.\n#if CPU_FRQ_150MHZ\n   //Set the Paged Waitstate for the Flash\n   FlashRegs.FBANKWAIT.bit.PAGEWAIT = 5;\n\n   //Set the Random Waitstate for the Flash\n   FlashRegs.FBANKWAIT.bit.RANDWAIT = 5;\n\n   //Set the Waitstate for the OTP\n   FlashRegs.FOTPWAIT.bit.OTPWAIT = 8;\n#endif\n\n#if CPU_FRQ_100MHZ\n   //Set the Paged Waitstate for the Flash\n   FlashRegs.FBANKWAIT.bit.PAGEWAIT = 3;\n\n   //Set the Random Waitstate for the Flash\n   FlashRegs.FBANKWAIT.bit.RANDWAIT = 3;\n\n   //Set the Waitstate for the OTP\n   FlashRegs.FOTPWAIT.bit.OTPWAIT = 5;\n#endif\n   //                CAUTION\n   //ONLY THE DEFAULT VALUE FOR THESE 2 REGISTERS SHOULD BE USED\n   FlashRegs.FSTDBYWAIT.bit.STDBYWAIT = 0x01FF;\n   FlashRegs.FACTIVEWAIT.bit.ACTIVEWAIT = 0x01FF;\n   EDIS;\n\n   //Force a pipeline flush to ensure that the write to\n   //the last register configured occurs before returning.\n\n   asm(\" RPT #7 || NOP\");\n}\n\n\n//---------------------------------------------------------------------------\n// Example: ServiceDog:\n//---------------------------------------------------------------------------\n// This function resets the watchdog timer.\n// Enable this function for using ServiceDog in the application\n\nvoid ServiceDog(void)\n{\n    EALLOW;\n    SysCtrlRegs.WDKEY = 0x0055;\n    SysCtrlRegs.WDKEY = 0x00AA;\n    EDIS;\n}\n\n//---------------------------------------------------------------------------\n// Example: DisableDog:\n//---------------------------------------------------------------------------\n// This function disables the watchdog timer.\n\nvoid DisableDog(void)\n{\n    EALLOW;\n    SysCtrlRegs.WDCR= 0x0068;\n    EDIS;\n}\n\n//---------------------------------------------------------------------------\n// Example: InitPll:\n//---------------------------------------------------------------------------\n// This function initializes the PLLCR register.\n\nvoid InitPll(Uint16 val, Uint16 divsel)\n{\n\n   // Make sure the PLL is not running in limp mode\n   if (SysCtrlRegs.PLLSTS.bit.MCLKSTS != 0)\n   {\n      // Missing external clock has been detected\n      // Replace this line with a call to an appropriate\n      // SystemShutdown(); function.\n      asm(\"        ESTOP0\");\n   }\n\n   // DIVSEL MUST be 0 before PLLCR can be changed from\n   // 0x0000. It is set to 0 by an external reset XRSn\n   // This puts us in 1/4\n   if (SysCtrlRegs.PLLSTS.bit.DIVSEL != 0)\n   {\n       EALLOW;\n       SysCtrlRegs.PLLSTS.bit.DIVSEL = 0;\n       EDIS;\n   }\n\n   // Change the PLLCR\n   if (SysCtrlRegs.PLLCR.bit.DIV != val)\n   {\n\n      EALLOW;\n      // Before setting PLLCR turn off missing clock detect logic\n      SysCtrlRegs.PLLSTS.bit.MCLKOFF = 1;\n      SysCtrlRegs.PLLCR.bit.DIV = val;\n      EDIS;\n\n      // Optional: Wait for PLL to lock.\n      // During this time the CPU will switch to OSCCLK/2 until\n      // the PLL is stable.  Once the PLL is stable the CPU will\n      // switch to the new PLL value.\n      //\n      // This time-to-lock is monitored by a PLL lock counter.\n      //\n      // Code is not required to sit and wait for the PLL to lock.\n      // However, if the code does anything that is timing critical,\n      // and requires the correct clock be locked, then it is best to\n      // wait until this switching has completed.\n\n      // Wait for the PLL lock bit to be set.\n\n      // The watchdog should be disabled before this loop, or fed within\n      // the loop via ServiceDog().\n\n\t  // Uncomment to disable the watchdog\n      DisableDog();\n\n      while(SysCtrlRegs.PLLSTS.bit.PLLLOCKS != 1)\n      {\n\t      // Uncomment to service the watchdog\n          // ServiceDog();\n      }\n\n      EALLOW;\n      SysCtrlRegs.PLLSTS.bit.MCLKOFF = 0;\n      EDIS;\n    }\n\n    // If switching to 1/2\n\tif((divsel == 1)||(divsel == 2))\n\t{\n\t\tEALLOW;\n\t    SysCtrlRegs.PLLSTS.bit.DIVSEL = divsel;\n\t    EDIS;\n\t}\n\n\t// If switching to 1/1\n\t// * First go to 1/2 and let the power settle\n\t//   The time required will depend on the system, this is only an example\n\t// * Then switch to 1/1\n\tif(divsel == 3)\n\t{\n\t\tEALLOW;\n\t    SysCtrlRegs.PLLSTS.bit.DIVSEL = 2;\n\t    DELAY_US(50L);\n\t    SysCtrlRegs.PLLSTS.bit.DIVSEL = 3;\n\t    EDIS;\n    }\n}\n\n//--------------------------------------------------------------------------\n// Example: InitPeripheralClocks:\n//---------------------------------------------------------------------------\n// This function initializes the clocks to the peripheral modules.\n// First the high and low clock prescalers are set\n// Second the clocks are enabled to each peripheral.\n// To reduce power, leave clocks to unused peripherals disabled\n//\n// Note: If a peripherals clock is not enabled then you cannot\n// read or write to the registers for that peripheral\n\nvoid InitPeripheralClocks(void)\n{\n   EALLOW;\n\n// HISPCP/LOSPCP prescale register settings, normally it will be set to default values\n   SysCtrlRegs.HISPCP.all = 0x0001;\n   SysCtrlRegs.LOSPCP.all = 0x0002;\n\n// XCLKOUT to SYSCLKOUT ratio.  By default XCLKOUT = 1/4 SYSCLKOUT\n   // XTIMCLK = SYSCLKOUT/2\n   XintfRegs.XINTCNF2.bit.XTIMCLK = 1;\n   // XCLKOUT = XTIMCLK/2\n   XintfRegs.XINTCNF2.bit.CLKMODE = 1;\n   // Enable XCLKOUT\n   XintfRegs.XINTCNF2.bit.CLKOFF = 0;\n\n// Peripheral clock enables set for the selected peripherals.\n// If you are not using a peripheral leave the clock off\n// to save on power.\n//\n// Note: not all peripherals are available on all 2833x derivates.\n// Refer to the datasheet for your particular device.\n//\n// This function is not written to be an example of efficient code.\n\n   SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 1;    // ADC\n\n   // *IMPORTANT*\n   // The ADC_cal function, which  copies the ADC calibration values from TI reserved\n   // OTP into the ADCREFSEL and ADCOFFTRIM registers, occurs automatically in the\n   // Boot ROM. If the boot ROM code is bypassed during the debug process, the\n   // following function MUST be called for the ADC to function according\n   // to specification. The clocks to the ADC MUST be enabled before calling this\n   // function.\n   // See the device data manual and/or the ADC Reference\n   // Manual for more information.\n\n   ADC_cal();\n\n\n   SysCtrlRegs.PCLKCR0.bit.I2CAENCLK = 1;   // I2C\n   SysCtrlRegs.PCLKCR0.bit.SCIAENCLK = 1;   // SCI-A\n   SysCtrlRegs.PCLKCR0.bit.SCIBENCLK = 1;   // SCI-B\n   SysCtrlRegs.PCLKCR0.bit.SCICENCLK = 1;   // SCI-C\n   SysCtrlRegs.PCLKCR0.bit.SPIAENCLK = 1;   // SPI-A\n   SysCtrlRegs.PCLKCR0.bit.MCBSPAENCLK = 1; // McBSP-A\n   SysCtrlRegs.PCLKCR0.bit.MCBSPBENCLK = 1; // McBSP-B\n   SysCtrlRegs.PCLKCR0.bit.ECANAENCLK=1;    // eCAN-A\n   SysCtrlRegs.PCLKCR0.bit.ECANBENCLK=1;    // eCAN-B\n\n   SysCtrlRegs.PCLKCR1.bit.EPWM1ENCLK = 1;  // ePWM1\n   SysCtrlRegs.PCLKCR1.bit.EPWM2ENCLK = 1;  // ePWM2\n   SysCtrlRegs.PCLKCR1.bit.EPWM3ENCLK = 1;  // ePWM3\n   SysCtrlRegs.PCLKCR1.bit.EPWM4ENCLK = 1;  // ePWM4\n   SysCtrlRegs.PCLKCR1.bit.EPWM5ENCLK = 1;  // ePWM5\n   SysCtrlRegs.PCLKCR1.bit.EPWM6ENCLK = 1;  // ePWM6\n   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0;   // Disable TBCLK within the ePWM\n\n   SysCtrlRegs.PCLKCR1.bit.ECAP3ENCLK = 1;  // eCAP3\n   SysCtrlRegs.PCLKCR1.bit.ECAP4ENCLK = 1;  // eCAP4\n   SysCtrlRegs.PCLKCR1.bit.ECAP5ENCLK = 1;  // eCAP5\n   SysCtrlRegs.PCLKCR1.bit.ECAP6ENCLK = 1;  // eCAP6\n   SysCtrlRegs.PCLKCR1.bit.ECAP1ENCLK = 1;  // eCAP1\n   SysCtrlRegs.PCLKCR1.bit.ECAP2ENCLK = 1;  // eCAP2\n   SysCtrlRegs.PCLKCR1.bit.EQEP1ENCLK = 1;  // eQEP1\n   SysCtrlRegs.PCLKCR1.bit.EQEP2ENCLK = 1;  // eQEP2\n\n   SysCtrlRegs.PCLKCR3.bit.CPUTIMER0ENCLK = 1; // CPU Timer 0\n   SysCtrlRegs.PCLKCR3.bit.CPUTIMER1ENCLK = 1; // CPU Timer 1\n   SysCtrlRegs.PCLKCR3.bit.CPUTIMER2ENCLK = 1; // CPU Timer 2\n\n   SysCtrlRegs.PCLKCR3.bit.DMAENCLK = 1;       // DMA Clock\n   SysCtrlRegs.PCLKCR3.bit.XINTFENCLK = 1;     // XTIMCLK\n   SysCtrlRegs.PCLKCR3.bit.GPIOINENCLK = 1;    // GPIO input clock\n\n   EDIS;\n}\n\n//---------------------------------------------------------------------------\n// Example: CsmUnlock:\n//---------------------------------------------------------------------------\n// This function unlocks the CSM. User must replace 0xFFFF's with current\n// password for the DSP. Returns 1 if unlock is successful.\n\n#define STATUS_FAIL          0\n#define STATUS_SUCCESS       1\n\nUint16 CsmUnlock()\n{\n    volatile Uint16 temp;\n\n    // Load the key registers with the current password. The 0xFFFF's are dummy\n\t// passwords.  User should replace them with the correct password for the DSP.\n\n    EALLOW;\n    CsmRegs.KEY0 = 0xFFFF;\n    CsmRegs.KEY1 = 0xFFFF;\n    CsmRegs.KEY2 = 0xFFFF;\n    CsmRegs.KEY3 = 0xFFFF;\n    CsmRegs.KEY4 = 0xFFFF;\n    CsmRegs.KEY5 = 0xFFFF;\n    CsmRegs.KEY6 = 0xFFFF;\n    CsmRegs.KEY7 = 0xFFFF;\n    EDIS;\n\n    // Perform a dummy read of the password locations\n    // if they match the key values, the CSM will unlock\n\n    temp = CsmPwl.PSWD0;\n    temp = CsmPwl.PSWD1;\n    temp = CsmPwl.PSWD2;\n    temp = CsmPwl.PSWD3;\n    temp = CsmPwl.PSWD4;\n    temp = CsmPwl.PSWD5;\n    temp = CsmPwl.PSWD6;\n    temp = CsmPwl.PSWD7;\n\n    // If the CSM unlocked, return succes, otherwise return\n    // failure.\n    if (CsmRegs.CSMSCR.bit.SECURE == 0) return STATUS_SUCCESS;\n    else return STATUS_FAIL;\n\n}\n\n\n//===========================================================================\n// End of file.\n//===========================================================================\n"},{"name":"DSP2833x_usDelay.asm","type":"other","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":";// TI File Revision: /main/4 \n;// Checkin Date: July 30, 2007   10:28:57 \n;//###########################################################################\n;//\n;// FILE:  DSP2833x_usDelay.asm\n;//\n;// TITLE: Simple delay function\n;//\n;// DESCRIPTION:\n;//  \n;// This is a simple delay function that can be used to insert a specified\n;// delay into code.  \n;// \n;// This function is only accurate if executed from internal zero-waitstate\n;// SARAM. If it is executed from waitstate memory then the delay will be\n;// longer then specified. \n;// \n;// To use this function:\n;//\n;//  1 - update the CPU clock speed in the DSP2833x_Examples.h\n;//    file. For example:\n;//    #define CPU_RATE 6.667L // for a 150MHz CPU clock speed\n;//    or #define CPU_RATE 10.000L // for a 100MHz CPU clock speed \n;//\n;//  2 - Call this function by using the DELAY_US(A) macro\n;//    that is defined in the DSP2833x_Examples.h file.  This macro\n;//    will convert the number of microseconds specified\n;//    into a loop count for use with this function.  \n;//    This count will be based on the CPU frequency you specify.\n;//\n;//  3 - For the most accurate delay \n;//    - Execute this function in 0 waitstate RAM.  \n;//    - Disable interrupts before calling the function\n;//      If you do not disable interrupts, then think of\n;//      this as an \"at least\" delay function as the actual\n;//      delay may be longer. \n;//\n;//  The C assembly call from the DELAY_US(time) macro will\n;//  look as follows: \n;//\n;//  extern void Delay(long LoopCount);                \n;//\n;//        MOV   AL,#LowLoopCount\n;//        MOV   AH,#HighLoopCount\n;//        LCR   _Delay\n;//\n;//  Or as follows (if count is less then 16-bits):\n;//\n;//        MOV   ACC,#LoopCount\n;//        LCR   _Delay\n;//\n;//\n;//###########################################################################\n;// $TI Release: DSP2833x Header Files V1.10 $\n;// $Release Date: February 15, 2008 $\n;//###########################################################################\t\n\n       .def _DSP28x_usDelay\n       .sect \"ramfuncs\"\n\n        .global  __DSP28x_usDelay\n_DSP28x_usDelay:\n        SUB    ACC,#1\n        BF     _DSP28x_usDelay,GEQ    ;; Loop if ACC >= 0\n        LRETR \n\n;There is a 9/10 cycle overhead and each loop\n;takes five cycles. The LoopCount is given by\n;the following formula:\n;  DELAY_CPU_CYCLES = 9 + 5*LoopCount\n; LoopCount = (DELAY_CPU_CYCLES - 9) / 5\n; The macro DELAY_US(A) performs this calculation for you\n;\n;//===========================================================================\n;// End of file.\n;//===========================================================================\n"},{"name":"MW_c28xGPIO.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\shared\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGPIO.c\n * TITLE: GPIO functions to access the GPIO specific registers for C2000 target\n * Copyright 2017-2020 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n\n#include \"MW_c28xGPIO.h\"\n#ifdef CPU2\n#ifdef MW_F2837XD\n#include \"F2837xD_Ipc_drivers.h\"\n#define CPU01_TO_CPU02_PASSMSG  0x0003FFF4\n#endif //MW_F2837XD\n#ifdef MW_F2838X\n#include \"MW_f2838x_includes.h\"\n#endif //MW_F2838X\n#endif //CPU2\n\n/* ***************************************************************************/\n/* the defines */\n\n/* ***************************************************************************/\n/* the globals */\n\nUint16 GPIO_oneTimeInit = 0;\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* One time initialization of all GPIOs */\nvoid OneTimeGpioInit()\n{    \n    if(GPIO_oneTimeInit == 0)\n    {\n#ifdef CPU1\n        InitGpio();\n#endif //End of CPU1\n        GPIO_oneTimeInit = 1;\n    }\n}\n\n#ifndef MW_F281X /*GPIO implementation not supported for C281x */\n#ifndef F2837X_REG_FORMAT /*GPIO functions are provided by TI*/\n#ifndef MW_F2804X /*GPIO initialization is provided by TI for F2804x*/\n\n/*Sets all pins to be muxed to GPIO in input mode with pull-ups enabled.\n * Also sets the qualification to synchronous.*/\nvoid InitGpio()\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n    EALLOW;\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n            gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    \n    /* For concerto additional registers needs to be initialized*/\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioG1CtrlRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioG1CtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n            gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioG1DataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioG1DataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    #endif //End of MW_PIL_TIC2000_CONCERTO\n    EDIS;\n}\n#endif // End of MW_F2804X\n\n/*Set the peripheral muxing for the specified pin.\n * The appropriate parameters can be found in the GPIO Muxed Pins table.\n * Use the GPIO index row (0 to 4) to select a muxing option for the GPIO.*/\nvoid GPIO_SetupPinMux(Uint16 pin, Uint16 cpu, Uint16 peripheral)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux;\n    Uint16 pin32, pin16;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Sanity check for valid peripheral values*/\n    if (peripheral > 0x4)\n        return;\n    \n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    \n    //Now for the actual function\n    EALLOW;\n    \n    /* Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some tricky\n     * bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *mux |= (Uint32)(peripheral & 0x3UL) << (2*pin16);\n    \n    //WARNING: This code does not touch the analog mode select registers,\n    //which are needed to give the USB module control of its IOs.\n    EDIS;\n}\n\n/*Setup up the GPIO input/output options for the specified pin.\n * The flags are a 16-bit mask produced by ORing together options.\n * For input pins, the valid flags are:\n * GPIO_PULLUP    Enable pull-up\n * GPIO_SYNC        Synchronize the input latch to PLLSYSCLK (default -- you don't need to specify this)\n * GPIO_QUAL3    Use 3-sample qualification\n * GPIO_QUAL6    Use 6-sample qualification\n * GPIO_ASYNC    Do not use synchronization or qualification\n * (Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n * For output pins, the valid flags are:\n * GPIO_PULLUP        If open drain enabled, also enable the pull-up\n * and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n * With no flags, the default input state is synchronous with no pull-up or polarity inversion.\n * The default output state is the standard digital output.*/\nvoid GPIO_SetupPinOptions(Uint16 pin, Uint16 output, Uint16 flags)\n{\n    {\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    pinMask = 1UL << pin32;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-2. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n    \n    EALLOW;\n    \n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1)\n    {\n        /*Output, with optional open drain mode and pull-up*/\n        *dir |= pinMask;\n        \n        /*Enable pull-up if necessary. Open drain mode must be active.*/\n        if (flags & GPIO_PULLUP)\n            *pud &= ~pinMask;\n        else\n            *pud |= pinMask;\n    } else\n    {\n        /*Input, with optional pull-up, qualification, and polarity inversion*/\n        *dir &= ~pinMask;\n        \n        /*Enable pull-up if necessary*/\n        if (flags & GPIO_PULLUP)\n            *pud &= ~pinMask;\n        else\n            *pud |= pinMask;\n    }\n    \n    /*Extract the qualification parameter and load it into the register. This is\n     * also needed for open drain outputs, so we might as well do it all the time.*/\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0)\n        *qsel |= qual << (2 * pin16);\n    \n    EDIS;\n    }\n}\n\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0)\n        gpioDataReg[GPYCLEAR] = pinMask;\n    else\n        gpioDataReg[GPYSET] = pinMask;\n}\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    \n    gpioDataReg[GPYTOGGLE] = pinMask;\n\n}\n\n#else // for F2837X_REG_FORMAT\n#if defined(MW_F2838X) \n#if defined(CPU1)\n\nvoid InitGpio()\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n\n    /*Disable pin locks*/\n    EALLOW;\n    GpioCtrlRegs.GPALOCK.all = 0x00000000;\n    GpioCtrlRegs.GPBLOCK.all = 0x00000000;\n    GpioCtrlRegs.GPCLOCK.all = 0x00000000;\n    GpioCtrlRegs.GPDLOCK.all = 0x00000000;\n    GpioCtrlRegs.GPELOCK.all = 0x00000000;\n    GpioCtrlRegs.GPFLOCK.all = 0x00000000;\n\n    /* Fill all registers with zeros. Writing to each register separately\n     * for six GPIO modules would make this function *very* long.\n     * Fortunately, we'd be writing them all with zeros anyway, so this\n     * saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /* Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x40/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000;\n        }\n    }\n\n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000;\n    }\n\n    EDIS;\n}\n\nvoid GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux, *gmux, *csel;\n    Uint16 pin32, pin16, pin8;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pin8 = gpioNumber % 8;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /*Sanity check for valid cpu and peripheral values*/\n    if (cpu > GPIO_MUX_CM || muxPosition > 0xF)\n        return;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n    csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n    /* Now for the actual function */\n    EALLOW;\n\n    /* To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n     * glitches, then change the group mux, then set the peripheral mux to\n     * its target value. Finally, set the CPU select. This procedure is\n     * described in the TRM. Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some\n     * tricky bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *gmux &= ~(0x3UL << (2*pin16));\n    *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n    *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n\n    *csel &= ~(0x7L << (4*pin8));\n    *csel |= (Uint32)(cpu & 0x7L) << (4*pin8);\n\n    /* WARNING: This code does not touch the analog mode select registers,\n     * which are needed to give the USB module control of its IOs.*/\n    EDIS;\n}\n\nvoid GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pinMask = 1UL << pin32;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    inv = gpioBaseAddr + GPYINV;\n    odr = gpioBaseAddr + GPYODR;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n    EALLOW;\n\n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1)\n    {        \n        /* Output, with optional open drain mode and pull-up */        \n        *dir |= pinMask;\n\n        /* Enable open drain if necessary */\n        if (flags & GPIO_OPENDRAIN)\n        {\n            *odr |= pinMask;\n        }\n        else\n        {\n            *odr &= ~pinMask;\n        }\n\n        /* Enable pull-up if necessary. Open drain mode must be active. */\n        if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n    }\n    else\n    {\n        /* Input, with optional pull-up, qualification, and polarity\n         * inversion */\n        *dir &= ~pinMask;\n\n        /* Enable pull-up if necessary */\n        if (flags & GPIO_PULLUP)\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n\n        /* Invert polarity if necessary */\n        if (flags & GPIO_INVERT)\n        {\n            *inv |= pinMask;\n        }\n        else\n        {\n            *inv &= ~pinMask;\n        }\n    }\n\n    /* Extract the qualification parameter and load it into the register.\n     * This is also needed for open drain outputs, so we might as well do it\n     * all the time. */\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0)\n    {\n        *qsel |= qual << (2 * pin16);\n    }\n\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor176Pin()\n{\n\tEALLOW;\n\tGpioCtrlRegs.GPCPUD.all = ~0x80000000;  /* GPIO 95 */\n\tGpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  /* GPIOs 96-127 */\n\tGpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDF;  /* GPIOs 128-159 except for 133 */\n\tGpioCtrlRegs.GPFPUD.all = ~0x000001FF;  /* GPIOs 160-168 */\n\tEDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor100Pin()\n{\n    EALLOW;\n    GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3;  //GPIOs 0-1, 5-9, 22-31\n    GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FF;  //GPIOs 32-40, 44-57\n    GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18;  //GPIOs 67-68, 74-77, 79-83, 93-95\n    GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  //GPIOs 96-127\n    GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFF;  //GPIOs 128-159\n    GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  //GPIOs 160-168\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullups()\n{\n\t/* bits 8-10 have pin count */\n    unsigned char pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700) >> 8) ;\n\n\t/* 5 = 100 pin\n\t * 6 = 176 pin\n\t * 7 = 337 pin */\n    if(pin_count == 5)\n    {\n        GPIO_EnableUnbondedIOPullupsFor100Pin();\n    }\n    else if (pin_count == 6)\n\t{\n\t\tGPIO_EnableUnbondedIOPullupsFor176Pin();\n\t}\n\telse\n\t{\n\t\t/* do nothing - this is 337 pin package */\n\t}\n}\n#endif // defined(CPU1)\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n#endif // end of defined(MW_F2838X)\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (pin % 32);\n    gpioDataReg[GPYTOGGLE] = pinMask;\n}\n#endif // end of F2837X_REG_FORMAT\n\n/*Set the GPIO pin. Set the mux values and pin options for the specified pin.\n  This function can be used for all processors except C281x. The implementation is dependant on CPU1 and CPU2*/ \nvoid Set_GPIOPin(Uint16 pin, Uint16 cpu, Uint16 peripheral, Uint16 output, Uint16 flags)\n{\n#if defined(F2837X_REG_FORMAT) && defined(CPU2)\n    Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n    Uint32 gpioData = 0x00000000;\n    //Sanity check for valid cpu and peripheral values\n    if (cpu > GPIO_MUX_CPU2CLA || peripheral > 0xF)\n        return;\n    gpioData = gpioData | pin;\n    gpioData = gpioData | ((Uint32)peripheral << 8);\n    gpioData = gpioData | ((Uint32)output << 16);\n    gpioData = gpioData | ((Uint32)flags << 24);\n    #ifdef MW_F2837XD\n    Uint32 ulRWord32 = 0;\n    IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[0], gpioData, IPC_FLAG31);\n    while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n            IPC_FLAG31) != STATUS_PASS)\n    {\n    }\n    #else\n     MW_IPC_sendCommand(IPC_CPU2_L_CPU1_R, (IPC_FLAG0 | IPC_FLAG31), IPC_ADDR_CORRECTION_DISABLE, IPC_FUNC_CALL, pulMsgRam[0], gpioData);\n    IPC_waitForAck(IPC_CPU2_L_CPU1_R, IPC_FLAG31);\n    IPC_getResponse(IPC_CPU2_L_CPU1_R);\n    #endif //MW_F2837XD\n#else\n    GPIO_SetupPinMux(pin, cpu, peripheral);\n    GPIO_SetupPinOptions(pin, output, flags);\n#endif // end of defined(F2837X_REG_FORMAT) && defined(CPU2)\n}\n#endif //end of MW_F281X\n    \n"},{"name":"MW_c28xGlobalInterrupts.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\shared\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGlobalInterrupts.c\n * TITLE: Common board support functions specific for C2000 targets\n * Copyright 2020 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n#include \"MW_target_hardware_resources.h\"\n\n/* ***************************************************************************/\n/* the globals */\nUint16 MW_InterruptDisableLock;\n\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* Global interrupt enable function */\nvoid globalInterruptEnable(void)\n{\n    if (0 == MW_InterruptDisableLock)\n    {\n        /* Enabled the interrupts only if it was enabled before */\n        __enable_interrupts(); /* Enable Global Interrupt INTM and realtime interrupt DBGM */\n    }\n}\n\n/* Global interrupt disable function */\nvoid globalInterruptDisable(void)\n{\n    /* Disable Global Interrupt INTM using __disable_interrupts()\n     The function will return 0 if interrupt was enabled previously\n     otherwise it will return 1 if the interrupt was previously disabled*/\n    MW_InterruptDisableLock = __disable_interrupts();\n    MW_InterruptDisableLock &= 0x1;   \n}\n"},{"name":"MW_c28xx_board.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"DSP2833x_Device.h\"\r\n#include \"DSP2833x_Examples.h\"\r\n#include \"DSP2833x_GlobalPrototypes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"DCDC_Buck.h\"\r\n#include \"DCDC_Buck_private.h\"\r\n\r\nvoid InitXintf16Gpio();\r\nvoid init_board ()\r\n{\r\n  DisableDog();\r\n\r\n  /* Initialize the PLL control: PLLCR and DIVSEL\r\n   * DSP28_PLLCR and DSP28_DIVSEL are defined in DSP2833x_Examples.h\r\n   */\r\n  InitPll(10,2);\r\n  InitPeripheralClocks();\r\n  EALLOW;\r\n\r\n  /* Configure low speed peripheral clocks */\r\n  SysCtrlRegs.LOSPCP.all = 0U;\r\n\r\n  /* Configure high speed peripheral clocks */\r\n  SysCtrlRegs.HISPCP.all = 1U;\r\n  EDIS;\r\n  EALLOW;\r\n\r\n  /* Perform additional configuration of the XTINF for speed up */\r\n  XintfRegs.XINTCNF2.bit.XTIMCLK = 0;  /* XTIMCLK=SYSCLKOUT/1*/\r\n  XintfRegs.XINTCNF2.bit.CLKOFF = 0;   /* XCLKOUT is enabled*/\r\n  XintfRegs.XINTCNF2.bit.CLKMODE = 0;  /* XCLKOUT = XTIMCLK*/\r\n\r\n  /* Make sure write buffer is empty before configuring buffering depth*/\r\n  while (XintfRegs.XINTCNF2.bit.WLEVEL != 0) ;/* poll the WLEVEL bit*/\r\n  XintfRegs.XINTCNF2.bit.WRBUFF = 0;   /* No write buffering*/\r\n\r\n  /* Example: Assume Zone 7 is slow, so add additional BCYC cycles whenever\r\n   * switching from Zone 7 to another Zone.  This will help avoid bus contention.\r\n   */\r\n  XintfRegs.XBANK.bit.BCYC = 3;        /* Add 7 cycles*/\r\n  XintfRegs.XBANK.bit.BANK = 3;        /* select zone 7*/\r\n\r\n  /* Zone 0 Configuration */\r\n  /*\r\n     XintfRegs.XTIMING0.bit.X2TIMING = 0;       // Timing scale factor = 1\r\n     XintfRegs.XTIMING0.bit.XSIZE = 3;          // Always write as 11b\r\n     XintfRegs.XTIMING0.bit.READYMODE = 1;      // XREADY is asynchronous\r\n     XintfRegs.XTIMING0.bit.USEREADY = 0;       // Disable XREADY\r\n     XintfRegs.XTIMING0.bit.XRDLEAD = 1;        // Read lead time\r\n     XintfRegs.XTIMING0.bit.XRDACTIVE = 2;      // Read active time\r\n     XintfRegs.XTIMING0.bit.XRDTRAIL = 1;       // Read trail time\r\n     XintfRegs.XTIMING0.bit.XWRLEAD = 1;        // Write lead time\r\n     XintfRegs.XTIMING0.bit.XWRACTIVE = 2;      // Write active time\r\n     XintfRegs.XTIMING0.bit.XWRTRAIL = 1;       // Write trail time\r\n   */\r\n  XintfRegs.XTIMING0.all = (XintfRegs.XTIMING0.all & ~0x43FFFF) | 0x394A9;\r\n\r\n  /* Zone 6 Configuration */\r\n  /*\r\n     XintfRegs.XTIMING6.bit.X2TIMING = 0;       // Timing scale factor = 1\r\n     XintfRegs.XTIMING6.bit.XSIZE = 3;          // Always write as 11b\r\n     XintfRegs.XTIMING6.bit.READYMODE = 1;      // XREADY is asynchronous\r\n     XintfRegs.XTIMING6.bit.USEREADY = 0;       // Disable XREADY\r\n     XintfRegs.XTIMING6.bit.XRDLEAD = 1;        // Read lead time\r\n     XintfRegs.XTIMING6.bit.XRDACTIVE = 2;      // Read active time\r\n     XintfRegs.XTIMING6.bit.XRDTRAIL = 1;       // Read trail time\r\n     XintfRegs.XTIMING6.bit.XWRLEAD = 1;        // Write lead time\r\n     XintfRegs.XTIMING6.bit.XWRACTIVE = 2;      // Write active time\r\n     XintfRegs.XTIMING6.bit.XWRTRAIL = 1;       // Write trail time\r\n   */\r\n  XintfRegs.XTIMING6.all = (XintfRegs.XTIMING6.all & ~0x43FFFF) | 0x394A9;\r\n\r\n  /* Zone 7 Configuration */\r\n  /*\r\n     XintfRegs.XTIMING7.bit.X2TIMING = 0;       // Timing scale factor = 1\r\n     XintfRegs.XTIMING7.bit.XSIZE = 3;          // Always write as 11b\r\n     XintfRegs.XTIMING7.bit.READYMODE = 1;      // XREADY is asynchronous\r\n     XintfRegs.XTIMING7.bit.USEREADY = 0;       // Disable XREADY\r\n     XintfRegs.XTIMING7.bit.XRDLEAD = 1;        // Read lead time\r\n     XintfRegs.XTIMING7.bit.XRDACTIVE = 2;      // Read active time\r\n     XintfRegs.XTIMING7.bit.XRDTRAIL = 1;       // Read trail time\r\n     XintfRegs.XTIMING7.bit.XWRLEAD = 1;        // Write lead time\r\n     XintfRegs.XTIMING7.bit.XWRACTIVE = 2;      // Write active time\r\n     XintfRegs.XTIMING7.bit.XWRTRAIL = 1;       // Write trail time\r\n   */\r\n  XintfRegs.XTIMING7.all = (XintfRegs.XTIMING7.all & ~0x43FFFF) | 0x394A9;\r\n  EDIS;\r\n  InitXintf16Gpio();\r\n\r\n  /* Flush pipeline to ensure that the write is complete. Wait to be sure. */\r\n  asm(\" RPT #6 || NOP\");\r\n\r\n  /* Disable and clear all CPU interrupts */\r\n  DINT;\r\n  IER = 0x0000;\r\n  IFR = 0x0000;\r\n  InitPieCtrl();\r\n  InitPieVectTable();\r\n  InitCpuTimers();\r\n\r\n  /* initial GPIO qualification settings.... */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPAQSEL1.all = 0x0;\r\n  GpioCtrlRegs.GPAQSEL2.all = 0x0;\r\n  GpioCtrlRegs.GPBQSEL1.all = 0x0;\r\n  GpioCtrlRegs.GPBQSEL2.all = 0x0;\r\n  EDIS;\r\n}\r\n\r\nvoid InitXintf16Gpio()\r\n{\r\n  EALLOW;\r\n\r\n  /*\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO64 = 3;  // XD15\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO65 = 3;  // XD14\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO66 = 3;  // XD13\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO67 = 3;  // XD12\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO68 = 3;  // XD11\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO69 = 3;  // XD10\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO70 = 3;  // XD19\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO71 = 3;  // XD8\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO72 = 3;  // XD7\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO73 = 3;  // XD6\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO74 = 3;  // XD5\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO75 = 3;  // XD4\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO76 = 3;  // XD3\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO77 = 3;  // XD2\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO78 = 3;  // XD1\r\n     GpioCtrlRegs.GPCMUX1.bit.GPIO79 = 3;  // XD0\r\n\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO40 = 3;  // XA0/XWE1n\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO41 = 3;  // XA1\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO42 = 3;  // XA2\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO43 = 3;  // XA3\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO44 = 3;  // XA4\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO45 = 3;  // XA5\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO46 = 3;  // XA6\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO47 = 3;  // XA7\r\n\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO80 = 3;  // XA8\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO81 = 3;  // XA9\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO82 = 3;  // XA10\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO83 = 3;  // XA11\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO84 = 3;  // XA12\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO85 = 3;  // XA13\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO86 = 3;  // XA14\r\n     GpioCtrlRegs.GPCMUX2.bit.GPIO87 = 3;  // XA15\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO39 = 3;  // XA16\r\n     GpioCtrlRegs.GPAMUX2.bit.GPIO31 = 3;  // XA17\r\n     GpioCtrlRegs.GPAMUX2.bit.GPIO30 = 3;  // XA18\r\n     GpioCtrlRegs.GPAMUX2.bit.GPIO29 = 3;  // XA19\r\n\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO34 = 3;  // XREADY\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO35 = 3;  // XRNW\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO38 = 3;  // XWE0\r\n\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO36 = 3;  // XZCS0\r\n     GpioCtrlRegs.GPBMUX1.bit.GPIO37 = 3;  // XZCS7\r\n     GpioCtrlRegs.GPAMUX2.bit.GPIO28 = 3;  // XZCS6\r\n   */\r\n  GpioCtrlRegs.GPCMUX1.all = (GpioCtrlRegs.GPCMUX1.all & ~0xFFFFFFFF) |\r\n    0xFFFFFFFF;\r\n  GpioCtrlRegs.GPBMUX1.all = (GpioCtrlRegs.GPBMUX1.all & ~0xFFFFFFF0) |\r\n    0xFFFFFFF0;\r\n  GpioCtrlRegs.GPCMUX2.all = (GpioCtrlRegs.GPCMUX2.all & ~0xFFFF) | 0xFFFF;\r\n  GpioCtrlRegs.GPAMUX2.all = (GpioCtrlRegs.GPAMUX2.all & ~0xFF000000) |\r\n    0xFF000000;\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_csl.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"DSP2833x_Device.h\"\r\n#include \"DSP2833x_Examples.h\"\r\n#include \"DSP2833x_GlobalPrototypes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"DCDC_Buck.h\"\r\n#include \"DCDC_Buck_private.h\"\r\n\r\nvoid enableExtInterrupt (void);\r\nvoid disableWatchdog(void)\r\n{\r\n  int *WatchdogWDCR = (void *) 0x7029;\r\n  asm(\" EALLOW \");\r\n  *WatchdogWDCR = 0x0068;\r\n  asm(\" EDIS \");\r\n}\r\n"},{"name":"MW_c28xx_pie.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"#define PIEMASK0                       64\r\n#define IFRMASK                        1\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"c2000BoardSupport.h\"\n#include \"DSP2833x_Device.h\"\n#include \"DSP2833x_Examples.h\"\n#include \"DSP2833x_GlobalPrototypes.h\"\n#include \"DSP2833x_CpuTimers.h\"\n#include \"c2000SchedulerTimer.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE TI Delfino F2833x\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERNUM 3\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.registry.getExtModeHostBaud(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.registry.serialPortValueCallback(hCS, 'ExtModeCOMPort');\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_CONNECTIONINFO_XCPONCAN_CANVENDOR \n#define MW_CONNECTIONINFO_XCPONCAN_CANDEVICE \n#define MW_CONNECTIONINFO_XCPONCAN_CANCHANNEL \n#define MW_CONNECTIONINFO_XCPONCAN_BUSSPEED codertarget.registry.getExtModeCANBusSpeed(hCS)\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDCOMMAND 2\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDRESPONSE 3\n#define MW_CONNECTIONINFO_XCPONCAN_ISCANIDEXTENDED 0\n#define MW_CONNECTIONINFO_XCPONCAN_VERBOSE 1\n#define MW_CONNECTIONINFO_SERIAL_IPADDRESS codertarget.registry.getLoopbackIP;\n#define MW_CONNECTIONINFO_SERIAL_PORT 17725\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_CAN_MEXARGS  \n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_CANMODULE 0\n#define MW_EXTMODE_CANRXMAILBOXNUMBER 0\n#define MW_EXTMODE_CANTXMAILBOXNUMBER 1\n#define MW_EXTMODE_SCIMODULE 0\n#define MW_EXTMODE_RUNNING on\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_DEVICEID 0\n#define MW_RUNTIME_FLASHLOAD 0\n#define MW_RUNTIME_LOADCOMMANDARG $(TARGET_ROOT)/CCS_Config/f28335.ccxml\n#define MW_RUNTIME_DMAACCESS 0\n#define MW_RUNTIME_ENABLEFASTRTS 1\n#define MW_TARGETLINKOBJ_USECUSTOMLINKER 0\n#define MW_TARGETLINKOBJ_NAME $(TARGET_ROOT)/src/c28335.cmd\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 150\n#define MW_CLOCKING_OSCCLK 30\n#define MW_CLOCKING_AUTOSETPLLSETTINGS 1\n#define MW_CLOCKING_PLLCR 0\n#define MW_CLOCKING_DIVSEL 1\n#define MW_CLOCKING_CLOSESTCPUCLOCK 150\n#define MW_CLOCKING_LSPCLKDIV 0\n#define MW_CLOCKING_LSPCLK 150\n#define MW_CLOCKING_HSPCLKDIV 1\n#define MW_CLOCKING_HSPCLK 75\n#define MW_ADC_ADCLKPS 3\n#define MW_ADC_CPS 1\n#define MW_ADC_ADCCLK 6.250000\n#define MW_ADC_ACQ_PS 4\n#define MW_ADC_ACQUISITIONWINDOW 0.800000\n#define MW_ADC_OFFSETCORRECTIONVALUE AdcRegs.ADCOFFTRIM.bit.OFFSET_TRIM\n#define MW_ADC_EXTERNALREFERENCESELECTOR 0\n#define MW_ADC_CONTINUOUS 0\n#define MW_ECAN_A_MODULECLOCKFREQUENCY 75\n#define MW_ECAN_A_BAUDRATEPRESCALER 5.000000\n#define MW_ECAN_A_TSEG1 6\n#define MW_ECAN_A_TSEG2 4\n#define MW_ECAN_A_BAUDRATE 1000000\n#define MW_ECAN_A_SBG 0\n#define MW_ECAN_A_SJW 1\n#define MW_ECAN_A_SAM 0\n#define MW_ECAN_A_ENHANCEDCANMODE 1\n#define MW_ECAN_A_SELFTESTMODE 0\n#define MW_ECAN_A_PINASSIGNMENT_TX 2\n#define MW_ECAN_A_PINASSIGNMENT_RX 2\n#define MW_ECAN_B_MODULECLOCKFREQUENCY 75\n#define MW_ECAN_B_BAUDRATEPRESCALER 5.000000\n#define MW_ECAN_B_TSEG1 6\n#define MW_ECAN_B_TSEG2 4\n#define MW_ECAN_B_BAUDRATE 1000000\n#define MW_ECAN_B_SBG 0\n#define MW_ECAN_B_SJW 1\n#define MW_ECAN_B_SAM 0\n#define MW_ECAN_B_ENHANCEDCANMODE 1\n#define MW_ECAN_B_SELFTESTMODE 0\n#define MW_ECAN_B_PINASSIGNMENT_TX 1\n#define MW_ECAN_B_PINASSIGNMENT_RX 1\n#define MW_ECAP_PINASSIGNMENT_ECAP1 1\n#define MW_ECAP_PINASSIGNMENT_ECAP2 1\n#define MW_ECAP_PINASSIGNMENT_ECAP3 1\n#define MW_ECAP_PINASSIGNMENT_ECAP4 1\n#define MW_ECAP_PINASSIGNMENT_ECAP5 1\n#define MW_ECAP_PINASSIGNMENT_ECAP6 1\n#define MW_EPWM_PINASSIGNMENT_SYNCI 0\n#define MW_EPWM_PINASSIGNMENT_SYNCO 0\n#define MW_I2C_MODE 0\n#define MW_I2C_ADDRDATAFORMAT 0\n#define MW_I2C_OWNADDRESS 1\n#define MW_I2C_BITCOUNT 0\n#define MW_I2C_MODULECLOCKPRESCALER 9\n#define MW_I2C_MODULECLOCKFREQUENCY 15000000.000000\n#define MW_I2C_MASTERCLKLOWTIME 5\n#define MW_I2C_MASTERCLKHIGHTIME 5\n#define MW_I2C_MASTERCLOCKFREQUENCY 750000.000000\n#define MW_I2C_MASTERCLOCKFREQUENCY_1 750000.000000\n#define MW_I2C_MASTERCLOCKFREQUENCY_2 750000.000000\n#define MW_I2C_PINASSIGNMENT_SDAA 0\n#define MW_I2C_PINASSIGNMENT_SCLA 0\n#define MW_I2C_PINVALUE_SDA 32\n#define MW_I2C_PINVALUE_SCL 33\n#define MW_I2C_PINMUX_SDA 1\n#define MW_I2C_PINMUX_SCL 1\n#define MW_I2C_ENABLELOOPBACK 0\n#define MW_I2C_ENABLETXINT 0\n#define MW_I2C_TXFIFOLEVEL 16\n#define MW_I2C_ENABLERXINT 0\n#define MW_I2C_RXFIFOLEVEL 16\n#define MW_I2C_ENABLESYSINT 0\n#define MW_I2C_AAS 0\n#define MW_I2C_SCD 0\n#define MW_I2C_ARDY 0\n#define MW_I2C_NACK 0\n#define MW_I2C_AL 0\n#define MW_SCI_A_ENABLELOOPBACK 0\n#define MW_SCI_A_SUSPENSIONMODE 2\n#define MW_SCI_A_NUMBEROFSTOPBITS 0\n#define MW_SCI_A_PARITYMODE 0\n#define MW_SCI_A_CHARACTERLENGTHBITS 0\n#define MW_SCI_A_USERBAUDRATE 115200\n#define MW_SCI_A_BAUDRATEPRESCALER 162.000000\n#define MW_SCI_A_BAUDRATE 115031.000000\n#define MW_SCI_A_COMMUNICATIONMODE 0\n#define MW_SCI_A_BLOCKINGMODE 0\n#define MW_SCI_A_DATABYTEORDER 0\n#define MW_SCI_A_DATASWAPWIDTH 0\n#define MW_SCI_A_PINASSIGNMENT_TX 1\n#define MW_SCI_A_PINASSIGNMENT_RX 1\n#define MW_SCI_B_ENABLELOOPBACK 0\n#define MW_SCI_B_SUSPENSIONMODE 2\n#define MW_SCI_B_NUMBEROFSTOPBITS 0\n#define MW_SCI_B_PARITYMODE 0\n#define MW_SCI_B_CHARACTERLENGTHBITS 0\n#define MW_SCI_B_USERBAUDRATE 115200\n#define MW_SCI_B_BAUDRATEPRESCALER 162.000000\n#define MW_SCI_B_BAUDRATE 115031.000000\n#define MW_SCI_B_COMMUNICATIONMODE 0\n#define MW_SCI_B_BLOCKINGMODE 0\n#define MW_SCI_B_DATABYTEORDER 0\n#define MW_SCI_B_DATASWAPWIDTH 0\n#define MW_SCI_B_PINASSIGNMENT_TX 1\n#define MW_SCI_B_PINASSIGNMENT_RX 1\n#define MW_SCI_C_ENABLELOOPBACK 0\n#define MW_SCI_C_SUSPENSIONMODE 2\n#define MW_SCI_C_NUMBEROFSTOPBITS 0\n#define MW_SCI_C_PARITYMODE 0\n#define MW_SCI_C_CHARACTERLENGTHBITS 0\n#define MW_SCI_C_USERBAUDRATE 115200\n#define MW_SCI_C_BAUDRATEPRESCALER 162.000000\n#define MW_SCI_C_BAUDRATE 115031.000000\n#define MW_SCI_C_COMMUNICATIONMODE 0\n#define MW_SCI_C_BLOCKINGMODE 0\n#define MW_SCI_C_DATABYTEORDER 0\n#define MW_SCI_C_DATASWAPWIDTH 0\n#define MW_SCI_C_PINASSIGNMENT_TX 0\n#define MW_SCI_C_PINASSIGNMENT_RX 0\n#define MW_SPI_A_MODE 0\n#define MW_SPI_A_USERBAUDRATE 1843200\n#define MW_SPI_A_BAUDRATEFACTOR 80.000000\n#define MW_SPI_A_BAUDRATE 1851852.000000\n#define MW_SPI_A_DATABITS 15\n#define MW_SPI_A_CLOCKPOLARITY 0\n#define MW_SPI_A_CLOCKPHASE 0\n#define MW_SPI_A_SUSPENSIONMODE 2\n#define MW_SPI_A_ENABLELOOPBACK 0\n#define MW_SPI_A_TXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_A_RXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_A_FIFOENABLE 1\n#define MW_SPI_A_FIFOTRANSMITDELAY 0\n#define MW_SPI_A_PINASSIGNMENT_SIMO 1\n#define MW_SPI_A_PINASSIGNMENT_SOMI 1\n#define MW_SPI_A_PINASSIGNMENT_CLK 1\n#define MW_SPI_A_PINASSIGNMENT_STE 1\n#define MW_SPI_A_PINVALUE_SIMO 16\n#define MW_SPI_A_PINVALUE_SOMI 17\n#define MW_SPI_A_PINVALUE_CLK 18\n#define MW_SPI_A_PINVALUE_STE 19\n#define MW_SPI_A_PINMUX_SIMO 1\n#define MW_SPI_A_PINMUX_SOMI 1\n#define MW_SPI_A_PINMUX_CLK 1\n#define MW_SPI_A_PINMUX_STE 1\n#define MW_SPI_A_FIFO_LEVEL 16.000000\n#define MW_EQEP_PINASSIGNMENT_EQEP1A 1\n#define MW_EQEP_PINASSIGNMENT_EQEP1B 1\n#define MW_EQEP_PINASSIGNMENT_EQEP1S 1\n#define MW_EQEP_PINASSIGNMENT_EQEP1I 1\n#define MW_WATCHDOG_ENABLE_WATCHDOG 0\n#define MW_WATCHDOG_WATCHDOGCLOCK 0\n#define MW_WATCHDOG_TIME_PERIOD 0.004369\n#define MW_WATCHDOG_WATCHDOGEVENT 0\n#define MW_GPIO0_7_GPIOQUALSEL0 0\n#define MW_GPIO0_7_GPIOQUALSEL1 0\n#define MW_GPIO0_7_GPIOQUALSEL2 0\n#define MW_GPIO0_7_GPIOQUALSEL3 0\n#define MW_GPIO0_7_GPIOQUALSEL4 0\n#define MW_GPIO0_7_GPIOQUALSEL5 0\n#define MW_GPIO0_7_GPIOQUALSEL6 0\n#define MW_GPIO0_7_GPIOQUALSEL7 0\n#define MW_GPIO0_7_QUALPRD 0\n#define MW_GPIO8_15_GPIOQUALSEL8 0\n#define MW_GPIO8_15_GPIOQUALSEL9 0\n#define MW_GPIO8_15_GPIOQUALSEL10 0\n#define MW_GPIO8_15_GPIOQUALSEL11 0\n#define MW_GPIO8_15_GPIOQUALSEL12 0\n#define MW_GPIO8_15_GPIOQUALSEL13 0\n#define MW_GPIO8_15_GPIOQUALSEL14 0\n#define MW_GPIO8_15_GPIOQUALSEL15 0\n#define MW_GPIO8_15_QUALPRD 0\n#define MW_GPIO16_23_GPIOQUALSEL16 0\n#define MW_GPIO16_23_GPIOQUALSEL17 0\n#define MW_GPIO16_23_GPIOQUALSEL18 0\n#define MW_GPIO16_23_GPIOQUALSEL19 0\n#define MW_GPIO16_23_GPIOQUALSEL20 0\n#define MW_GPIO16_23_GPIOQUALSEL21 0\n#define MW_GPIO16_23_GPIOQUALSEL22 0\n#define MW_GPIO16_23_GPIOQUALSEL23 0\n#define MW_GPIO16_23_QUALPRD 0\n#define MW_GPIO24_31_GPIOQUALSEL24 0\n#define MW_GPIO24_31_GPIOQUALSEL25 0\n#define MW_GPIO24_31_GPIOQUALSEL26 0\n#define MW_GPIO24_31_GPIOQUALSEL27 0\n#define MW_GPIO24_31_GPIOQUALSEL28 0\n#define MW_GPIO24_31_GPIOQUALSEL29 0\n#define MW_GPIO24_31_GPIOQUALSEL30 0\n#define MW_GPIO24_31_GPIOQUALSEL31 0\n#define MW_GPIO24_31_QUALPRD 0\n#define MW_GPIO32_39_GPIOQUALSEL32 0\n#define MW_GPIO32_39_GPIOQUALSEL33 0\n#define MW_GPIO32_39_GPIOQUALSEL34 0\n#define MW_GPIO32_39_GPIOQUALSEL35 0\n#define MW_GPIO32_39_GPIOQUALSEL36 0\n#define MW_GPIO32_39_GPIOQUALSEL37 0\n#define MW_GPIO32_39_GPIOQUALSEL38 0\n#define MW_GPIO32_39_GPIOQUALSEL39 0\n#define MW_GPIO32_39_QUALPRD 0\n#define MW_GPIO40_47_GPIOQUALSEL40 0\n#define MW_GPIO40_47_GPIOQUALSEL41 0\n#define MW_GPIO40_47_GPIOQUALSEL42 0\n#define MW_GPIO40_47_GPIOQUALSEL43 0\n#define MW_GPIO40_47_GPIOQUALSEL44 0\n#define MW_GPIO40_47_GPIOQUALSEL45 0\n#define MW_GPIO40_47_GPIOQUALSEL46 0\n#define MW_GPIO40_47_GPIOQUALSEL47 0\n#define MW_GPIO40_47_QUALPRD 0\n#define MW_GPIO48_55_GPIOQUALSEL48 0\n#define MW_GPIO48_55_GPIOQUALSEL49 0\n#define MW_GPIO48_55_GPIOQUALSEL50 0\n#define MW_GPIO48_55_GPIOQUALSEL51 0\n#define MW_GPIO48_55_GPIOQUALSEL52 0\n#define MW_GPIO48_55_GPIOQUALSEL53 0\n#define MW_GPIO48_55_GPIOQUALSEL54 0\n#define MW_GPIO48_55_GPIOQUALSEL55 0\n#define MW_GPIO48_55_QUALPRD 0\n#define MW_GPIO56_63_GPIOQUALSEL56 0\n#define MW_GPIO56_63_GPIOQUALSEL57 0\n#define MW_GPIO56_63_GPIOQUALSEL58 0\n#define MW_GPIO56_63_GPIOQUALSEL59 0\n#define MW_GPIO56_63_GPIOQUALSEL60 0\n#define MW_GPIO56_63_GPIOQUALSEL61 0\n#define MW_GPIO56_63_GPIOQUALSEL62 0\n#define MW_GPIO56_63_GPIOQUALSEL63 0\n#define MW_GPIO56_63_QUALPRD 0\n#define MW_DMA_CH1_ENABLEDMACHANNEL 0\n#define MW_DMA_CH1_DATASIZE 0\n#define MW_DMA_CH1_INTERRUPTSRC 0\n#define MW_DMA_CH1_EXTERNALPIN 0\n#define MW_DMA_CH1_BURSTSIZE 0\n#define MW_DMA_CH1_TRANSFERSIZE 1\n#define MW_DMA_CH1_SRCBEGINADD 0xC000\n#define MW_DMA_CH1_DSTBEGINADD 0xD000\n#define MW_DMA_CH1_SRCBURSTSTEP 0\n#define MW_DMA_CH1_DSTBURSTSTEP 0\n#define MW_DMA_CH1_SRCTRANSSTEP 0\n#define MW_DMA_CH1_DSTTRANSSTEP 0\n#define MW_DMA_CH1_WRAPSRCSIZE 65536\n#define MW_DMA_CH1_WRAPDSTSIZE 65536\n#define MW_DMA_CH1_SRCWRAPSTEP 0\n#define MW_DMA_CH1_DSTWRAPSTEP 0\n#define MW_DMA_CH1_SETCH1TOHIGH 0\n#define MW_DMA_CH1_ENABLEONESHOT 0\n#define MW_DMA_CH1_ENABLECONTINUOUS 1\n#define MW_DMA_CH1_SYNCENABLE 0\n#define MW_DMA_CH1_ENABLEDSTSYNC 0\n#define MW_DMA_CH1_GENINTERRUPT 0\n#define MW_DMA_CH1_ENABLEOVERFLOW 0\n#define MW_DMA_CH2_ENABLEDMACHANNEL 0\n#define MW_DMA_CH2_DATASIZE 0\n#define MW_DMA_CH2_INTERRUPTSRC 0\n#define MW_DMA_CH2_EXTERNALPIN 0\n#define MW_DMA_CH2_BURSTSIZE 0\n#define MW_DMA_CH2_TRANSFERSIZE 1\n#define MW_DMA_CH2_SRCBEGINADD 0xC000\n#define MW_DMA_CH2_DSTBEGINADD 0xD000\n#define MW_DMA_CH2_SRCBURSTSTEP 0\n#define MW_DMA_CH2_DSTBURSTSTEP 0\n#define MW_DMA_CH2_SRCTRANSSTEP 0\n#define MW_DMA_CH2_DSTTRANSSTEP 0\n#define MW_DMA_CH2_WRAPSRCSIZE 65536\n#define MW_DMA_CH2_WRAPDSTSIZE 65536\n#define MW_DMA_CH2_SRCWRAPSTEP 0\n#define MW_DMA_CH2_DSTWRAPSTEP 0\n#define MW_DMA_CH2_ENABLEONESHOT 0\n#define MW_DMA_CH2_ENABLECONTINUOUS 1\n#define MW_DMA_CH2_SYNCENABLE 0\n#define MW_DMA_CH2_ENABLEDSTSYNC 0\n#define MW_DMA_CH2_GENINTERRUPT 0\n#define MW_DMA_CH2_ENABLEOVERFLOW 0\n#define MW_DMA_CH3_ENABLEDMACHANNEL 0\n#define MW_DMA_CH3_DATASIZE 0\n#define MW_DMA_CH3_INTERRUPTSRC 0\n#define MW_DMA_CH3_EXTERNALPIN 0\n#define MW_DMA_CH3_BURSTSIZE 0\n#define MW_DMA_CH3_TRANSFERSIZE 1\n#define MW_DMA_CH3_SRCBEGINADD 0xC000\n#define MW_DMA_CH3_DSTBEGINADD 0xD000\n#define MW_DMA_CH3_SRCBURSTSTEP 0\n#define MW_DMA_CH3_DSTBURSTSTEP 0\n#define MW_DMA_CH3_SRCTRANSSTEP 0\n#define MW_DMA_CH3_DSTTRANSSTEP 0\n#define MW_DMA_CH3_WRAPSRCSIZE 65536\n#define MW_DMA_CH3_WRAPDSTSIZE 65536\n#define MW_DMA_CH3_SRCWRAPSTEP 0\n#define MW_DMA_CH3_DSTWRAPSTEP 0\n#define MW_DMA_CH3_ENABLEONESHOT 0\n#define MW_DMA_CH3_ENABLECONTINUOUS 1\n#define MW_DMA_CH3_SYNCENABLE 0\n#define MW_DMA_CH3_ENABLEDSTSYNC 0\n#define MW_DMA_CH3_GENINTERRUPT 0\n#define MW_DMA_CH3_ENABLEOVERFLOW 0\n#define MW_DMA_CH4_ENABLEDMACHANNEL 0\n#define MW_DMA_CH4_DATASIZE 0\n#define MW_DMA_CH4_INTERRUPTSRC 0\n#define MW_DMA_CH4_EXTERNALPIN 0\n#define MW_DMA_CH4_BURSTSIZE 0\n#define MW_DMA_CH4_TRANSFERSIZE 1\n#define MW_DMA_CH4_SRCBEGINADD 0xC000\n#define MW_DMA_CH4_DSTBEGINADD 0xD000\n#define MW_DMA_CH4_SRCBURSTSTEP 0\n#define MW_DMA_CH4_DSTBURSTSTEP 0\n#define MW_DMA_CH4_SRCTRANSSTEP 0\n#define MW_DMA_CH4_DSTTRANSSTEP 0\n#define MW_DMA_CH4_WRAPSRCSIZE 65536\n#define MW_DMA_CH4_WRAPDSTSIZE 65536\n#define MW_DMA_CH4_SRCWRAPSTEP 0\n#define MW_DMA_CH4_DSTWRAPSTEP 0\n#define MW_DMA_CH4_ENABLEONESHOT 0\n#define MW_DMA_CH4_ENABLECONTINUOUS 1\n#define MW_DMA_CH4_SYNCENABLE 0\n#define MW_DMA_CH4_ENABLEDSTSYNC 0\n#define MW_DMA_CH4_GENINTERRUPT 0\n#define MW_DMA_CH4_ENABLEOVERFLOW 0\n#define MW_DMA_CH5_ENABLEDMACHANNEL 0\n#define MW_DMA_CH5_DATASIZE 0\n#define MW_DMA_CH5_INTERRUPTSRC 0\n#define MW_DMA_CH5_EXTERNALPIN 0\n#define MW_DMA_CH5_BURSTSIZE 0\n#define MW_DMA_CH5_TRANSFERSIZE 1\n#define MW_DMA_CH5_SRCBEGINADD 0xC000\n#define MW_DMA_CH5_DSTBEGINADD 0xD000\n#define MW_DMA_CH5_SRCBURSTSTEP 0\n#define MW_DMA_CH5_DSTBURSTSTEP 0\n#define MW_DMA_CH5_SRCTRANSSTEP 0\n#define MW_DMA_CH5_DSTTRANSSTEP 0\n#define MW_DMA_CH5_WRAPSRCSIZE 65536\n#define MW_DMA_CH5_WRAPDSTSIZE 65536\n#define MW_DMA_CH5_SRCWRAPSTEP 0\n#define MW_DMA_CH5_DSTWRAPSTEP 0\n#define MW_DMA_CH5_ENABLEONESHOT 0\n#define MW_DMA_CH5_ENABLECONTINUOUS 1\n#define MW_DMA_CH5_SYNCENABLE 0\n#define MW_DMA_CH5_ENABLEDSTSYNC 0\n#define MW_DMA_CH5_GENINTERRUPT 0\n#define MW_DMA_CH5_ENABLEOVERFLOW 0\n#define MW_DMA_CH6_ENABLEDMACHANNEL 0\n#define MW_DMA_CH6_DATASIZE 0\n#define MW_DMA_CH6_INTERRUPTSRC 0\n#define MW_DMA_CH6_EXTERNALPIN 0\n#define MW_DMA_CH6_BURSTSIZE 0\n#define MW_DMA_CH6_TRANSFERSIZE 1\n#define MW_DMA_CH6_SRCBEGINADD 0xC000\n#define MW_DMA_CH6_DSTBEGINADD 0xD000\n#define MW_DMA_CH6_SRCBURSTSTEP 0\n#define MW_DMA_CH6_DSTBURSTSTEP 0\n#define MW_DMA_CH6_SRCTRANSSTEP 0\n#define MW_DMA_CH6_DSTTRANSSTEP 0\n#define MW_DMA_CH6_WRAPSRCSIZE 65536\n#define MW_DMA_CH6_WRAPDSTSIZE 65536\n#define MW_DMA_CH6_SRCWRAPSTEP 0\n#define MW_DMA_CH6_DSTWRAPSTEP 0\n#define MW_DMA_CH6_ENABLEONESHOT 0\n#define MW_DMA_CH6_ENABLECONTINUOUS 1\n#define MW_DMA_CH6_SYNCENABLE 0\n#define MW_DMA_CH6_ENABLEDSTSYNC 0\n#define MW_DMA_CH6_GENINTERRUPT 0\n#define MW_DMA_CH6_ENABLEOVERFLOW 0\n#define MW_XINT_GPIOXINT1SEL 0\n#define MW_XINT_GPIOXINT2SEL 0\n#define MW_XINT_GPIOXINT3SEL 0\n#define MW_XINT_GPIOXINT4SEL 0\n#define MW_XINT_GPIOXINT5SEL 0\n#define MW_XINT_GPIOXINT6SEL 0\n#define MW_XINT_GPIOXINT7SEL 0\n#define MW_XINT_POLARITY1 0\n#define MW_XINT_POLARITY2 0\n#define MW_XINT_POLARITY3 0\n#define MW_XINT_POLARITY4 0\n#define MW_XINT_POLARITY5 0\n#define MW_XINT_POLARITY6 0\n#define MW_XINT_POLARITY7 0\n#define MW_PIL_COMMUNICATIONINTERFACE 0\n#define MW_PIL_SCIMODULE 0\n#define MW_PIL_COMPORT COM1\n#define MW_EXTMODECOMPORT -1\n#define MW_EXECUTIONPROFILEBUFFERLEN 50.000000\n#define MW_SDCARD_ENABLE 0\n#define MW_SDCARD_SPIMODULE 0\n#define MW_SDCARD_SPIBAUDRATE 1\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_CHECK_GPIO_STATUS 1\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 34\n#define MW_OVERRUNDETECTION_GPIOMODE 0\n#define MW_OVERRUNDETECTION_CUSTOM_LOGIC 0\n#define MW_OVERRUNDETECTION_PIE_NUMBER 0\n#define MW_OVERRUNDETECTION_CPU_NUMBER 0\n#define MW_OVERRUNDETECTION_CUSTOM_FUNCTION c2000_OverrunFunction\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"c2833xBoard_Realtime_Support.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"#include \"MW_target_hardware_resources.h\"\n#include <math.h>\n#include <float.h>\n#include <string.h>\n\n#ifdef MW_FAST_RTS_INCLUDED\n#if DBL_MANT_DIG == FLT_MANT_DIG\nfloat cosf(float x) { return cos(x); }\nfloat sinf(float x) { return sin(x); }\nfloat sqrtf(float x) { return sqrt(x); }\nfloat atanf(float x) { return atan(x); }\nfloat atan2f(float y, float x) { return atan2(y, x); }\n#endif\n#endif\n\nextern Uint16 RamfuncsLoadSize;\n\nvoid c2000_flash_init(void)\n{\n  #if MW_RUNTIME_FLASHLOAD\n  // Copy InitFlash function code and Flash setup code to RAM\n  memcpy(&RamfuncsRunStart,&RamfuncsLoadStart, (Uint32)(&RamfuncsLoadEnd-&RamfuncsLoadStart));\n\n  // Call Flash Initialization to setup flash waitstates\n  // This function must reside in RAM\n  InitFlash();\n  #endif\n}\n"},{"name":"c2833xSchedulerTimer0.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"#include <stdbool.h>\n\n#include \"DSP2833x_Device.h\"\n#include \"DSP2833x_CpuTimers.h\"\n#include \"MW_c28xx_pie.h\"\n\nextern void rt_OneStep(void);\n\ninterrupt void TINT0_isr(void)\n{\n      #ifdef PIEMASK0\n        volatile unsigned int PIEIER1_stack_save = PieCtrlRegs.PIEIER1.all;\n      #endif\n      #ifdef PIEMASK1\n        volatile unsigned int PIEIER2_stack_save  = PieCtrlRegs.PIEIER2.all;\n      #endif\n      #ifdef PIEMASK2\n        volatile unsigned int PIEIER3_stack_save  = PieCtrlRegs.PIEIER3.all;\n      #endif\n      #ifdef PIEMASK3\n        volatile unsigned int PIEIER4_stack_save  = PieCtrlRegs.PIEIER4.all;\n      #endif\n      #ifdef PIEMASK4\n        volatile unsigned int PIEIER5_stack_save  = PieCtrlRegs.PIEIER5.all;\n      #endif\n      #ifdef PIEMASK5\n        volatile unsigned int PIEIER6_stack_save  = PieCtrlRegs.PIEIER6.all;\n      #endif\n      #ifdef PIEMASK6\n        volatile unsigned int PIEIER7_stack_save  = PieCtrlRegs.PIEIER7.all;\n      #endif\n      #ifdef PIEMASK7\n        volatile unsigned int PIEIER8_stack_save  = PieCtrlRegs.PIEIER8.all;\n      #endif\n      #ifdef PIEMASK8\n        volatile unsigned int PIEIER9_stack_save  = PieCtrlRegs.PIEIER9.all;\n      #endif\n      #ifdef PIEMASK9\n        volatile unsigned int PIEIER10_stack_save = PieCtrlRegs.PIEIER10.all;\n      #endif\n      #ifdef PIEMASK10\n        volatile unsigned int PIEIER11_stack_save = PieCtrlRegs.PIEIER11.all;\n      #endif\n      #ifdef PIEMASK11\n        volatile unsigned int PIEIER12_stack_save = PieCtrlRegs.PIEIER12.all;\n      #endif\n\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all &= ~PIEMASK0;      /* disable group1 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all &= ~PIEMASK1;      /* disable group2 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all &= ~PIEMASK2;      /* disable group3 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all &= ~PIEMASK3;      /* disable group4 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all &= ~PIEMASK4;      /* disable group5 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all &= ~PIEMASK5;      /* disable group6 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all &= ~PIEMASK6;      /* disable group7 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all &= ~PIEMASK7;      /* disable group8 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all &= ~PIEMASK8;      /* disable group9 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all &= ~PIEMASK9;     /* disable group10 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all &= ~PIEMASK10;    /* disable group11 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all &= ~PIEMASK11;    /* disable group12 lower/equal priority interrupts */\n      #endif\n\n      asm(\" RPT #5 || NOP\");               /* wait 5 cycles */\n      IFR &= ~IFRMASK;                           /* eventually disable lower/equal priority pending interrupts */\n      PieCtrlRegs.PIEACK.all = IFRMASK;          /* ACK to allow other interrupts from the same group to fire */\n      IER |= 1;\n      EINT;                                /* global interrupt enable */\n      rt_OneStep();\n      DINT;                                /* disable global interrupts during context switch, CPU will enable global interrupts after exiting ISR */\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all = PIEIER1_stack_save;/*restore PIEIER register that was modified */\n      #endif  \n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all = PIEIER2_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all = PIEIER3_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all = PIEIER4_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all = PIEIER5_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all = PIEIER6_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all = PIEIER7_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all = PIEIER8_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all = PIEIER9_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all= PIEIER10_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all= PIEIER11_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all= PIEIER12_stack_save;/*restore PIEIER register that was modified */\n      #endif\n}\n\nvoid configureTimer0(float baseRate, float systemClock)\n{\n    \n    /* InitCpuTimers() - CPU Timers are initialized in \n     * MW_c28xx_board.c in the generated code.\n     */\n\n\t/* Configure CPU-Timer 0 to interrupt every base rate. */\n\t/* Parameters:  Timer Pointer, CPU Freq in MHz, Period in usec. */\n\tConfigCpuTimer(&CpuTimer0, systemClock, baseRate * 1000000);\n\tStartCpuTimer0();\n\n\tEALLOW;\n\tPieVectTable.TINT0 = &TINT0_isr;     /* Hook interrupt to the ISR*/\n\tEDIS;\n\n\tPieCtrlRegs.PIEIER1.bit.INTx7 = 1;   /* Enable interrupt TINT0 */\n\tIER |= M_INT1;\n}\n\nvoid enableTimer0Interrupt(void)\n{\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n\tPieCtrlRegs.PIEIER1.all |= (1 << 6); /* Enable PIER bit for timer 0 */\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n}\n\nbool disableTimer0Interrupt(void)\n{\n    bool isrEnabled = false;\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n    isrEnabled = PieCtrlRegs.PIEIER1.all & (1 << 6) ;\n\tPieCtrlRegs.PIEIER1.all &= ~(1 << 6); /* Disable PIER bit for timer 0 */\n\tasm(\" RPT #5 || NOP\");\n\tIFR &= 0xFFFE;\n\tPieCtrlRegs.PIEACK.all = 0x1;\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n    return isrEnabled;\n}\n\nvoid restoreTimer0Interrupt(bool isrStatus){\n    if(isrStatus)\n        enableTimer0Interrupt();\n    else\n        disableTimer0Interrupt();\n}\n"},{"name":"datamodify_xcp.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\shared\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*\n *   Copyright 2014-2020 The MathWorks, Inc.\n *\n *\n */\n\n\n#include <stdlib.h>\n#include \"rtwtypes.h\"\n#include \"datamodify.h\"\n\n\n/* Que Declarations */\nboolean_T isEmpty(queSci* que);\n\nboolean_T isFull(queSci* que);\n\n#ifdef MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT\n\n#if MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT != 1\n\nqueSci queRx;\t\t/* Que to Supplement SCI in External Mode */\n\n#else \n\n#pragma DATA_SECTION(queRx,\"rambldata\");    /*Que for BL placed in BL data area*/\nqueSci queRx;\t\t/* Que to Supplement SCI in External Mode */\n\n#endif\n\n#else\nqueSci queRx;\t\t/* Que to Supplement SCI in External Mode */\n\n#endif\n\nvoid BytePackerInplace32bits(char* src)\n{\n\tuint32_T temp32bits=0;\n\tuint32_T mask = 0xff;\n\tchar \t index=0;\n\n\tfor (index = 0; index < 4; index++)\n\t{\n\t\ttemp32bits += ( (uint32_T)(src[index] & mask) << (8 * index) );\n\n\t}\n\n\t*src = temp32bits;\n\n}\n\n\nvoid BytePacker32bits(void *dst, const char* src )\n{\n\n\tuint32_T temp32bits=0;\n\tuint32_T mask = 0xff;\n\tchar \t index=0;\n\tuint32_T *typecastdst = (uint32_T *)dst;\n\n\tfor (index = 0; index < 4; index++)\n\t{\n\t\ttemp32bits += ( (uint32_T)(src[index] & mask) << (8 * index) );\n\n\t}\n\n\t*typecastdst = temp32bits;\n\n}\n\nvoid BytePacker16bits(void* dst, const char* src)\n{\n\tuint16_T temp16bits=0;\n\tuint16_T mask = 0xff;\n\tuint16_T *typecastdst = (uint16_T*)dst;\n\tchar index = 0;\n\tfor( index=0; index < 2; index++)\n\t{\n\t\ttemp16bits += ((uint16_T)(src[index] & mask) << (8 * index));\n\n\t}\n\n\t*typecastdst = temp16bits;\n\n\n}\n\n\nvoid initQue(queSci *que)\n{\n\tque->firstElement = 0;\n\tque->queCount     = 0;\n}\n\n\nboolean_T isEmpty(queSci* que)\n{\n\tif (que->queCount == 0)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n\nboolean_T isFull(queSci* que)\n{\n\tif(que->queCount >= QUE_SIZE)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n\n\nboolean_T addElement(queSci* que, char* new_element)\n{\n\n\tint new_element_position=0;\n\n\tif(isFull(que))\n\t{\n\t\treturn false;\n\t}\n\n\t//Add new element\n\tnew_element_position = (que->firstElement + que->queCount);\n\tif (new_element_position >= QUE_SIZE)\n\t{\n        //Wrapping Circular Buffer every time new_element_position >= QUE_SIZE\n\t\tnew_element_position = new_element_position - QUE_SIZE;\t\n\t}\n\n\tque->queElements[new_element_position] = *new_element;\n\tque->queCount++;\n\n\treturn true;\n\n}\n\n#ifdef MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT\n\n#if MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT!=1\n\n#pragma CODE_SECTION(deleteElement, \"ramfuncs\");\n/* C2806x case without BL \n * this is required only for BL build\n */\n\n#else\n\n/* C2806x case with BL \n * this is required only for BL build\n */\n\n#pragma CODE_SECTION(deleteElement, \"blramfuncs\");\n/* for BL build, to avoid content with Application code RAM\n * this function has to sit in the BL dedicated RAM. */\n\n#endif\n\n#else\n\n#pragma CODE_SECTION(deleteElement, \"ramfuncs\");\n/*non C2806x cases*/\n\n#endif\n\n/*\n\tdeleteElement() is supposed to read an element from the Queue and decreases it's length by one. This is the standard and expected behaviour.\n\tHowever, in case the Queue is empty, it does check the hardware buffer for any available data. If new data is available, it is read and returned.\n\tIf not, the function returns 'false' indicating a failure to read/fetch any data.\n\n*/\n\nboolean_T deleteElement(queSci* que, char* read_element)\n{\n\tif(isEmpty(que))\t\t\t\t\t\t\t\t\t// check if queue empty.\n        return false;\n\telse {\n\t\tDINT;\t\t//Disable Interrupts while accessing SW Que\n\n\t\t*read_element = que->queElements[que->firstElement++];\n\t\tque->queCount--;\n\n\t\tEINT;\t\t//Renable Interrupts after accessing SW Que\n\t\t\n\t\treturn true;\n\t}\n}\n\n\n"},{"name":"pm_printf.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * Abstract:\n *\n *    Conditionally include implementations for wrappers of printf\n *    functionality.\n *\n * Copyright 2015-2016 The MathWorks, Inc.\n */\n\n/* only Visual compile printf implementations */\n\n#if defined(_MSC_VER)\n#include \"pm_printf.h\"\n\n#else\n/*\n * included to avoid empty translation unit\n */\ntypedef int pm_printf_dummy;\n#endif\n"},{"name":"profiler_Support.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyrights 2016, MathWorks Inc */\n#include \"MW_target_hardware_resources.h\"\n#include \"rtwtypes.h\"\n\nvoid config_profilerTimer(void)\n{\n  /* InitCpuTimers() - CPU Timers are initialized in\n   * MW_c28xx_board.c in the generated code.\n   */\n  CpuTimer1Regs.PRD.all = 0xFFFFFFFF;  /* max Period*/\n  CpuTimer1Regs.TIM.all = 0xFFFFFFFF;  /* set Ctr*/\n  CpuTimer1Regs.TPR.all = 0x00;        /* no prescaler    */\n  StartCpuTimer1();\n}\n\n/* EOF */\n"},{"name":"rt_backsubrr_dbl.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_backsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      backward substitution: solving Ux=b for real\r\n *      double precision float operands.\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_BackwardSubstitutionRR_Dbl =====================================\r\n * Abstract: Backward substitution: Solving Ux=b \r\n *           U: real, double\r\n *           b: real, double\r\n *           U is an upper (or unit upper) triangular full matrix.\r\n *           The entries in the lower triangle are ignored.\r\n *           U is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                   const real_T    *pb,\r\n                                   real_T          *x,\r\n                                   int_T            N,\r\n                                   int_T            P,\r\n                                   boolean_T        unit_upper)\r\n{\r\n  int_T i,k;\r\n  for(k=P; k>0; k--) {\r\n    real_T *pUcol = pU;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N-1;\r\n      real_T s = 0.0;\r\n      real_T *pUrow = pUcol--;          /* access current row of U */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pUrow * *xj--;\r\n          pUrow -= N;\r\n        }\r\n      }\r\n\r\n      if (unit_upper) {\r\n        *xj = *pb-- - s;\r\n      } else {\r\n        *xj = (*pb-- - s) / *pUrow;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_backsubrr_dbl.c */\r\n"},{"name":"rt_forwardsubrr_dbl.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_forwardsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      forward substitution: solving Lx=b\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_ForwardSubstitutionRR_Dbl ======================================\r\n * Abstract: Forward substitution: solving Lx=b \r\n *           L: Real, double\r\n *           b: Real, double\r\n *           L is a lower (or unit lower) triangular full matrix.\r\n *           The entries in the upper triangle are ignored.\r\n *           L is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                  const real_T  *pb,\r\n                                  real_T        *x,\r\n                                  int_T          N,\r\n                                  int_T          P,\r\n                                  const int32_T *piv,\r\n                                  boolean_T      unit_lower)\r\n{  \r\n  /* Real inputs: */\r\n  int_T i, k;\r\n  for(k=0; k<P; k++) {\r\n    real_T *pLcol = pL;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N;\r\n      real_T s = 0.0;\r\n      real_T *pLrow = pLcol++;          /* access current row of L */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pLrow * *xj;\r\n          pLrow += N;\r\n          xj++;\r\n        }\r\n      }\r\n\r\n      if (unit_lower) {\r\n        *xj = pb[piv[i]] - s;\r\n      } else {\r\n        *xj = (pb[piv[i]] - s) / *pLrow;\r\n      }\r\n    }\r\n    pb += N;\r\n  }\r\n}\r\n\r\n/* [EOF] rt_forwardsubrr_dbl.c */\r\n"},{"name":"rt_lu_real.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_lu_real.c     \r\n *\r\n * Abstract:\r\n *      Real-Time Workshop support routine for lu_real\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_lu_real  =======================================================\r\n * Abstract: A is real.\r\n *\r\n */\r\nvoid rt_lu_real(real_T      *A,    /* in and out                         */\r\n                const int_T n,     /* number or rows = number of columns */\r\n                int32_T     *piv)  /* pivote vector                      */\r\n{\r\n  int_T k;\r\n\r\n  /* initialize row-pivot indices: */\r\n  for (k = 0; k < n; k++) {\r\n    piv[k] = k;\r\n  }\r\n\r\n  /* Loop over each column: */\r\n  for (k = 0; k < n; k++) {\r\n    const int_T kn = k*n;\r\n    int_T p = k;\r\n\r\n    /* Scan the lower triangular part of this column only\r\n     * Record row of largest value\r\n     */\r\n    {\r\n      int_T i;\r\n      real_T Amax = fabs(A[p+kn]);      /* assume diag is max */\r\n      for (i = k+1; i < n; i++) {\r\n        real_T q = fabs(A[i+kn]);\r\n        if (q > Amax) {p = i; Amax = q;}\r\n      }\r\n    }\r\n\r\n    /* swap rows if required */\r\n    if (p != k) {\r\n      int_T j;\r\n      int32_T t1;\r\n      for (j = 0; j < n; j++) {\r\n        real_T t;\r\n        const int_T j_n = j*n;\r\n        t = A[p+j_n]; A[p+j_n] = A[k+j_n]; A[k+j_n] = t;\r\n      }\r\n      /* swap pivot row indices */\r\n      t1 = piv[p]; piv[p] = piv[k]; piv[k] = t1;\r\n    }\r\n\r\n    /* column reduction */\r\n    {\r\n      real_T Adiag = A[k+kn];\r\n      int_T i,j;\r\n      if (Adiag != 0.0) {               /* non-zero diagonal entry */\r\n\r\n        /* divide lower triangular part of column by max */\r\n        Adiag = 1.0/Adiag;\r\n        for (i = k+1; i < n; i++) {\r\n          A[i+kn] *= Adiag;\r\n        }\r\n\r\n        /* subtract multiple of column from remaining columns */\r\n        for (j = k+1; j < n; j++) {\r\n          int_T j_n = j*n;\r\n          for (i = k+1; i < n; i++) {\r\n            A[i+j_n] -= A[i+kn]*A[k+j_n];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_lu_real.c */\r\n"},{"name":"rt_matrixlib.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef rt_matrixlib_h\r\n#define rt_matrixlib_h\r\n\r\n/* Copyright 2007-2013 The MathWorks, Inc.\r\n *\r\n * File    : rt_matrixlib.h\r\n * Abstract:\r\n *     Function prototypes for .c sources in rtw/c/src/matrixmath.\r\n *\r\n */\r\n\r\n\r\n/*==========*\r\n * Includes *\r\n *==========*/\r\n\r\n#include \"rtwtypes.h\"\r\n#include <limits.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* Matrix Multiplication Utility Functions */\r\nextern void rt_MatMultRR_Dbl(real_T         *y, \r\n                             const real_T   *A, \r\n                             const real_T   *B, \r\n                             const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Dbl(creal_T       *y,\r\n                             const real_T  *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCR_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const real_T  *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCC_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultRR_Sgl(real32_T       *y,\r\n                             const real32_T *A,\r\n                             const real32_T *B,\r\n                             const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Sgl(creal32_T       *y,\r\n                             const real32_T  *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCR_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const real32_T  *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCC_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultAndIncRR_Dbl(real_T       *y,\r\n                                   const real_T *A,\r\n                                   const real_T *B,\r\n                                   const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Dbl(creal_T       *y,\r\n                                   const real_T  *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const real_T  *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n#endif\r\nextern void rt_MatMultAndIncRR_Sgl(real32_T       *y,\r\n                                   const real32_T *A,\r\n                                   const real32_T *B,\r\n                                   const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Sgl(creal32_T       *y,\r\n                                   const real32_T  *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const real32_T  *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n#endif \r\n\r\n/* Matrix Inversion Utility Functions */\r\nextern void rt_lu_real(real_T      *A,\r\n                       const int_T n,\r\n                       int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx(creal_T *A,\r\n                       const int_T n,\r\n                       int32_T *piv);\r\n#endif\r\n\r\nextern void rt_lu_real_sgl(real32_T      *A,\r\n                           const int_T n,\r\n                           int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx_sgl(creal32_T *A,\r\n                           const int_T n,\r\n                           int32_T *piv);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                          const real_T    *pb,\r\n                                          real_T          *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Dbl(real_T          *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Dbl(creal_T         *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                         const real_T  *pb,\r\n                                         real_T        *x,\r\n                                         int_T          N,\r\n                                         int_T          P,\r\n                                         const int32_T *piv,\r\n                                         boolean_T      unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Dbl(real_T        *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Dbl(creal_T   *pL,\r\n                                         const real_T    *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Dbl(creal_T   *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Sgl(real32_T          *pU,\r\n                                          const real32_T    *pb,\r\n                                          real32_T          *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Sgl(real32_T          *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Sgl(creal32_T         *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Sgl(real32_T    *pL,\r\n                                         const real32_T    *pb,\r\n                                         real32_T    *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Sgl(real32_T    *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Sgl(creal32_T   *pL,\r\n                                         const real32_T    *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Sgl(creal32_T   *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\n\r\nextern void rt_MatDivRR_Dbl(real_T        *Out,\r\n                            const real_T  *In1,\r\n                            const real_T  *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            real_T        *x,\r\n                            const int_T    dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Dbl(creal_T       *Out,\r\n                            const real_T  *In1,\r\n                            const creal_T *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCR_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const real_T  *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCC_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const creal_T *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n#endif\r\n\r\nextern void rt_MatDivRR_Sgl(real32_T        *Out,\r\n                            const real32_T  *In1,\r\n                            const real32_T  *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            real32_T        *x,\r\n                            const int_T      dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Sgl(creal32_T       *Out,\r\n                            const real32_T  *In1,\r\n                            const creal32_T *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCR_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const real32_T  *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCC_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const creal32_T *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n#endif\r\n\r\n\r\n/* Matrix multiplication defines */\r\n\r\n/* Quick (approximate) complex absolute value: */\r\n#define CQABS(X) (fabs((X).re) + fabs((X).im))\r\n\r\n/* Quick (approximate) complex absolute value for singles: */\r\n#define CQABSSGL(X) (real32_T)(fabs( (real_T) (X).re) + fabs( (real_T) (X).im)) \r\n\r\n#ifdef CREAL_T\r\nextern void rt_ComplexTimes_Dbl(creal_T       *Out,\r\n                                const creal_T In1,\r\n                                const creal_T In2);\r\n\r\nextern void rt_ComplexRDivide_Dbl(creal_T       *Out,\r\n                                  const creal_T In1,\r\n                                  const creal_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Dbl(creal_T       *Out,\r\n                                     const creal_T In1);\r\n\r\nextern void rt_ComplexTimes_Sgl(creal32_T       *Out,\r\n                                const creal32_T In1,\r\n                                const creal32_T In2);\r\n\r\nextern void rt_ComplexRDivide_Sgl(creal32_T       *Out,\r\n                                  const creal32_T In1,\r\n                                  const creal32_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Sgl(creal32_T       *Out,\r\n                                     const creal32_T In1);\r\n\r\n#endif\r\n\r\nextern real_T rt_Hypot_Dbl(real_T In1,\r\n                           real_T In2);\r\n\r\nextern real32_T rt_Hypot_Sgl(real32_T In1,\r\n                             real32_T In2);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* rt_matrixlib_h */\r\n"},{"name":"rt_matrixlib_dbl.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2013 The MathWorks, Inc.\r\n *\r\n * File: rt_matrixlib_dbl.c\r\n *\r\n * Abstract:\r\n *      Simulink Coder utility functions\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n#ifdef CREAL_T\r\nvoid rt_ComplexTimes_Dbl(creal_T* c,\r\n                         const creal_T a,\r\n                         const creal_T b)\r\n{\r\n    if (a.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.re * b.im;\r\n        if (b.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (b.re == 0.0 || a.re == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else if (b.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0 || a.re == 0.0) { \r\n            c->re = 0.0;\r\n        }\r\n    } else if (a.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0) {\r\n            c->im = 0.0;\r\n        }\r\n    } else if (b.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.re * b.im;\r\n    } else {\r\n        c->re = a.re * b.re - a.im * b.im;\r\n        c->im = a.re * b.im + a.im * b.re;\r\n    }\r\n}\r\n\r\nvoid rt_ComplexRDivide_Dbl(creal_T* c,\r\n                           const creal_T a,\r\n                           const creal_T b)\r\n{\r\n    if (b.im == 0.0) {\r\n        c->re = a.re / b.re;\r\n        if (a.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else { /* a.im != 0.0 */\r\n            c->im = a.im / b.re;\r\n            if (a.re == 0.0) {\r\n                c->re = 0.0;\r\n            }\r\n        }\r\n    } else if (b.re == 0.0) { /* b.im != 0.0 */\r\n        c->re = a.im / b.im;\r\n        c->im = -a.re / b.im;\r\n        if (a.re == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (a.im == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else {\r\n        real_T brm = fabs(b.re);\r\n        real_T bim = fabs(b.im);\r\n        if (brm > bim) {\r\n            real_T s = b.im / b.re;\r\n            real_T d = b.re + s * b.im;\r\n            c->im = (a.im - s * a.re) / d;\r\n            c->re = (a.re + s * a.im) / d;\r\n        } else if (brm == bim) {\r\n            real_T half = 0.5;\r\n            real_T sgnbr = b.re > 0.0 ? half : -half;\r\n            real_T sgnbi = b.im > 0.0 ? half : -half;\r\n            c->im = (a.im*sgnbr - a.re*sgnbi)/brm;\r\n            c->re = (a.re*sgnbr + a.im*sgnbi)/brm;\r\n        } else {\r\n            real_T s = b.re / b.im;\r\n            real_T d = b.im + s * b.re;\r\n            c->im = (s * a.im - a.re) / d;\r\n            c->re = (s * a.re + a.im) / d;\r\n        }\r\n    }\r\n}\r\n\r\nvoid rt_ComplexReciprocal_Dbl(creal_T* Out,\r\n                              const creal_T In1)\r\n{\r\n    creal_T y;\r\n    y.re = 1.0;\r\n    y.im = 0.0;\r\n\r\n    rt_ComplexRDivide_Dbl(Out, y, In1);\r\n}\r\n\r\n#endif\r\n\r\n\r\nreal_T rt_Hypot_Dbl(real_T a, real_T b)\r\n{\r\n    real_T y;\r\n    if (a != a || b != b) {\r\n        y = a + b;\r\n    } else {\r\n        real_T t;\r\n        if (fabs(a) > fabs(b)) {\r\n            t = b/a;\r\n            y = fabs(a)*sqrt(1.0 + t*t);\r\n        } else {\r\n            if (b == 0.0) {\r\n                y = 0.0;\r\n            } else {\r\n                t = a/b;\r\n                y = fabs(b)*sqrt(1.0 + t*t);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return y;\r\n}\r\n"},{"name":"rtiostream_serial_c28x_ext.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"// Created on 16-Mar-2024 15:06:22\n#ifndef RTIOSTREAM_SERIAL_C28X_EXT_H_\n#define RTIOSTREAM_SERIAL_C28X_EXT_H_\n\n#include \"MW_target_hardware_resources.h\"\n\n// Baud Rate = 115031\n#define MW_PIL_SCIHBAUD 0\n#define MW_PIL_SCILBAUD 162\n\n#define EXT_SCI_RX_PIN 28\n#define EXT_SCI_TX_PIN 29\n\n#define RX_PIN_MUX_VAL 1\n#define TX_PIN_MUX_VAL 1\n\n#endif\n"},{"name":"rtiostream_serial_c28x_ext_xcp.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\shared\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*\n *   Copyright 2011-2021 The MathWorks, Inc.\n *\n *\n */\n\n\n#include <stdlib.h>\n#include <string.h>\n#include \"rtwtypes.h\"\n#include \"rtiostream_serial_c28x_ext.h\" /* Autogenerated */\n#include \"datamodify.h\"\n#if defined (F2837X_REG_FORMAT) && defined (CPU2)\n#ifdef MW_F2837XD\n#include \"F2837xD_Ipc_drivers.h\"\n#define CPU01_TO_CPU02_PASSMSG  0x0003FFF4\n#endif //MW_F2837XD\n#ifdef MW_F2838X\n#include \"MW_f2838x_includes.h\"\n#endif //MW_F2838X\n#endif\n#include \"MW_c28xGPIO.h\"\n\n#define NOERROR                        0\n#define PRTYERR                        3\n#define FRAMERR                        4\n#define RTIOSTREAM_NO_ERROR           (0)\n#define RTIOSTREAM_ERROR             (-1)\n#define SERVER_STREAM_ID              (1) /* Allow a single server-side connection */\n#define RTIOSTREAM_MAX_CHAR            32 /* Allocate temporary variables in global memory so that they do not show up in stack profiling numbers */\n\n#ifdef MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT\n\n#if MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT != 1\n\nchar srcSerial[RTIOSTREAM_MAX_CHAR];\n\n#else\n\n#pragma DATA_SECTION(srcSerial,\"rambldata\");    /* For BL placed in BL data area*/\n\nchar srcSerial[RTIOSTREAM_MAX_CHAR];\n\n#endif\n\n#else\n\nchar srcSerial[RTIOSTREAM_MAX_CHAR];\n\n#endif\n\nvolatile struct  SCI_REGS * MW_SCI_PTR = &SciaRegs;\n\nvoid init_SCI_external_mode(void);\nint sci_rcv_external_mode(char *rcvBuff, size_t buffLen, int*sizeCharsRcvd);\nvoid sci_xmit_external_mode(char* pmsg, int msglen);\n\n/************************** rtIOStream functions *****************************/\n\n#ifdef MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT\n\n#if MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT!=1\n\n#pragma CODE_SECTION(SCIRXINT_isr, \"ramfuncs\");\n/* C2806x case without BL \n * this is required only for BL build\n */\n\n#else\n\n/* C2806x case with BL \n * this is required only for BL build\n */\n\n#pragma CODE_SECTION(SCIRXINT_isr, \"blramfuncs\");\n/* for BL build, to avoid content with Application code RAM\n * this function has to sit in the BL dedicated RAM. */\n\n#endif\n\n#else\n\n#pragma CODE_SECTION(SCIRXINT_isr, \"ramfuncs\");\n/*non C2806x cases*/\n\n#endif\n\n\ninterrupt void SCIRXINT_isr(void)\n{\n    if(queRx.queCount < QUE_SIZE )\n        queRx.queElements[((queRx.firstElement + queRx.queCount++) & (QUE_SIZE-1))] = MW_SCI_PTR->SCIRXBUF.all;\n    else\n        while(1){}\n    \n  /*\n  \t Assumption: queRx (SW Queue) will not over flow if the QUE_SIZE is high (64 default value)\n\t The queRx is used to collect data when the SCI HW FIFO overflows\n\t Otherwise the Data Collection for external Mode occurs by\n\t polling the SCI Rx Buffer\n  */\n\n  MW_SCI_PTR->SCIFFRX.bit.RXFFINTCLR = 1; /* Clear Interrupt flag*/\n  #if MW_EXTMODE_SCIMODULE == 0 || MW_EXTMODE_SCIMODULE == 1\n  PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;/* Acknowledge to receive more interrupts   */  \n  #elif MW_EXTMODE_SCIMODULE == 2 || MW_EXTMODE_SCIMODULE == 3\n  PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;/* Acknowledge to receive more interrupts   */ \n  #endif\n}\n\nvoid enable_interrupts_sci(void)\n{\n    #if MW_EXTMODE_SCIMODULE == 0\n    EALLOW;\n      #ifdef F2837X_REG_FORMAT\n      PieVectTable.SCIA_RX_INT = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #else\n      PieVectTable.SCIRXINTA = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #endif //F2837X_REG_FORMAT\n    PieCtrlRegs.PIEIER9.bit.INTx1 = 1;   /* Enable PIE group 9 interrupt 1 for SCIRXINTA*/\n    EDIS;\n    IER |= M_INT9;\n    #elif MW_EXTMODE_SCIMODULE == 1\n    EALLOW;\n      #ifdef F2837X_REG_FORMAT\n      PieVectTable.SCIB_RX_INT = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #else\n      PieVectTable.SCIRXINTB = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #endif //F2837X_REG_FORMAT\n    PieCtrlRegs.PIEIER9.bit.INTx3 = 1;   /* Enable PIE group 9 interrupt 3 for SCIRXINTB*/\n    EDIS;\n    IER |= M_INT9;\n    #elif MW_EXTMODE_SCIMODULE == 2\n    EALLOW;\n      #ifdef F2837X_REG_FORMAT\n      PieVectTable.SCIC_RX_INT = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #else\n      PieVectTable.SCIRXINTC = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #endif //F2837X_REG_FORMAT\n    PieCtrlRegs.PIEIER8.bit.INTx5 = 1;   /* Enable PIE group 8 interrupt 5 for SCIRXINTC*/\n    EDIS;\n    IER |= M_INT8;\n    #elif MW_EXTMODE_SCIMODULE == 3\n    EALLOW;\n      #ifdef F2837X_REG_FORMAT\n      PieVectTable.SCID_RX_INT = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #else\n      PieVectTable.SCIRXINTD = &SCIRXINT_isr;/* Hook interrupt to the ISR*/\n      #endif //F2837X_REG_FORMAT\n    PieCtrlRegs.PIEIER8.bit.INTx7 = 1;   /* Enable PIE group 8 interrupt 7 for SCIRXINTD*/\n    EDIS;\n    IER |= M_INT8;\n    #endif\n}\n\n\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    int streamID = SERVER_STREAM_ID;\n    init_SCI_external_mode();\n    Set_GPIOPin(EXT_SCI_RX_PIN, GPIO_MUX_CPU1, RX_PIN_MUX_VAL, GPIO_INPUT, 0);\n    Set_GPIOPin(EXT_SCI_TX_PIN, GPIO_MUX_CPU1, TX_PIN_MUX_VAL, GPIO_OUTPUT, 0);\n    initQue(&queRx);\t\t\t\t/* int SW Que that supplements SCI for External Mode Over Serial */\n    enable_interrupts_sci();\t\t/* Enable SCI interrupt used for external mode over Serial*/\n\n    return streamID;\n}\n\n\nint rtIOStreamClose(int streamID)\n{\n\tint retVal = RTIOSTREAM_NO_ERROR;\n\n\treturn retVal;\n}\n\n/**\n * @brief   Send BYTEs over UART\n * \n * @note    Send all octets in a word, LSB first.\n *\n * @param[in]   streamID    \n * @param[in]   src         Source buffer\n * @param[in]   bytesToSend Number of BYTEs to send\n * @param[out]  bytesSent   Number of BYTEs sent\n */\nint rtIOStreamSend(int streamID, const void *src, size_t bytesToSend, size_t *bytesSent)\n{\n    sci_xmit_external_mode((char *)src, bytesToSend);\n\n    *bytesSent = bytesToSend;\n    return RTIOSTREAM_NO_ERROR;\n}\n\n/**\n * @brief   Receive BYTEs from UART\n * \n * @note    Pack all received BYTEs into memory, LSB first\n *\n * @param[in]   streamID    \n * @param[in]   dst            Destination buffer\n * @param[in]   bytesToReceive Number of BYTEs to receive\n * @param[out]  bytesRcvd      Number of BYTEs received\n */\nint rtIOStreamRecv(int streamID, void *dst, size_t bytesToReceive, size_t *bytesRcvd)\n{\n\tint errFlg = NOERROR;\n\n\t*bytesRcvd = 0;\n\n\terrFlg = sci_rcv_external_mode((char *)dst, bytesToReceive, (int *)bytesRcvd);\n\n\tif (errFlg != NOERROR)\n\t\treturn RTIOSTREAM_ERROR;\n\n\treturn RTIOSTREAM_NO_ERROR;\n}\n\n\n/************************** C2000 specific functions *****************************/\n\nvoid init_SCI_external_mode(void)\n{\n    #if MW_EXTMODE_SCIMODULE == 0\n    MW_SCI_PTR = &SciaRegs;\n    #elif MW_EXTMODE_SCIMODULE == 1\n    MW_SCI_PTR = &ScibRegs;\n    #elif MW_EXTMODE_SCIMODULE == 2\n    MW_SCI_PTR = &ScicRegs;\n    #elif MW_EXTMODE_SCIMODULE == 3\n    MW_SCI_PTR = &ScidRegs;\n    #endif\n\tEALLOW;\n    /* initialize SCI & FIFO registers */\n\t/*\n\t* Initialize SCI with following parameters:\n\t*    BaudRate              : 115200\n\t*    CharacterLengthBits   : 8\n\t*    EnableLoopBack        : 0\n\t*    NumberOfStopBits      : 1\n\t*    ParityMode            : None\n\t*    SuspensionMode        : Free_run\n\t*    CommMode              : Raw_data\n\t*/\n    #ifdef F2837X_REG_FORMAT\n        #if MW_EXTMODE_SCIMODULE == 0\n        CpuSysRegs.PCLKCR7.bit.SCI_A = 1;\n        #elif MW_EXTMODE_SCIMODULE == 1\n        CpuSysRegs.PCLKCR7.bit.SCI_B = 1;\n        #elif MW_EXTMODE_SCIMODULE == 2\n        CpuSysRegs.PCLKCR7.bit.SCI_C = 1;\n        #elif MW_EXTMODE_SCIMODULE == 3\n        CpuSysRegs.PCLKCR7.bit.SCI_D = 1;\n        #endif\n    #endif\n\tMW_SCI_PTR->SCICTL1.bit.SWRESET = 0;    //Software reset\n\tMW_SCI_PTR->SCICTL1.bit.SWRESET = 1;    //Software reset\n\tMW_SCI_PTR->SCICCR.bit.STOPBITS = 0;    //Number of stop bits. (0: One stop bit, 1: Two stop bits)\n\tMW_SCI_PTR->SCICCR.bit.PARITY = 0;      //Parity mode (0: Odd parity, 1: Even parity)\n\tMW_SCI_PTR->SCICCR.bit.PARITYENA = 0;   //Enable Parity Mode\n\tMW_SCI_PTR->SCICCR.bit.LOOPBKENA = 0;   //Loop Back enable\n\tMW_SCI_PTR->SCICCR.bit.ADDRIDLE_MODE = 0;//ADDR/IDLE Mode control\n\tMW_SCI_PTR->SCICCR.bit.SCICHAR = 7;     //Character length\n\tMW_SCI_PTR->SCICTL1.bit.RXERRINTENA = 0;//Disable receive error interrupt\n\tMW_SCI_PTR->SCICTL1.bit.TXENA = 1;      // SCI transmitter enable\n\tMW_SCI_PTR->SCICTL1.bit.RXENA = 1;      // SCI receiver enable\n    \n    #ifdef F2837X_REG_FORMAT\n    MW_SCI_PTR->SCIHBAUD.all = MW_PIL_SCIHBAUD;\n\tMW_SCI_PTR->SCILBAUD.all = MW_PIL_SCILBAUD;\n    //Free run, continue SCI operation regardless of suspend\n\tMW_SCI_PTR->SCIPRI.bit.FREESOFT = 2;        // Free emulation mode control\n    #else\n\tMW_SCI_PTR->SCIHBAUD = MW_PIL_SCIHBAUD;\n\tMW_SCI_PTR->SCILBAUD = MW_PIL_SCILBAUD;\n    //Free run, continue SCI operation regardless of suspend\n\tMW_SCI_PTR->SCIPRI.bit.FREE = 1;        // Free emulation mode control\n\tMW_SCI_PTR->SCIPRI.bit.SOFT = 0;        // Interrupt priority select\n    #endif\n\n\t\n\tMW_SCI_PTR->SCIFFCT.bit.ABDCLR = 0;\n\tMW_SCI_PTR->SCIFFCT.bit.CDC = 0;\n\tMW_SCI_PTR->SCIFFTX.bit.SCIRST = 1;     // SCI reset rx/tx channels\n\tMW_SCI_PTR->SCIFFTX.bit.SCIFFENA = 1;   // SCI FIFO enhancements are enabled.\n\t#ifdef F2837X_REG_FORMAT\n\t\tMW_SCI_PTR->SCIFFTX.bit.TXFIFORESET = 1;// Re-enable transmit FIFO operation.\n\t#else\n\t\tMW_SCI_PTR->SCIFFTX.bit.TXFIFOXRESET = 1;// Re-enable transmit FIFO operation.\n\t#endif\n\tMW_SCI_PTR->SCIFFRX.bit.RXFIFORESET = 1;// Re-enable receive FIFO operation.\n\n\n\tMW_SCI_PTR->SCIFFRX.bit.RXFFIENA = 1;\t\t\t\t\t//Receive FIFO Interrupt Enable\n    // Enabling FIFO on all the C2000 HW is not working consistently. TODO:Investigate further on the cause of the sporadic issue - g2461348\n\tMW_SCI_PTR->SCIFFRX.bit.RXFFIL = 1;//((MW_PIL_SCIFIFOLEN==16)?(8):(1));\t//Generate Interrupt when FIFO Overflows by 8 for hardware having 16 level of fifo. For hardware F2803,05,06 has fifo for 4 use interrupt on every byte\n\tMW_SCI_PTR->SCICTL1.bit.RXERRINTENA = 1; // Enable receive error interrupt to handle any receive errors for SCI\n\tEDIS;\n}\n\n/**\n * @brief Receive Data from the SCI module, or from the SW Queue that is filled by the\n *        SCI module\n *\n * @note  This function packs data into the destination buffer.\n *\n * @param[out]  rcvBuff          Destination buffer\n * @param[in]   buffLen          Number of 8bit bytes to read\n * @param[in]   loopMode         No idea what this does\n * @param[out]  sizeCharsRcvd    Number of characters read successfully\n */\nint sci_rcv_external_mode(char *rcvBuff, size_t buffLen, int *sizeCharsRcvd)\n{   \n    uint8_T rcvChar;\n\tuint8_T charsRcvd = 0;\n    *sizeCharsRcvd = charsRcvd;\n    \n    if( queRx.queCount < buffLen ){\n        // Enabling FIFO on all the C2000 HW is not working consistently. TODO:Investigate further on the cause of the sporadic issue - g2461348\n        #if 0//MW_PIL_SCIFIFOLEN==16\n            // Added code to check queCount again before just naively quitting.\n            // If the HW buffer ISRs at 8 bytes, and we have 5 bytes in the buffer, the ISR won't trigger.\n            // rtIOStreamRevc will now pend unnecessarily until we receive 3 more bytes belonging to the next packet.\n            while(MW_SCI_PTR->SCIFFRX.bit.RXFFST !=0)\n            {\n                queRx.queElements[((queRx.firstElement + queRx.queCount++) & (QUE_SIZE-1))] = MW_SCI_PTR->SCIRXBUF.all;\n            }\n            if( queRx.queCount < buffLen )\n            {\n                return NOERROR;\n            }\n        #else\n\t    return NOERROR;\n\t#endif\n    }\n    \n    /* When an xcp command with odd number of bytes (like one BYTE GET_DAQ_RESOLUTION_INFO/GET_DAQ_PROCESSOR_INFO)\n     * is pushed into packed words, the MSB of the last word will be undetermined.\n     * This value will interfere with the checksum calculation (since the checksum)\n     * works on all bytes of the words.\n     */\n    memset(rcvBuff, 0, (buffLen+1)/2);\n    //__byte(rcvBuff, 1 + (buffLen+1)/2) = 0x00;\n\n\twhile (charsRcvd < buffLen ) {\n\n\t\tif(deleteElement(&queRx, (char *)&rcvChar))  {\t\t//try to pull off a byte from the queue.\n            __byte((int *)rcvBuff, charsRcvd) = rcvChar ;\n\t\t\tcharsRcvd += 1;\n\t\t}\n\t}\n\t#if MW_EXTMODE_SCIMODULE == 0\n\tif( (SciaRegs.SCIRXST.bit.FE) || (SciaRegs.SCIRXST.bit.PE) || (SciaRegs.SCIFFRX.bit.RXFFOVF) || (SciaRegs.SCIRXST.bit.BRKDT))\n\t{\n\t#elif MW_EXTMODE_SCIMODULE == 1\n\tif( (ScibRegs.SCIRXST.bit.FE) || (ScibRegs.SCIRXST.bit.PE) || (ScibRegs.SCIFFRX.bit.RXFFOVF) || (ScibRegs.SCIRXST.bit.BRKDT))\n\t{\n\t#elif MW_EXTMODE_SCIMODULE == 2\n\tif( (ScicRegs.SCIRXST.bit.FE) || (ScicRegs.SCIRXST.bit.PE) || (ScicRegs.SCIFFRX.bit.RXFFOVF) || (ScicRegs.SCIRXST.bit.BRKDT))\n\t{\n\t#elif MW_EXTMODE_SCIMODULE == 3\n\tif( (ScidRegs.SCIRXST.bit.FE) || (ScidRegs.SCIRXST.bit.PE) || (ScidRegs.SCIFFRX.bit.RXFFOVF) || (ScidRegs.SCIRXST.bit.BRKDT))\n\t{\n\t#endif\n\t\treturn FRAMERR;\t\t\t\t\t/* Providing FRAME error for frame error, parity error and FIFO overflow\n\t\t\t\t\t\t\t\t\t\t as the RTIOStream doesnt have capability to differentiate between errors */\n\t}\n\t*sizeCharsRcvd = charsRcvd;\n\treturn NOERROR;\n}\n\nvoid sci_xmit_external_mode(char* pmsg, int msglen)\n{\n\tint i;\n    #if MW_EXTMODE_SCIMODULE == 0\n\tfor (i = 0; i < msglen; i++) {\n\t\twhile (SciaRegs.SCIFFTX.bit.TXFFST == MW_PIL_SCIFIFOLEN) {} /* The buffer is full */\n        #ifdef F2837X_REG_FORMAT\n        SciaRegs.SCITXBUF.bit.TXDT = __byte(pmsg, i);\n        #else\n\t\tSciaRegs.SCITXBUF = __byte(pmsg, i);\n        #endif\n\t}\n    #elif MW_EXTMODE_SCIMODULE == 1\n\tfor (i = 0; i < msglen; i++) {\n\t\twhile (ScibRegs.SCIFFTX.bit.TXFFST == MW_PIL_SCIFIFOLEN) {} /* The buffer is full */\n        #ifdef F2837X_REG_FORMAT\n        ScibRegs.SCITXBUF.bit.TXDT = __byte(pmsg, i);\n        #else\n\t\tScibRegs.SCITXBUF = __byte(pmsg, i);\n        #endif\n\t}\n    #elif MW_EXTMODE_SCIMODULE == 2\n\tfor (i = 0; i < msglen; i++) {\n\t\twhile (ScicRegs.SCIFFTX.bit.TXFFST == MW_PIL_SCIFIFOLEN) {} /* The buffer is full */\n        #ifdef F2837X_REG_FORMAT\n        ScicRegs.SCITXBUF.bit.TXDT = __byte(pmsg, i);\n        #else\n\t\tScicRegs.SCITXBUF = __byte(pmsg, i);\n        #endif\n\t}\n    #elif MW_EXTMODE_SCIMODULE == 3\n\tfor (i = 0; i < msglen; i++) {\n\t\twhile (ScidRegs.SCIFFTX.bit.TXFFST == MW_PIL_SCIFIFOLEN) {} /* The buffer is full */\n        #ifdef F2837X_REG_FORMAT\n        ScidRegs.SCITXBUF.bit.TXDT = __byte(pmsg, i);\n        #else\n\t\tScidRegs.SCITXBUF = __byte(pmsg, i);\n        #endif\n\t}\n    #endif\n\n}\n/* LocalWords:  ADDR rx tx GPIO SCIRXDA SCITXDA SCIRXDB SCITXDB SCIRXDC SCITXDC SCIRXDD SCITXDD rcv XD rambldata ramfuncs\n * LocalWords:  blramfuncs que ISR SCIRXINTA SCIA SCIRXINTB SCIB SCIRXINTC SCIC SCIRXINTD SCID BYT UART Rcvd LOSPCP LSPCLK\n * LocalWords:  SYSC Lk SciaRegs ScibRegs ScicRegs ScidRegs SCICTL SWRESET Revc RTIO doesnt\n */\n"},{"name":"ssc_ml_fun.h","type":"header","group":"other","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCDC_Buck/DC//DC_Buck_PLANT/Solver Configuration'.\r\n */\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SSC_ML_FUN_H\r\n#define SSC_ML_FUN_H                   1\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n};\r\n\r\n#endif\r\n"},{"name":"xcp.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_calibration.h\"\n#include \"xcp_mem.h\"\n\n\n/*****************************************************************************\n    Internal Global variables\n******************************************************************************/\n/* Initialization status */\nstatic boolean_T initialized = false;\n\n/** Current Status of the XCP Slave according to the Protocol Layer */\nstatic XcpStatus xcpStatus = XCP_DISCONNECTED;\n\n/** Current Session Status of the XCP Slave according to the Protocol Layer\n(see XCP Session Status bit masks) */\nstatic uint8_T xcpSessionStatus;\n\n/** XCP Slave Resource Protection Status (see XCP Resource bit masks) */\nstatic uint8_T xcpResourceProtectionStatus;\n\n/** XCP Session configuration Id\n@note xcpSessionConfigurationId has to be set with an XCP SET_REQUEST\n      before a STORE_DAQ_REQ set. This allows the master device to verify that\n      automatically started DAQ lists contain the expected data transfer\n      configuration.\n      However the (optional) SET_REQUEST command is not supported at the\n      moment, so this value is hard-coded to 0 and never changed. */\nstatic uint16_T xcpSessionConfigurationId = 0;\n\n/** This table contains the list of XcpPacketLookupFunction to be used\n    (for each packets group) to get access to the corresponding\n    Packet Input and Output handlers */\nstatic XcpPacketLookupFunction groupPacketLookup[XCP_PACKETS_GROUP_NUMBER];\n\n/*****************************************************************************\n    Internal Functions\n******************************************************************************/\n/** Free the msgBuffer and allocate a new buffer to host a XCP packet of newPacketSize */\nstatic XcpErrorCode msgBufferRealloc(void **msgBuffer, size_t *msgBufferSize, size_t *packetOffset, size_t newPacketSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    xcpPoolId_T reservedPoolId = xcpTransportCtoReservedMemPoolId();\n\n    /* Free the original buffer */\n    xcpMemFree(*msgBuffer);\n\n    /* Allocate a new buffer with the proper size */\n    *msgBufferSize = xcpTransportMsgBufferSize(newPacketSize, XCP_CTO);\n    *packetOffset = xcpTransportPacketOffset();\n\n    if (*msgBufferSize > 0) {\n        /* Using a reserved memory pool, to guarantee that the reply\n           gets always delivered to the XCP Master */\n        *msgBuffer = xcpMemAllocFromPool(reservedPoolId, *msgBufferSize);\n        if (*msgBuffer == NULL) {\n            errorCode = XCP_NO_MEMORY;\n        }\n    }\n    else {\n        errorCode = XCP_INV_SIZE;\n    }\n\n    return errorCode;\n}\n\n/** Input Packet Handler to be used for packets that need to be discarded */\nstatic XcpProtoErrorCode discardInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Detected attempt to send packet ID %xH when the XCP connection has not been established\\n\", \n               *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    *outputPacketSize = 0;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/** Input Packet Handler to be used for unknown commands */\nstatic XcpProtoErrorCode unknownInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Packet ID  %xH is not supported at the moment\\n\",\n    *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    *outputPacketSize = XCP_ERROR_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_CMD_UNKNOWN;\n}\n\n/** The function returns the Group Id corresponding to a given Packet ID */\nstatic XcpPacketsGroupIdType xcpGetPacketGroupID(uint8_T pid)\n{\n    XcpPacketsGroupIdType groupId = XCP_UNKNOWN_PACKET_GROUP_ID;\n\n    if ((pid >= XCP_STANDARD_PACKETS_ID_MIN) /* && (pid <= XCP_STANDARD_PACKETS_ID_MAX) */) {\n        groupId = XCP_STANDARD_PACKETS_ID;\n    }\n    else if ((pid >= XCP_CALIBRATION_PACKETS_ID_MIN) && (pid <= XCP_CALIBRATION_PACKETS_ID_MAX)) {\n        groupId = XCP_CALIBRATION_PACKETS_ID;\n    }\n    else if ((pid >= XCP_DAQ_PACKETS_ID_MIN) && (pid <= XCP_DAQ_PACKETS_ID_MAX)) {\n        groupId = XCP_DAQ_PACKETS_ID;\n    }\n    else if ((pid >= XCP_PROGRAM_PACKETS_ID_MIN) && (pid <= XCP_PROGRAM_PACKETS_ID_MAX)) {\n        groupId = XCP_PROGRAM_PACKETS_ID;\n    }\n\n    return groupId;\n}\n\n/** Identify the internal packet handler functions responsible for processing a specific XCP packet.\n    @note If the status is XCP_DISCONNECTED, no packets are accepted except XCP_PID_CONNECT\n          If the command is not supported, the XCP slave has to reply with a ERR response packet\n          and ERR_CMD_UNKNOWN error code */\nstatic void xcpGetPacketHandlers(const uint8_T *packet,\n                                 size_t packetSize,\n                                 XcpInputPacketHandler  *inputHandler,\n                                 XcpOutputPacketHandler *outputHandler)\n{\n    /* uint8_T gets promoted to a higher data-type. On C2000, it is \n     * unsigned int. Since data is packed, a non-zero MSB in packet[0]\n     * can then make PID an invalid identifier. Explicitly mask to\n     * remove the upper byte if any.\n     */\n    uint8_T PID = 0x00FF & packet[0]; /* Retrieve Packet ID */\n\n    XCP_UNUSED_PARAM(packetSize);\n\n    if (xcpStatus != XCP_DISCONNECTED) {\n        /* Check if the received XCP packet is supported and\n           retrieve the corresponding handler */\n        XcpPacketsGroupIdType groupId = xcpGetPacketGroupID(PID);\n        boolean_T found = false;\n\n        if (groupId != XCP_UNKNOWN_PACKET_GROUP_ID) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[groupId];\n            const XcpPacketHandlers *packetInfo = NULL;\n\n            if (getPacket != NULL) {\n                packetInfo = getPacket(PID);\n                found = (packetInfo != NULL);\n                if (found) {\n                    *inputHandler = packetInfo->inputHandler;\n                    *outputHandler = packetInfo->outputHandler;\n                }\n            }\n        }\n\n        if (!found) {\n            /* Packet is not supported*/\n            *inputHandler = unknownInputPacketHandler;\n            *outputHandler = genericOutputPacketHandler;\n        }\n    }\n    else {\n        /* If the XCP Slave is in the XCP_DISCONNECTED status,\n        * no other XCP packets are accepted except XCP_PID_CONNECT */\n        if (PID == XCP_PID_CONNECT) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[XCP_STANDARD_PACKETS_ID];\n\n            *inputHandler = NULL;\n            *outputHandler = NULL;\n\n            if (getPacket != NULL) {\n                const XcpPacketHandlers *connect = getPacket(XCP_PID_CONNECT);\n                if (connect != NULL) {\n                    /* Note: if the Protocol layer is correctly configured,\n                       the CONNECT command should be always implemented */\n                    *inputHandler = connect->inputHandler;\n                    *outputHandler = connect->outputHandler;\n                }\n            }\n        }\n        else {\n            /* Input packet must be ignored and discarded */\n            *inputHandler = discardInputPacketHandler;\n            *outputHandler = NULL;\n        }\n    }\n}\n\n/*****************************************************************************\n    Public Functions (shared across different XCP commands)\n******************************************************************************/\nXcpStatus xcpStatusGet(void)\n{\n    return xcpStatus;\n}\n\nvoid xcpStatusSet(XcpStatus status)\n{\n    xcpStatus = status;\n}\n\nuint8_T xcpSessionStatusGet(void)\n{\n    return xcpSessionStatus;\n}\n\nvoid xcpSessionStatusSet(uint8_T status)\n{\n    xcpSessionStatus = status;\n}\n\nvoid xcpSessionStatusSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpSessionStatus, mask);\n}\n\nvoid xcpSessionStatusClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpSessionStatus, mask);\n}\n\nuint8_T xcpResourceProtectionStatusGet(void)\n{\n    return xcpResourceProtectionStatus;\n}\n\nvoid xcpResourceProtectionStatusSet(uint8_T status)\n{\n    xcpResourceProtectionStatus = status;\n}\n\nvoid xcpResourceProtectionSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpResourceProtectionStatus, mask);\n}\n\nvoid xcpResourceProtectionClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpResourceProtectionStatus, mask);\n}\n\nuint16_T xcpSessionConfigurationIdGet(void)\n{\n    return xcpSessionConfigurationId;\n}\n\nvoid xcpSessionConfigurationIdSet(uint16_T id)\n{\n    xcpSessionConfigurationId = id;\n}\n\nvoid genericOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XCP_UNUSED_PARAM(packetSize);\n\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Send back a generic RES packet */\n        XcpGenericResPacketFrame *frame = (XcpGenericResPacketFrame *)packet;\n        frame->PID = XCP_PID_RES;\n    }\n    else {\n        XcpErrorPacketFrame *frame = (XcpErrorPacketFrame *)packet;\n        frame->PID = XCP_PID_ERR;\n\n        switch (inputCode) {\n        case XCP_PROTO_MEMORY_OVERFLOW:\n            frame->errorCode = XCP_ERR_MEMORY_OVERFLOW;\n            break;\n        case XCP_PROTO_SEQUENCE_ERROR:\n            frame->errorCode = XCP_ERR_SEQUENCE;\n            break;\n        case XCP_PROTO_OUT_OF_RANGE:\n            frame->errorCode = XCP_ERR_OUT_OF_RANGE;\n            break;\n        case XCP_PROTO_CMD_UNKNOWN:\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n            break;\n        case XCP_PROTO_SYNCH:\n            frame->errorCode = XCP_ERR_CMD_SYNC;\n            break;\n        case XCP_PROTO_WRITE_PROTECTED:\n            frame->errorCode = XCP_ERR_WRITE_PROTECTED;\n            break;\n        case XCP_PROTO_CMD_SYNTAX:\n            frame->errorCode = XCP_ERR_CMD_SYNTAX;\n            break;\n        case XCP_PROTO_DAQ_ACTIVE:\n            frame->errorCode = XCP_ERR_DAQ_ACTIVE;\n            break;\n        case XCP_PROTO_MODE_NOT_VALID:\n            frame->errorCode = XCP_ERR_MODE_NOT_VALID;\n            break;\n        case XCP_PROTO_DAQ_CONFIG_ERROR:\n            frame->errorCode = XCP_ERR_DAQ_CONFIG;\n            break;\n        case XCP_PROTO_BUSY:\n            frame->errorCode = XCP_ERR_CMD_BUSY;\n            break;\n        case XCP_PROTO_ACCESS_DENIED:\n            frame->errorCode = XCP_ERR_ACCESS_DENIED;\n            break;\n        case XCP_PROTO_SEGMENT_UNKNOWN:\n            frame->errorCode = XCP_ERR_SEGMENT_NOT_VALID;\n            break;\n        case XCP_PROTO_PAGE_UNKNOWN:\n            frame->errorCode = XCP_ERR_PAGE_NOT_VALID;\n            break;\n        case XCP_PROTO_GENERIC_ERROR:\n            frame->errorCode = XCP_ERR_GENERIC;\n            break;\n        default:\n            /* This should never happen */\n            XCP_PRINTF(\"genericOutputPacketHandler error: %xH input code is not supported\", inputCode);\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n        }\n    }\n}\n\n\nconst XcpPacketHandlers* xcpFindPacket(XcpRxPidCode pid, const XcpPacketHandlers* packets, size_t packetsNumber)\n{\n    const XcpPacketHandlers* packet = NULL;\n\n    if (packets != NULL) {\n        size_t i = 0;\n        for (i = 0; (i < packetsNumber) && (packet == NULL); i++) {\n            if (pid == packets[i].PID) {\n                packet = &packets[i];\n            }\n        }\n    }\n\n    return packet;\n}\n\n/*****************************************************************************\n    Public Functions (implementing the Protocol Layer interface)\n******************************************************************************/\nXcpErrorCode xcpInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XCP_UNUSED_PARAM(argc);\n    XCP_UNUSED_PARAM(argv);\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpInit: protocol layer already initialized\\n\");\n\n    /* Initialize Standard Commands support */\n    xcpStandardInit();\n    groupPacketLookup[XCP_STANDARD_PACKETS_ID] = xcpStandardGetPacketLookup();\n\n    /* Initialize DAQ lists (and STIM) support */\n    xcpDaqInit();\n    groupPacketLookup[XCP_DAQ_PACKETS_ID] = xcpDaqGetPacketLookup();\n\n    /* Initialize Calibration support */\n    xcpCalibrationInit();\n    groupPacketLookup[XCP_CALIBRATION_PACKETS_ID] = xcpCalibrationGetPacketLookup();\n\n    initialized = true;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpRun(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *msgBuffer = NULL;\n    size_t   msgBufferSize = 0;\n    size_t   packetOffset = 0;\n    size_t   packetSize = 0;\n    size_t   outputPacketSize = 0;\n    uint8_T *packet = NULL;\n    XcpInputPacketHandler  inputHandler  = NULL;\n    XcpOutputPacketHandler outputHandler = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpRun: protocol layer not initialized\\n\");\n\n    /* Extract a packet from the transport layer */\n    errorCode = xcpTransportRxPacketGet(XCP_TRANSPORT_RX_DEFAULT_QUEUE,\n                                       (void**)&msgBuffer, &msgBufferSize,\n                                       &packetOffset, &packetSize);\n    if ((errorCode != XCP_SUCCESS) &&\n        (errorCode != XCP_PKT_OUT_OF_SEQUENCE) && /* If a wrong packet counter is detected,       */\n        (errorCode != XCP_PKT_LOST)) {            /* the packet content is still considered valid */\n        goto error;\n    }\n\n    /* Check buffer sizes and retrieve the pointer to the XCP packet area */\n    if ((msgBuffer == NULL) || ((packetOffset + XCP_IN_HW_AG(packetSize)) > msgBufferSize)) { \n        errorCode = XCP_INV_SIZE;\n        goto error;\n    }\n\n    /* Identify the handler suitable for processing the given XCP packet */\n    packet = msgBuffer + packetOffset;\n    xcpGetPacketHandlers(packet, packetSize, &inputHandler, &outputHandler);\n\n    /* An input handler needs to be always present */\n    if (inputHandler == NULL) {\n        XCP_PRINTF(\"xcpRun: missing input handler for packet ID %xH\", packet[0]);\n        errorCode = XCP_ERROR;\n        goto error;\n    }\n\n    /* Process input packet */\n    protoErrorCode = inputHandler(msgBuffer, packetOffset, &outputPacketSize);\n\n    if ((outputHandler != NULL) && (outputPacketSize > 0)) {\n        errorCode = XCP_SUCCESS;\n\n        /* An Output Packet needs to be generated -> check if current message buffer is big enough for the response packet */\n        if (packetSize < outputPacketSize) {\n            errorCode = msgBufferRealloc((void **)&msgBuffer, &msgBufferSize, &packetOffset, outputPacketSize);\n        }\n\n        XCP_MEMSET(packet, 0, XCP_IN_HW_AG(packetSize));\n\n        if (errorCode == XCP_SUCCESS) {\n            /* Fill the response packet */\n            packet = msgBuffer + packetOffset;\n            outputHandler(protoErrorCode, packet, outputPacketSize);\n\n            /* Send the response back to the Transport Layer\n               @note to guarantee the maximum responsiveness even when the TX traffic\n                     is maxed out, the highest priority queue is used */\n            errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                                XCP_TRANSPORT_NOT_A_DAQ,\n                                                msgBuffer, msgBufferSize,\n                                                packetOffset, outputPacketSize);\n            if (errorCode != XCP_SUCCESS) {\n                goto error;\n            }\n        }\n    }\n\n    return errorCode;\n\nerror:\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEvent(XcpEventIdType eventId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint32_T timestamp = 0;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    timestamp = (uint32_T)XCP_TIMESTAMP_GET();\n    \n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventExternalTimestamp(XcpEventIdType eventId, uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventNotificationReq(XcpEventCode eventCode, const void *eventData, size_t eventDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxEventDataSize = xcpTransportMaxCtoSize() - XCP_EVENT_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((eventDataSize > 0) && (eventData == NULL), XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventData buffer\\n\");\n    XCP_ERROR_IF(eventDataSize > maxEventDataSize, XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = eventDataSize + XCP_EVENT_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpEventPacketFrame *frame = (XcpEventPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the EV packet information */\n        frame->PID = XCP_PID_EV;\n        frame->eventCode = eventCode;\n\n        if (eventDataSize > 0) {\n            uint8_T *packetEventData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_EVENT_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetEventData, eventData, XCP_IN_HW_AG(eventDataSize));\n        }\n\n        /* Send the EV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Master, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpRemoteServiceReq(XcpReqServiceCode serviceReqCode, const void *serviceReqData, size_t serviceReqDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxServiceReqDataSize = xcpTransportMaxCtoSize() - XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((serviceReqDataSize > 0) && (serviceReqData == NULL), XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqData buffer\\n\");\n    XCP_ERROR_IF(serviceReqDataSize > maxServiceReqDataSize, XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = serviceReqDataSize + XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpServiceReqPacketFrame *frame = (XcpServiceReqPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the SERV packet information */\n        frame->PID = XCP_PID_SERV;\n        frame->serviceReqCode = serviceReqCode;\n\n        if (serviceReqDataSize > 0) {\n            uint8_T *packetServiceReqData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetServiceReqData, serviceReqData, XCP_IN_HW_AG(serviceReqDataSize));\n        }\n\n        /* Send the SERV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Master, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpStatus xcpGetStatus(void)\n{\n    return xcpStatus;\n}\n\nXcpErrorCode xcpReset(void)\n{\n    if (!initialized) {\n        XCP_PRINTF(\"xcpReset: protocol layer already reset\\n\");\n        /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Reset Calibration support */\n    xcpCalibrationReset();\n\n    /* Reset DAQ lists (and STIM) support */\n    xcpDaqReset();\n\n    /* Reset Standard Commands support */\n    xcpStandardReset();\n\n    XCP_MEMSET((void*)groupPacketLookup, 0, sizeof(groupPacketLookup));\n\n    initialized = false;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler)\n{\n    XcpErrorCode errCode;\n\n    /* Forward registration to DAQ list */\n    errCode = xcpDaqSetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n\n    return errCode;\n}\n\nXcpErrorCode xcpGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler)\n{\n    XcpErrorCode errCode;\n    \n    /* Forward query to DAQ list */\n    errCode = xcpDaqGetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n    \n    return errCode;\n}\n\n\n#ifndef XCP_DAQ_SUPPORT\n\nvoid xcpDaqInit(void) {}\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void) {return NULL;}\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp) {XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(timestamp); return XCP_SUCCESS;}\nboolean_T xcpResetDaqListStatus(void) {return true;}\nboolean_T xcpDaqLock(void) {return true;}\nvoid xcpDaqUnlock(void) {}\nvoid xcpDaqReset(void) {}\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\n\n#endif\n\n\n#ifndef XCP_CALIBRATION_SUPPORT\n\nvoid xcpCalibrationInit(void) {}\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void) {return NULL;}\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nvoid xcpCalibrationReset(void) {}\n\n#endif\n"},{"name":"xcp_calibration.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2017-2020 The MathWorks, Inc.\n*\n* File: xcp_calibration.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer Calibration support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_calibration.h\"\n\n#ifdef XCP_CALIBRATION_SUPPORT\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n#include \"xcp_calibration_ext.h\"\n#endif\n\n#include \"xcp_types.h\"\n#include \"xcp_calibration_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_transport_internal.h\"\n\n/*****************************************************************************\n    Internal Functions specific to Calibration support\n******************************************************************************/\nstatic boolean_T isValidShortDownloadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size <= ((maxCtoSize - 8) / addressGranularity));\n}\n\n#if XCP_SET_MTA_ENABLE == 1\n    static boolean_T isValidDownloadSize(uint8_T size)\n    {\n        size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        \n        return ( (size >= 1)  && (size <= (maxCtoSize-2) / addressGranularity ) );\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/** memcpy function used to copy data from packet to MTA address */\nstatic void xcpMemcpyToMTA(uint8_T *packet, uint8_T size)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"writing at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T dstOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    dstOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    xcpMemcpyByte(xcpMTARawPointer, dstOffsetBytes, packet, 0, size);\n}\n#else\n    XCP_MEMCPY(xcpMTARawPointer, packet, size);\n#endif\n}\n\n/*****************************************************************************\n    XCP DOWNLOAD\n******************************************************************************/\n#if XCP_SET_MTA_ENABLE == 1\n    static XcpProtoErrorCode downloadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize)\n    {\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpDownloadCmdPacketFrame *frame = (XcpDownloadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidDownloadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n            \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF((xcpMTARawPointer == 0) || (xcpMTARawPointer == NULL), \n            XCP_PROTO_ACCESS_DENIED, (\"DOWNLOAD: invalid address\\n\"));\n\n        XCP_PRINTF(\"DOWNLOAD: \");\n    \n        /* Update the value of the parameter with the data element content */\n        xcpMemcpyToMTA(packet + sizeof(XcpDownloadCmdPacketFrame), (uint8_T)frame->size);\n    \n        /* Post-increment MTA by the frame size in address granularity units */\n        xcpStandardIncrementMta((uint8_T)frame->size);\n        \n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n        return protoErrorCode;\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/*****************************************************************************\n    XCP SHORT_DOWNLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortDownloadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortDownloadCmdPacketFrame *frame = (XcpShortDownloadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidShortDownloadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_DOWNLOAD: invalid address\\n\"));\n\n    XCP_PRINTF(\"SHORT_DOWNLOAD: \");\n\n    /* Update the value of the parameter with the data element content */\n    xcpMemcpyToMTA(packet + sizeof(XcpShortDownloadCmdPacketFrame), (uint8_T)frame->size);\n\n    /* Post-increment MTA by the frame size in address granularity units */\n    xcpStandardIncrementMta((uint8_T)frame->size);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers calibrationSupportedRxPacket[] =\n{\n#if XCP_SET_MTA_ENABLE == 1\n    { XCP_PID_DOWNLOAD,       downloadInputPacketHandler,     genericOutputPacketHandler },\n#endif\n    { XCP_PID_SHORT_DOWNLOAD, shortDownloadInputPacketHandler, genericOutputPacketHandler }\n};\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic calibration commands\n******************************************************************************/\n\n/* Default Calibration Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, calibrationSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(calibrationSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpCalibrationInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       calibration commands */\n    xcpCalibrationSetPacketLookup(getPacket);\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Initialize support for the extended list of calibration commands */\n    xcpCalibrationExtendedInit();\n#endif\n}\n\n\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacket)\n{\n    packetLookup = getPacket;\n}\n\nvoid xcpCalibrationReset(void)\n{\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Reset support for the extended list of calibration commands */\n    xcpCalibrationExtendedReset();\n#endif\n}\n\n#endif\n"},{"name":"xcp_daq.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_daq.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer DAQ Lists (and STIM) support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_daq.h\"\n\n#ifdef XCP_DAQ_SUPPORT\n#include \"xcp_daq_ext.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_types.h\"\n#include \"xcp_daq_types.h\"\n#include \"xcp_mem.h\"\n\n/*****************************************************************************\n    Internal Global variables specific to DAQ support\n******************************************************************************/\n\n/** Dynamic DAQ Lists data structures */\nstatic XcpDaqLists xcpDynamicDaqLists;\n\n/** Number of event threads currently in execution */\nstatic size_t xcpRunningEventCounter = 0;\n\n/** ID of the selected DAQ List on START_STOP_DAQ_LIST command */\n#define XCP_INVALID_DAQ_LIST_ID -1\nstatic int32_T startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n/** Pointer to current ODT entry */\nstatic XcpDaqPtr   xcpCurrentDaq = { 0xFFFF, 0xFF, 0xFF };\n\nstatic XcpEventCustomMemoryManager xcpEventCustomMemoryManager = {XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID, NULL, NULL};\n\n#ifndef XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically enabled\n   for multi-core applications, where it is critical to limit\n   the interference between threads streaming data.\n   For this reason, by default we enable the independent lock\n   of the DAQ list data structures between events */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 1\n#else\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically disabled\n   for single-core bare-metal applications, where it is critical\n   to limit the memory footprint of the target executable.\n   For this reason, by default we disable the independent lock\n   of the DAQ list data structures between events and use a single\n   mutex to protect the DAQ lists data structures */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 0\n#endif\n\n#endif\n\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n/* Mutex protecting against the concurrent access to DAQ Lists data structures */\nstatic XCP_MUTEX_DEFINE(daqLock);\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    boolean_T locked = false;\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_TRY_LOCK(daqLock, xcpRunningEventCounter, locked);\n\n    return locked;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_UNLOCK(daqLock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_LOCK(daqLock, xcpRunningEventCounter);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_UNLOCK(daqLock, xcpRunningEventCounter);\n}\n\n#else\n/* Each XCP event has an independent mutex to protect the read/write access\n   to the DAQ list data structures */\n#ifndef XCP_MAX_EVENT_DATA_NUMBER\n#define XCP_MAX_EVENT_DATA_NUMBER XCP_MAX_EVENT_CHANNEL\n#endif\n\ntypedef struct XcpEventData {\n    XCP_MUTEX_DEFINE(lock);\n} XcpEventData;\n\n/** Array of event-specific data */\nstatic XcpEventData xcpEventData[XCP_MAX_EVENT_DATA_NUMBER];\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n    return true;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\n#endif\n\n\n/*****************************************************************************\n    Internal Functions specific to DAQ support\n******************************************************************************/\n\n/* When enabled, timestamp is required for first ODT in the DAQ list */\n#if XCP_TIMESTAMP_FIXED == 0\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) ((odtNumber == 0) && \\\n            XCP_READ_BIT_VALUE(mode, XCP_DAQ_MODE_TIMESTAMP_MASK))\n#else\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) (odtNumber == 0)\n#endif\n\n/* Incrementing pointer. byteOffset argument will have a valid value only when\n   we are emulating as a BYTE addressable target. Otherwise, it is 0. */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(byteOffset ? (ptr + XCP_IN_HW_AG(incr - 1)) : (ptr + XCP_IN_HW_AG(incr)))\n#else\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(ptr + incr)\n#endif\n\n/* Update byteOffset when emulating as a BYTE addressable target */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) ((offset + size) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER)\n#else\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) 0\n#endif\n\n#define IS_USING_CUSTOM_POOL(x) (x == xcpEventCustomMemoryManager.eventId)\n\nstatic boolean_T isActiveDaqList(uint16_T daqListId)\n{\n    return (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_SELECTED) ||\n           (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_STARTED);\n}\n\nstatic boolean_T noActiveDaqLists(void)\n{\n    boolean_T found = 0;\n    uint16_T i = 0;\n\n    for (i = 0; (i < xcpDynamicDaqLists.daqCount) && !found; i++) {\n        found = isActiveDaqList(i);\n    }\n\n    return !found;\n}\n\nstatic boolean_T isValidDaqPtr(uint16_T daqListId, uint8_T odtId, uint8_T odtEntryId)\n{\n    boolean_T ret = (xcpDynamicDaqLists.daq != NULL) &&\n                    (daqListId < xcpDynamicDaqLists.daqCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt != NULL) &&\n                    (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry != NULL) &&\n                    (odtEntryId < xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount);\n\n    return ret;\n}\n\nstatic boolean_T isValidDaqEntry(uint8_T bitOffset, uint8_T size, uint32_T address)\n{\n    boolean_T ret = false;\n    uint16_T  entrySize = size;     /* cast to 16-bit avoids -Werror=type-limits */\n\n    if (bitOffset == 0xFF) {\n        /* \"Normal\" (non-bitwise) access has been selected */\n        if ( (entrySize <= XCP_MAX_ODT_ENTRY_SIZE) &&\n             (entrySize % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) &&\n             (  address % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) ) {\n            ret = true;\n        }\n    }\n    else {\n        /* Bitwise access has been selected */\n        if ((bitOffset <= 0x1F) && (address % XCP_ODT_ENTRY_SIZE_GRANULARITY) &&\n            (entrySize == XCP_ODT_ENTRY_SIZE_GRANULARITY)) {\n            ret = true;\n        }\n    }\n\n    return ret;\n}\n\n/** The current supported mode includes:\n- alternating = 0\n- direction = 0 (DAQ only)\n- timestamp = 1 or 0\n- PID OFF = 0\n*/\nstatic boolean_T isSupportedDaqListMode(uint8_T mode)\n{\n    #if XCP_TIMESTAMP_FIXED == 0\n        return ( (mode & ~XCP_DAQ_MODE_TIMESTAMP_MASK) == 0 );\n    #else\n        return (mode == XCP_DAQ_MODE_TIMESTAMP_MASK);\n    #endif\n}\n\nstatic boolean_T isValidStartStopMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP) ||\n        (mode == XCP_DAQ_LIST_START) ||\n        (mode == XCP_DAQ_LIST_SELECT))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T isValidStartStopSynchMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP_ALL) ||\n        (mode == XCP_DAQ_LIST_START_SELECTED) ||\n        (mode == XCP_DAQ_LIST_STOP_SELECTED))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T absoluteOdtNumberIdentification(void)\n{\n    return (XCP_ID_FIELD_TYPE == XCP_ID_ABSOLUTE_ODT_NUMBER);\n}\n\n/* Try to allocate a reserved memory pool dedicated to the packets in the DAQ list.\n   @note depending on the configuration of the memory allocator, this may fail\n         so we just set daq->poolId to XCP_INVALID_POOL_ID in that case */\nstatic XcpErrorCode createDaqReservedPool(XcpDaq *daq)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t poolBlockSize = 0;\n    int i = 0;\n\n    /* Calculate the max size for the ODT packets in the given DAQ list */\n    for (i = 0; i < daq->odtCount; i++) {\n        /* Calculate the required message buffer size */\n        size_t packetSize = XCP_IN_BYTES(daq->odt[i].size + XCP_IN_AG(XCP_ID_FIELD_SIZE));\n        size_t msgBufferSize = 0;\n\n        if (IS_TIMESTAMP_REQUIRED(daq->mode, i)) {\n            /* The first DTO should also contain the Timestamp info */\n            packetSize += XCP_TIMESTAMP_SIZE;\n        }\n\n        msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_DTO);\n\n        if (msgBufferSize > poolBlockSize) {\n            poolBlockSize = msgBufferSize;\n        }\n    }\n\n    /* Try the allocation of the dedicate pool */\n    errorCode = xcpMemReservedPoolCreate(poolBlockSize,\n                                         XCP_MEM_DAQ_RESERVED_POOL_BLOCKS_NUMBER,\n                                         &daq->poolId);\n    if (errorCode != XCP_SUCCESS) {\n        daq->poolId = XCP_INVALID_POOL_ID;\n    }\n\n    return errorCode;\n}\n\nstatic void destroyDaqReservedPool(XcpDaq *daq)\n{\n    if (daq->poolId != XCP_INVALID_POOL_ID) {\n        xcpMemReservedPoolDestroy(daq->poolId);\n    }\n\n    daq->poolId = XCP_INVALID_POOL_ID;\n}\n\n\n/*****************************************************************************\n    XCP SET DAQ PTR\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqPtrInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqPtrCmdPacketFrame *frame = (XcpSetDaqPtrCmdPacketFrame *) packet;\n    uint16_T daqListId  = (uint16_T)frame->daqListId;\n    uint8_T  odtId      = (uint8_T)frame->odtId;\n    uint8_T  odtEntryId = (uint8_T)frame->odtEntryId;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SET_DAQ_PTR: ODT entry not available (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_PTR: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Everything is fine -> proceed and update the current ODT entry pointer */\n    XCP_PRINTF(\"SET_DAQ_PTR: updating current ODT entry pointer to DAQ %d, ODT %d, Entry %d\\n\",\n               daqListId, odtId, odtEntryId);\n\n    xcpCurrentDaq.daqListId  = daqListId;\n    xcpCurrentDaq.odtId      = odtId;\n    xcpCurrentDaq.odtEntryId = odtEntryId;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP WRITE DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode writeDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpWriteDaqCmdPacketFrame *frame = (XcpWriteDaqCmdPacketFrame *)packet;\n    uint16_T daqListId = xcpCurrentDaq.daqListId;\n    uint8_T  odtId = xcpCurrentDaq.odtId;\n    uint8_T  odtEntryId = xcpCurrentDaq.odtEntryId;\n    XcpOdtEntry *entry = NULL;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_WRITE_PROTECTED,\n        (\"WRITE_DAQ: current ODT entry not available for write operations (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"XCP_WRITE_DAQ: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Check if the Entry values are valid */\n    ok = isValidDaqEntry((uint8_T)frame->bitOffset, (uint8_T)frame->size, (uint32_T)frame->address);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"XCP_WRITE_DAQ: invalid DAQ %d ODT %d Entry %d value: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n         daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address));\n\n    /* Everything is fine -> proceed and write the entry */\n    XCP_PRINTF(\"XCP_WRITE_DAQ: writing DAQ %d ODT %d Entry %d: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n               daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address);\n\n    entry = &(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry[odtEntryId]);\n\n    entry->bitOffset        = (uint8_T)frame->bitOffset;\n    entry->size             = (uint8_T)frame->size;\n    entry->addressExtension = (uint8_T)frame->addressExtension;\n    entry->address          = (uint32_T)frame->address;\n\n    /* After a successful WRITE_DAQ, the xcpDaqPtr odtEntryId needs to be post incremented */\n    xcpCurrentDaq.odtEntryId++;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP SET DAQ LIST MODE\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqListModeInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqListModeCmdPacketFrame *frame = (XcpSetDaqListModeCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    boolean_T ok = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (frame->daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: DAQ list %d not available\\n\", frame->daqListId));\n\n    daqList = &(xcpDynamicDaqLists.daq[frame->daqListId]);\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList((uint16_T)frame->daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_LIST_MODE: DAQ list %d is currently active\\n\", frame->daqListId));\n\n    /* Check if the Event Id is valid */\n    ok = (frame->eventId < XCP_MAX_EVENT_CHANNEL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: invalid event channel Id %d\\n\", frame->eventId));\n\n    /* Check DAQ list priority */\n    ok = (frame->priority == 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: priority not supported, must be zero\\n\"));\n\n    /* Check if DAQ list mode is supported */\n    ok = isSupportedDaqListMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID, (\"SET_DAQ_LIST_MODE: DAQ list mode not supported %xH\\n\", frame->mode));\n\n    /* Everything is fine -> proceed and set the DAQ list mode */\n    XCP_PRINTF(\"SET_DAQ_LIST_MODE: setting DAQ list %d: mode = %xH, eventId = %d, prescaler = %d, priority = %d\\n\",\n        frame->daqListId, frame->mode, frame->eventId, frame->prescaler, frame->priority);\n\n    daqList->mode       = (uint8_T)frame->mode;\n    daqList->eventId    = (uint16_T)frame->eventId;\n    daqList->prescaler  = (uint8_T)frame->prescaler;\n    daqList->priority   = (uint8_T)frame->priority;\n\n    /* Assuming that prescaler = 0 means value that you are not interested in using it */\n    if (daqList->prescaler <= 1)\n        daqList->prescaler = 1;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP START STOP DAQ LIST\n******************************************************************************/\nstatic XcpProtoErrorCode startStopDaqListInputPacketHandler(void   *msgBuffer,\n                                                            size_t  xcpPacketOffset,\n                                                            size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopDaqListCmdPacketFrame *frame = (XcpStartStopDaqListCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    int32_T daqListId = frame->daqListId;\n    boolean_T ok = false;\n    boolean_T locked = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_DAQ_LIST: DAQ list %d not available\\n\", daqListId));\n\n    startStopDaqListId = daqListId;\n    daqList = &(xcpDynamicDaqLists.daq[daqListId]);\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_DAQ_LIST: invalid mode %d selected \\n\", frame->mode));\n\n    /* Assign the Absolute ODT number */\n    if (absoluteOdtNumberIdentification()) {\n        if (daqList->status == XCP_DAQ_INIT) {\n            /* The DAQ list has never been started/stopped/selected before\n            -> PIDs for the ODTs needs to be reserved */\n            if (XCP_READ_BIT_VALUE(daqList->mode, XCP_DAQ_MODE_DIRECTION_MASK)) {\n                /* STIM */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableStimPid +\n                        daqList->odtCount) <= XCP_MAX_STIM_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableStimPid;\n                    xcpDynamicDaqLists.firstAvailableStimPid += daqList->odtCount;\n                }\n            }\n            else {\n                /* DAQ */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableDaqPid +\n                        daqList->odtCount) <= XCP_MAX_DAQ_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableDaqPid;\n                    xcpDynamicDaqLists.firstAvailableDaqPid += daqList->odtCount;\n                }\n            }\n\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: cannot assign PIDs for DAQ list %d \\n\", daqListId));\n        }\n    }\n\n    /* Check the ODT configuration and also if the ODT sizes fits the Max DTO size */\n    if ((frame->mode == XCP_DAQ_LIST_START) || (frame->mode == XCP_DAQ_LIST_SELECT)) {\n        int i = 0;\n\n        ok = true;\n        for (i = 0; (i < daqList->odtCount) && ok; i++) {\n            int j = 0;\n            size_t odtSize = 0;\n\n            /* Calculate the resulting ODT size */\n            for (j = 0; j < daqList->odt[i].entriesCount; j++) {\n                odtSize += daqList->odt[i].entry[j].size;\n            }\n\n            /* Check that the resulting ODT size is valid */\n            if (IS_TIMESTAMP_REQUIRED(daqList->mode, i)){\n                ok = (XCP_IN_BYTES(odtSize + XCP_IN_AG(XCP_ID_FIELD_SIZE)) + XCP_TIMESTAMP_SIZE) <= xcpTransportMaxDtoSize();\n            }\n            else{\n                ok = (XCP_IN_BYTES(odtSize + XCP_IN_AG(XCP_ID_FIELD_SIZE))) <= xcpTransportMaxDtoSize();\n            }\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: in DAQ list %d the ODT entries size is larger than Max DTO size for ODT %d \\n\", daqListId, i));\n\n            /* Update the ODT size */\n            daqList->odt[i].size = odtSize;\n        }\n    }\n\n    /* Everything is fine -> proceed and change the DAQ list status */\n    locked = xcpDaqWriteLock(daqList->eventId);\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: stopping DAQ list %d\\n\", daqListId);\n            daqList->status = XCP_DAQ_STOPPED;\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_START:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: starting DAQ list %d\\n\", daqListId);\n\n            /* daqList->poolId is initialized with XCP_INVALID_POOL_ID in\n               allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            if (daqList->poolId == XCP_INVALID_POOL_ID) {\n                if (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) {\n                    /* Create a reserved memory pool, if not already created */\n                    createPoolError = createDaqReservedPool(daqList);\n                } else if (IS_USING_CUSTOM_POOL(daqList->eventId)) {\n                    /* Forward custom memory information to the memory manager */\n                    createPoolError = xcpMemCustomPoolCreate(\n                                          xcpEventCustomMemoryManager.allocHandler, \n                                          xcpEventCustomMemoryManager.freeHandler,\n                                          &daqList->poolId);\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                daqList->status = XCP_DAQ_STARTED;\n                xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_SELECT:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: selected DAQ list %d\\n\", frame->daqListId);\n            daqList->status = XCP_DAQ_SELECTED;\n            break;\n        }\n\n        xcpDaqWriteUnlock(daqList->eventId);\n\n        *outputPacketSize = XCP_START_STOP_DAQ_LIST_RES_PACKET_SIZE_IN_BYTES;\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_DAQ_LIST: cannot allocate reserved memory pool for the DAQ list\\n\"));\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_DAQ_LIST: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\nstatic void startStopDaqListOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        XcpStartStopDaqListResPacketFrame *frame = (XcpStartStopDaqListResPacketFrame *)packet;\n\n        /* Fill the response */\n        frame->PID      = XCP_PID_RES;\n        frame->firstPid = xcpDynamicDaqLists.daq[startStopDaqListId].firstPid;\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP START STOP SYNCH\n******************************************************************************/\nstatic XcpProtoErrorCode startStopSynchInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopSynchCmdPacketFrame *frame = (XcpStartStopSynchCmdPacketFrame *)packet;\n    boolean_T ok = false;\n    boolean_T locked = false;\n    int32_T i = 0;\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopSynchMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_SYNCH: invalid mode %d selected \\n\", frame->mode));\n\n    /* Check if the DAQ Lists are available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_SYNCH: DAQ lists not available\\n\"));\n\n    /* Everything is fine -> proceed and try to change the DAQ list status */\n\n    /* Need to get the lock to guarantee that they are all done in the same cycle */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n        uint16_T daqListId = 0;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP_ALL:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status != XCP_DAQ_INIT) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            /* update status as there are no more active DAQ list */\n            xcpStatusSet(XCP_CONNECTED);\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            break;\n\n        case XCP_DAQ_LIST_START_SELECTED:\n            /* xcpDynamicDaqLists.daq[i].poolId is initialized with\n               XCP_INVALID_POOL_ID in allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            for (i = 0; (i < xcpDynamicDaqLists.daqCount) && (createPoolError == XCP_SUCCESS); i++) {\n                if ((xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) && \n                    (xcpDynamicDaqLists.daq[i].poolId == XCP_INVALID_POOL_ID)) {\n                    if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) {\n                        /* Create a reserved memory pool, if not already created */\n                        createPoolError = createDaqReservedPool(&xcpDynamicDaqLists.daq[i]);\n                        daqListId = (uint16_T) i;\n                    } else if (IS_USING_CUSTOM_POOL(xcpDynamicDaqLists.daq[i].eventId)) {\n                        /* Allocate custom pool if custom memory functions are\n                           provided for this eventId */\n                        createPoolError = xcpMemCustomPoolCreate(\n                                              xcpEventCustomMemoryManager.allocHandler,\n                                              xcpEventCustomMemoryManager.freeHandler,\n                                              &xcpDynamicDaqLists.daq[i].poolId);\n                    }\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                /* If the allocation went well for all the DAQ lists, start them */\n                for (i = 0; (i < xcpDynamicDaqLists.daqCount); i++) {\n                    if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                        XCP_PRINTF(\"START_STOP_SYNCH: starting DAQ list %d\\n\", i);\n\n                        xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STARTED;\n                        xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                        xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n                    }\n                }\n            }\n            break;\n\n        case XCP_DAQ_LIST_STOP_SELECTED:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n        }\n\n        /* Unlock all the events */\n        xcpDaqUnlock();\n\n        (void)daqListId; /* to suppress unused-but-set-variable when XCP_PRINTF is empty */\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_SYNCH: cannot allocate reserved memory pool for the DAQ list %d\\n\", daqListId));\n\n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_SYNCH: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP GET DAQ PROCESSOR INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqProcessorInfoInputPacketHandler(void   *msgBuffer,\n                                                               size_t  xcpPacketOffset,\n                                                               size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ PROCESSOR INFO\\n\");\n\n    *outputPacketSize =  XCP_GET_DAQ_PROCESSOR_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqProcessorInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqProcessorInfoResPacketFrame *frame = (XcpGetDaqProcessorInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Processor Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n    frame->daqProperties = XCP_DAQ_PROPERTIES_VALUE;\n    frame->maxDaq = XCP_MAX_DAQ;\n    frame->maxEventChannel = XCP_MAX_EVENT_CHANNEL;\n    frame->minDaq = XCP_MIN_DAQ;\n    frame->daqKeyByte = XCP_DAQ_KEY_VALUE;\n\n    XCP_PRINTF(\"* DAQ Properties:    %xH\\n\", frame->daqProperties);\n    XCP_PRINTF(\"* MAX_DAQ:           %d\\n\", frame->maxDaq);\n    XCP_PRINTF(\"* MAX_EVENT_CHANNEL: %d\\n\", frame->maxEventChannel);\n    XCP_PRINTF(\"* MIN_DAQ:           %d\\n\", frame->minDaq);\n    XCP_PRINTF(\"* Daq Key Byte:      %xH\\n\", frame->daqKeyByte);\n}\n\n/*****************************************************************************\n    XCP GET DAQ RESOLUTION INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqResolutionInfoInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ RESOLUTION INFO\\n\");\n\n    *outputPacketSize = XCP_GET_DAQ_RESOLUTION_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqResolutionInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqResolutionInfoResPacketFrame *frame = (XcpGetDaqResolutionInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Resolution Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n\n    /* @note in the current version the same limits apply for DAQ and STIM */\n    frame->daqOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxDaqOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->stimOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxStimOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->timestampMode = XCP_TIMESTAMP_MODE_VALUE;\n    frame->timestampTicks = XCP_TIMESTAMP_TICKS;\n\n    XCP_PRINTF(\"* DAQ ODT Entry size granularity:   %d\\n\",  frame->daqOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max DAQ ODT Entry size:           %d\\n\",  frame->maxDaqOdtEntrySize);\n    XCP_PRINTF(\"* STIM ODT Entry size granularity:  %d\\n\",  frame->stimOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max STIM ODT Entry size:          %d\\n\",  frame->maxStimOdtEntrySize);\n    XCP_PRINTF(\"* Timestamp Mode =                  %xH\\n\", frame->timestampMode);\n    XCP_PRINTF(\"* Timestamp Ticks =                 %d\\n\",  frame->timestampTicks);\n}\n\n/*****************************************************************************\n    XCP FREE_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode freeDaqInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    boolean_T ok = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"FREE_DAQ: clearing existing dynamic DAQ lists\\n\");\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"FREE_DAQ: cannot be carried out as an event was processed\\n\"));\n\n    /* No DAQ lists are running -> XCP_SYNC_DATA_TRANSFER cannot be active anymore */\n    xcpStatusSet(XCP_CONNECTED);\n\n    /* Everything is fine -> send positive response */\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode allocDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocDaqCmdPacketFrame *frame = (XcpAllocDaqCmdPacketFrame *) packet;\n    int32_T daqCount = (uint16_T)frame->daqCount;\n    XcpDaq *daq = NULL;\n    boolean_T ok = false;\n    int i = 0;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = xcpDynamicDaqLists.daq == NULL;\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_DAQ: sequence error detected, DAQ lists already allocated\\n\"));\n\n    /* Check if the number of DAQ lists requested is supported */\n    ok = (daqCount > 0) && (daqCount <= (XCP_MAX_DAQ - XCP_MIN_DAQ));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_DAQ: invalid number of DAQ lists (%d)\\n\", daqCount));\n\n    /* Proceed and allocate the DAQ lists */\n    daq = (XcpDaq *)xcpMemAlloc((size_t) daqCount * sizeof(XcpDaq));\n    XCP_INPUT_PKT_ERROR_IF(daq == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_DAQ: not enough memory to allocate %d DAQ lists\\n\", daqCount));\n\n    XCP_PRINTF(\"ALLOC_DAQ: allocating %d DAQ lists\\n\", daqCount);\n    XCP_MEMSET(daq, 0, (size_t)daqCount * sizeof(XcpDaq));\n\n    /* Make sure that the DAQ lists are available for use */\n    xcpDynamicDaqLists.daq = daq;\n    xcpDynamicDaqLists.daqCount = (uint16_T) daqCount;\n\n    for (i = 0; i < daqCount; i++) {\n        daq[i].poolId = XCP_INVALID_POOL_ID;\n    }\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtCmdPacketFrame *frame = (XcpAllocOdtCmdPacketFrame *)packet;\n    uint16_T daqListId = (uint16_T)frame->daqListId;\n    uint8_T  odtCount  = (uint8_T)frame->odtCount;\n    boolean_T ok = false;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the number of ODTs is valid */\n    ok = (odtCount > 0) && (odtCount <= XCP_MAX_DAQ_ODT_NUMBER);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: invalid number of ODT (%d) for DAQ list id %d\\n\", odtCount, daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, ODT already allocated\\n\"));\n\n    /* Everything is fine -> proceed and allocate the ODTs */\n    xcpDynamicDaqLists.daq[daqListId].odt = (XcpOdt *)xcpMemAlloc(odtCount * sizeof(XcpOdt));\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT: not enough memory to allocate %d ODT in DAQ list %d\\n\", odtCount, daqListId));\n\n    XCP_PRINTF(\"ALLOC_ODT: allocating %d ODTs in DAQ list %d\\n\", odtCount, daqListId);\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt, 0, odtCount * sizeof(XcpOdt));\n\n    xcpDynamicDaqLists.daq[daqListId].odtCount = odtCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT_ENTRY\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtEntryInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtEntryCmdPacketFrame *frame = (XcpAllocOdtEntryCmdPacketFrame *)packet;\n    uint16_T daqListId       = (uint16_T)frame->daqListId;\n    uint8_T  odtId           = (uint8_T)frame->odtId;\n    uint8_T  odtEntriesCount = (uint8_T)frame->odtEntriesCount;\n    boolean_T ok = false;\n\n    /* Check if the DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODTs not allocated\\n\"));\n\n    /* Check if the ODT Id is valid */\n    ok = (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: ODT id %d is out of range\\n\", odtId));\n\n    /* Check if the ODT entries have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODT Entries already allocated\\n\"));\n\n    /* Check if the number of ODT Entries is valid */\n    ok = (odtEntriesCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: invalid number of ODT entries (%d) for ODT %d in DAQ list %d\\n\", odtEntriesCount, odtId, daqListId));\n\n    /* Everything is fine -> proceed and allocate the ODT entries */\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry = (XcpOdtEntry *)xcpMemAlloc(odtEntriesCount * sizeof(XcpOdtEntry));\n\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT_ENTRY: not enough memory to allocate %d ODT in DAQ list %d ODT %d\\n\", odtEntriesCount, daqListId, odtId));\n\n    XCP_PRINTF(\"ALLOC_ODT_ENTRY: allocating %d ODT Entries in DAQ list %d ODT %d\\n\", odtEntriesCount, daqListId, odtId);\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry, 0, odtEntriesCount * sizeof(XcpOdtEntry));\n\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount = odtEntriesCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers daqSupportedRxPacket[] =\n{\n    { XCP_PID_START_STOP_DAQ_LIST,     startStopDaqListInputPacketHandler,     startStopDaqListOutputPacketHandler },\n    { XCP_PID_START_STOP_SYNCH,        startStopSynchInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_GET_DAQ_PROCESSOR_INFO,  getDaqProcessorInfoInputPacketHandler,  getDaqProcessorInfoOutputPacketHandler},\n    { XCP_PID_GET_DAQ_RESOLUTION_INFO, getDaqResolutionInfoInputPacketHandler, getDaqResolutionInfoOutputPacketHandler },\n    { XCP_PID_SET_DAQ_PTR,             setDaqPtrInputPacketHandler,            genericOutputPacketHandler },\n    { XCP_PID_WRITE_DAQ,               writeDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_SET_DAQ_LIST_MODE,       setDaqListModeInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_FREE_DAQ,                freeDaqInputPacketHandler,              genericOutputPacketHandler },\n    { XCP_PID_ALLOC_DAQ,               allocDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT,               allocOdtInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT_ENTRY,         allocOdtEntryInputPacketHandler,        genericOutputPacketHandler },\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic DAQ commands\n******************************************************************************/\n\n/* Default DAQ Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, daqSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(daqSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpDaqInit(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    uint16_T i = 0;\n\n    /* Initialize Event locks */\n    for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        XCP_MUTEX_INIT(xcpEventData[i].lock);\n    }\n#endif\n\n    xcpRunningEventCounter = 0;\n    XCP_MEMSET(&xcpDynamicDaqLists, 0, sizeof(xcpDynamicDaqLists));\n\n    /* Initialize the packet lookup function to support only basic\n       DAQ commands */\n    xcpDaqSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of DAQ commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpDaqExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacket)\n{\n    packetLookup = getPacket;\n}\n\n\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T error = false;\n\n    /* The lock is used to protect against the concurrent execution of XCP commands\n    (within xcpRun()) that can modify the DAQ list data structures */\n    xcpDaqReadLock(eventId);\n\n    if ((xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0)) {\n        uint16_T i = 0;\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n\n        for (i = 0; (i < xcpDynamicDaqLists.daqCount) && !error; i++) {\n            boolean_T txReady = xcpTransportTxReady(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n            XcpTransportQueueType_T txQueue = txReady ? XCP_TRANSPORT_TX_DEFAULT_QUEUE :\n                                                        XCP_TRANSPORT_DEFERRED_TX_QUEUE;\n\n            if (!XCP_READ_BIT_VALUE(daq[i].mode, XCP_DAQ_MODE_DIRECTION_MASK) && /* it's a DAQ list */\n                (daq[i].status == XCP_DAQ_STARTED) &&                            /* it's running */\n                (daq[i].eventId == eventId)) {                                   /* and associated to this event */\n                int j = 0;\n\n            #ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n                if (txReady &&\n                   (daq[i].poolId != XCP_INVALID_POOL_ID)) {\n                    /* If the Tx queue is ready, it is safe to flush the free memory,\n                       so that the deferred free blocks become available for subsequent allocations */\n                    xcpMemReservedPoolFlushFreeMem(daq[i].poolId);\n                }\n            #endif\n\n                /* @note prescaler is not supported at the moment -> we send DTOs every time */\n                for (j = 0; (j < daq[i].odtCount) && !error; j++) {\n                    /* Calculate the required message buffer size */\n                    size_t packetOffset = xcpTransportPacketOffset();\n                    size_t packetSize = 0;\n                    uint8_T *msgBuffer = NULL;\n                    size_t msgBufferSize = 0;\n                    const boolean_T needsTimestamp = IS_TIMESTAMP_REQUIRED(daq[i].mode, j);\n\n                    packetSize = XCP_IN_BYTES(daq[i].odt[j].size + XCP_IN_AG(XCP_ID_FIELD_SIZE));\n                    if (needsTimestamp) {\n                        /* The first DTO should also contain the Timestamp info */\n                        packetSize += XCP_TIMESTAMP_SIZE;\n                    }\n\n                    /* Allocate the message buffer */\n                    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_DTO);\n\n                    if (daq[i].poolId != XCP_INVALID_POOL_ID) {\n                        /* A dedicated memory pool is available */\n                        msgBuffer = (uint8_T *)xcpMemAllocFromPool(daq[i].poolId, msgBufferSize);\n                    } else {\n                        /* No memory pool available, use the Main memory instead */\n                        msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n                    }\n\n                    if (msgBuffer == NULL) {\n                        error = true;\n                        errorCode = XCP_NO_MEMORY;\n                    }\n\n                    if (!error) {\n                        uint8_T *packet = msgBuffer + packetOffset;\n                        int k = 0;\n                    #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                        /* timestamp is always aligned to WORD boundary. Hence, srcOffsetBytes = 0. */\n                        uint8_T srcOffsetBytes = 0;\n                        uint8_T dstOffsetBytes = (XCP_IN_AG(XCP_ID_FIELD_SIZE)) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER;\n                    #else\n                        /* Dummy variable used when we are not emulating as BYTE addressable target */\n                        uint8_T dstOffsetBytes = 0;\n                    #endif\n\n                        /* Fill the Identification Field first\n                         @note this is hard-coded to support absolute ODT number at the moment */\n                        *packet = (uint8_T)(daq[i].firstPid + j);\n                        packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_ID_FIELD_SIZE), dstOffsetBytes);\n\n                        /* Add the timestamp for the first DTO\n                         @note this is hard-coded to support timestamp size of 4 bytes */\n                        if (needsTimestamp) {\n                        #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                            xcpMemcpyByte(packet, dstOffsetBytes, &timestamp, srcOffsetBytes, XCP_IN_HW_BYTES(sizeof(timestamp)));\n                        #else\n                            XCP_MEMCPY(packet, &timestamp, sizeof(timestamp));\n                        #endif\n\n                            packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_TIMESTAMP_SIZE + dstOffsetBytes), dstOffsetBytes);\n                            dstOffsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(dstOffsetBytes, XCP_IN_AG(XCP_TIMESTAMP_SIZE));\n                        }\n                        if (!IS_USING_CUSTOM_POOL(eventId)) {\n                            /* Finally copy the ODT entries values */\n                            for (k = 0; k < daq[i].odt[j].entriesCount; k++) {\n                                XcpOdtEntry *entry = &(daq[i].odt[j].entry[k]);\n                                uint8_T *address = XCP_ADDRESS_GET(entry->addressExtension, entry->address);\n\n                                if (daq[i].odt[j].entry[k].bitOffset != 0xFF) {\n                                    /* Bitwise access has been selected */\n                                #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                                    uint32_T dword;\n                                    uint8_T bitValue;\n                                    srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n                                    xcpMemcpyByte(&dword, 0, address, srcOffsetBytes, 4);\n                                    bitValue = (uint8_T) ((dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n                                    xcpMemcpyByte(packet, dstOffsetBytes, &bitValue, 0, entry->size);\n                                #else\n                                    uint32_T *dword = (uint32_T *)address;\n                                    *packet = (uint8_T) ((*dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n                                #endif\n                                }\n                                else {\n                                    /* 'Normal' (non-bitwise) access has been selected */\n                                #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                                    srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n                                    xcpMemcpyByte(packet, dstOffsetBytes, address, srcOffsetBytes, entry->size);\n                                #else\n                                    XCP_MEMCPY(packet, address, entry->size);\n                                #endif\n                                }\n                            \n                                packet = XCP_HW_PTR_INCREMENT(packet, entry->size + dstOffsetBytes, dstOffsetBytes);\n                                dstOffsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(dstOffsetBytes, entry->size);\n                        \n                            }\n                        }\n                        \n                        /* Send the response back to the Transport Layer */\n                        errorCode = xcpTransportTxPacketSet(txQueue,\n                                                            i,\n                                                            msgBuffer, msgBufferSize,\n                                                            packetOffset, packetSize);\n                        if (errorCode != XCP_SUCCESS) {\n                            xcpMemFree(msgBuffer);\n                        }\n                    }\n                }\n                if (txReady) {\n                    /* Trigger the transmission of the packets that have been enqueued\n                       for this DAQ list */\n                    xcpTransportTxTrigger(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                }\n            }\n        }\n    }\n\n    xcpDaqReadUnlock(eventId);\n\n    return errorCode;\n}\n\n\nboolean_T xcpDaqLock(void)\n{\n    boolean_T locked = true;\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    locked = xcpDaqWriteLock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        xcpDaqWriteLock(i);\n    }\n#endif\n    return locked;\n}\n\n\n/* Unlock DAQ list transmission */\nvoid xcpDaqUnlock(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    xcpDaqWriteUnlock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        /* Unlock in reverse order, to prevent deadlock */\n    \txcpDaqWriteUnlock(XCP_MAX_EVENT_DATA_NUMBER - 1 - i);\n    }\n#endif\n}\n\n\nboolean_T xcpResetDaqListStatus(void)\n{\n    boolean_T locked = true;\n\n    if (xcpDynamicDaqLists.daq != NULL) {\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n        int32_T  daqCount = xcpDynamicDaqLists.daqCount;\n\n        locked = xcpDaqLock();\n\n        if (locked) {\n            /* No events were processed, it's safe to remove the DAQ lists */\n            int32_T i = 0;\n            int32_T j = 0;\n\n            /* No events are currently running,\n               it's safe to remove the DAQ lists */\n            xcpDynamicDaqLists.daq = NULL;\n            xcpDynamicDaqLists.daqCount = 0;\n            xcpDynamicDaqLists.firstAvailableDaqPid = 0;\n            xcpDynamicDaqLists.firstAvailableStimPid = 0;\n            \n            /* Reset ID of the DAQ List selected by START_STOP_DAQ_LIST command */\n            startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n            /* Let's release the locks */\n            xcpDaqUnlock();\n\n            /* Prepare the Transport Layer for subsequent connections\n               (by resetting the Frame Handler counters and deleting the\n               existing packets in TX/RX fifos) */\n            xcpTransportRestart();\n\n            /* Delete all the Dynamic DAQ data structures and\n               reserved  memory pools */\n            for (i = 0; i < daqCount; i++) {\n                if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) {\n                    destroyDaqReservedPool(&daq[i]);\n                } else if (IS_USING_CUSTOM_POOL(daq[i].eventId)) {\n                    xcpMemCustomPoolDestroy(daq[i].poolId);\n                }\n\n                if (daq[i].odt != NULL) {\n                    for (j = 0; j < daq[i].odtCount; j++) {\n                        if (daq[i].odt[j].entry != NULL) {\n                            xcpMemFree(daq[i].odt[j].entry);\n                        }\n                    }\n\n                    xcpMemFree(daq[i].odt);\n                }\n            }\n\n            xcpMemFree(daq);\n\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n        }\n    }\n\n    return locked;\n}\n\n\nvoid xcpDaqReset(void)\n{\n    xcpResetDaqListStatus();\n\n    /* reset support for the extended list of DAQ commands */\n    xcpDaqExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpDaqSetPacketLookup(NULL);\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    {\n        uint16_T i = 0;\n\n        for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n            XCP_MUTEX_INIT(xcpEventData[i].lock);\n        }\n    }\n#endif\n}\n\n\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler)\n{\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    xcpEventCustomMemoryManager.eventId = eventId;\n    xcpEventCustomMemoryManager.allocHandler = allocHandler;\n    xcpEventCustomMemoryManager.freeHandler = freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler)\n{\n    if (xcpEventCustomMemoryManager.eventId == XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID) {\n        return XCP_NOT_INITIALIZED;\n    }\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    *eventId = xcpEventCustomMemoryManager.eventId;\n    *allocHandler = xcpEventCustomMemoryManager.allocHandler;\n    *freeHandler = xcpEventCustomMemoryManager.freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\n#ifndef XCP_DAQ_EXTENDED_SUPPORT\n\nvoid xcpDaqExtendedInit(void) {}\nvoid xcpDaqExtendedReset(void) {}\n\n#endif\n\n#endif\n"},{"name":"xcp_drv_rtiostream.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\platform\\default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_drv_rtiostream.c\n*\n* Abstract:\n*  Implementation of XCP driver based on rtIOStream\n*/\n\n#include \"rtiostream.h\"\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_drv.h\"\n\n#define INVALID_DRV_ID  -1\n\n/* Timeout expected for the reception of a packet, once the reception has started */\nstatic const uint32_T XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS  = 10000000L;  /* 10s */\n\n/* Delay before attempting the reception of new data */\nstatic const uint32_T XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n/* Timeout expected for the transmission of a packet, once the transmission has started */\nstatic const uint32_T XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS = 2000000L;   /* 2s */\n\n/* Delay before attempting the transmission of new data */\nstatic const uint32_T XCP_SEND_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n\n/* According to the XCP standard, the XCP slave only supports the connection\n   with one XCP Master at a time. The active connection is identified by\n   a specific drvID */\nstatic int drvID = INVALID_DRV_ID;\n\n\n/* If set to true, force the xcpDrvSend and xcpDrvRecv APIs to be blocking */\nstatic boolean_T  forceBlocking = false;\n\n\nXcpErrorCode xcpDrvOpen(\n    int   argc,\n    void *argv[]\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID != INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvOpen: XCP driver already initialized\\n\");\n        return XCP_ERROR;\n    }\n\n    /* Open the actual communication channel */\n    drvID = rtIOStreamOpen(argc, argv);\n    if (drvID < 0) {\n        XCP_PRINTF(\"xcpDrvOpen: unable to open communication channel\\n\");\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvIoctl(XcpDrvIoctlCommand cmd)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF((cmd != XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP) &&\n                 (cmd != XCP_DRV_FORCE_BLOCKING), XCP_INV_ARG,\n                 \"xcpDrvIoctl: invalid command\\n\");\n\n    forceBlocking = (cmd == XCP_DRV_FORCE_BLOCKING);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvSend(const void *src, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t   sent = 0;\n    size_t sentBytesCounter = 0;\n    uint32_T elapsedTime = 0;\n    const uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(src == NULL, XCP_INV_ARG, \"xcpDrvSend: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvSend: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvSend: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (const uint8_T *)src + sentBytesCounter;\n        ret = rtIOStreamSend(drvID, dataPtr, (size - sentBytesCounter), &sent);\n\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((sent == 0) && (sentBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamSend function\n                   is non-blocking and we haven't started sending data yet */\n                errorCode = XCP_BUSY;\n            } else {\n                /* Send packet in progress, we need to complete it */\n                sentBytesCounter += sent;\n\n                done = (sentBytesCounter >= size) ;\n\n                if (!done) {\n                    if (elapsedTime >= XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_TX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_SEND_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_SEND_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        } else {\n            errorCode = XCP_ERROR;\n        }\n\n        done = done || (errorCode == XCP_BUSY) || (errorCode == XCP_ERROR) ||\n               (errorCode == XCP_PKT_TX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecv(void *dst, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytesCounter = 0;\n    size_t received = 0;\n    uint32_T elapsedTime = 0;\n    uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecv: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvRecv: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecv: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (uint8_T *)dst + receivedBytesCounter;\n\n        ret = rtIOStreamRecv(drvID, dataPtr, (size - receivedBytesCounter), &received);\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((received == 0) && (receivedBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamRecv function\n                   is non-blocking and we haven't started receiving data yet */\n                errorCode = XCP_EMPTY;\n            } else {\n                /* Receive packet in progress, we need to complete it */\n                receivedBytesCounter += received;\n                done = (receivedBytesCounter >= size);\n\n                if (!done) {\n                    if (elapsedTime >= XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_RX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n        \n        done = done || (errorCode == XCP_EMPTY) || (errorCode == XCP_ERROR) ||\n               (errorCode ==  XCP_PKT_RX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecvUnknownSize(void *dst, size_t *size, size_t maxSize)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytes = 0;\n    uint8_T *dataPtr = NULL;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid dst buffer\\n\");\n    XCP_ERROR_IF(size == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid size pointer\\n\");\n    XCP_ERROR_IF(maxSize == 0, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid maxSize\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecvUnknownSize: XCP driver not initialized\\n\");\n\n    dataPtr = (uint8_T *)dst;\n\n    ret = rtIOStreamRecv(drvID, dataPtr, maxSize, &receivedBytes);\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        if (receivedBytes == 0) {\n            /* This will only happen if we haven't yet started receiving data */\n            errorCode = XCP_EMPTY;\n        }\n        else if (receivedBytes <= maxSize) {\n            /* Packet received. Hence, update the actual size */\n            *size = receivedBytes;\n            errorCode = XCP_SUCCESS;\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvClose(void)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID == INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvClose: XCP driver already closed\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    ret = rtIOStreamClose(drvID);\n\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_SUCCESS;\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n"},{"name":"xcp_ext_classic_trigger.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2020-2021 The MathWorks, Inc.\n *\n * File: xcp_ext_classic_trigger.c\n *\n * Abstract:\n *  This file contains the implementation of the External Mode\n *  \"Classic Trigger\" logic.\n *\n */\n\n#include \"xcp_ext_classic_trigger.h\"\n#include \"xcp_ext_common.h\"\n\n#define EXTMODE_TRIG_BASE_RATE_EVENT_ID EXTMODE_BASE_RATE_EVENT_ID\n\n#define DEFAULT_XCP_CLASSIC_TRIGGER_DURATION 1000\n\n\n/* Global variables directly accessible by the XCP Master */\nextmodeEventId_T volatile xcpClassicTriggerEventId = 0;\n\nuint32_T volatile xcpClassicTriggerSignalAddress = 0;\nuint8_T volatile  xcpClassicTriggerSignalAddressExtension = 0;\n\nextmodeClassicTriggerSignal_T volatile xcpClassicTriggerLevel = 0;\n\nuint32_T volatile xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\nuint32_T volatile xcpClassicTriggerHoldOff  = 0;\nint32_T  volatile xcpClassicTriggerDelay    = 0;\n\nXcpClassicTriggerDirection volatile xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\nboolean_T volatile xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\nboolean_T volatile xcpClassicTriggerArmRequest = true;\n#endif\n\nboolean_T volatile xcpClassicTriggerCancelRequest = false;\n\nXcpClassicTriggerSource volatile xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXcpClassicTriggerMode volatile xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\nXcpClassicTriggerStatus volatile xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n\n\nXCP_STATIC extmodeClassicTriggerSignal_T xcpOldSignalValue = 0;\nXCP_STATIC boolean_T                     xcpOldSignalValueAvailable = false;\n\nXCP_STATIC XcpClassicTriggerSource       xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXCP_STATIC boolean_T                     xcpTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpSignalTriggerFired = false;\nXCP_STATIC uint32_T                      xcpTriggerCount = 0;\n\nXCP_STATIC boolean_T                     xcpForcedTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpForceTriggerEnableRequest = false;\n\n/** The function is responsible for sampling the signal trigger value\n    and setting the xcpSignalTriggerFired boolean to true if\n    the trigger signal has the expected transition across the xcpClassicTriggerLevel.\n    The boolean will always be restored back to false by the base rate\n    when the event is acknowledged and the state transition completed.\n    The function is also setting xcpTriggerEnabled to true if no Delay is required. */\nstatic void sampleSignalTrigger(void)\n{\n    extmodeClassicTriggerSignal_T *signal = (extmodeClassicTriggerSignal_T *)\n                                            XCP_ADDRESS_GET(xcpClassicTriggerSignalAddressExtension,\n                                                            xcpClassicTriggerSignalAddress);\n    if ((signal != NULL) &&\n       ((xcpClassicTriggerSignalAddressExtension != 0) ||\n        (xcpClassicTriggerSignalAddress != 0))) {\n        if ((xcpClassicTriggerStatus ==\tXCP_EXTMODE_TRIGGER_ARMED) &&\n            !xcpSignalTriggerFired) {\n            /* Read the new signal value */\n            extmodeClassicTriggerSignal_T signalValue = *signal;\n\n            if (xcpOldSignalValueAvailable) {\n                /* If the trigger is armed and not already fired,\n                   check for the expected transition */\n                boolean_T checkForRising =  (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                boolean_T checkForFalling = (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_FALLING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                if (checkForRising &&\n                   (((signalValue >= xcpClassicTriggerLevel) && (xcpOldSignalValue <  xcpClassicTriggerLevel)) ||\n                    ((signalValue >  xcpClassicTriggerLevel) && (xcpOldSignalValue == xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n                if (checkForFalling &&\n                   (((signalValue < xcpClassicTriggerLevel)  && (xcpOldSignalValue >= xcpClassicTriggerLevel)) ||\n                    ((signalValue == xcpClassicTriggerLevel) && (xcpOldSignalValue >  xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n            }\n\n            /* Update the old signal value. Note: if we just fired, the sampling will start\n               next time the trigger is armed and therefore we reset xcpOldSignalValueAvailable */\n            xcpOldSignalValueAvailable = !xcpSignalTriggerFired;\n            xcpOldSignalValue = signalValue;\n        }\n    }\n}\n\n\n/** The function is executed in the base rate and it is responsible\n    for the handling of the triggering status transitions */\nstatic void updateTriggerStatus(void)\n{\n    /* Process user Arm/Cancel requests common to all states\n       and update the triggerFired variable (depending on the\n       active triggering source) */\n    boolean_T triggerFired = false;\n\n    if (xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) {\n        /* This case deserves a separate handling\n           because we would like the transition to the ARMED status\n           to occur in the same cycle.\n           Since we are already UNARMED, any request to cancel \n           the trigger can be ignored */\n        xcpClassicTriggerCancelRequest = false;\n        xcpSignalTriggerFired = false;\n\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n\n            /* If we are using MANUAL trigger, we want to start \n               firing the trigger event straightaway, e.g.\n               when the user selects ExtModeArmWhenConnect */\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                triggerFired = true;\n            }\n        }\n    } else {\n        /* We are already armed, ignore any request to arm the trigger */\n        xcpClassicTriggerArmRequest = false;\n\n        if (xcpClassicTriggerCancelRequest) {\n            /* No matter what the Status is, a cancel request should\n               always bring the status to UNARMED.\n               We implement the transition here, to avoid code\n               duplication in the states. */\n            xcpTriggerEnabled = false;\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            xcpClassicTriggerCancelRequest = false;\n        } else {\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                /* when manual triggering is selected, we assume that\n                   the trigger event has always been fired when armed */\n                triggerFired = true;\n            } else {\n                /* when signal triggering is selected, we check the status\n                   of the xcpSignalTriggerFired (updated by the\n                   sampleSignalTrigger() logic */\n                triggerFired = xcpSignalTriggerFired;\n                xcpSignalTriggerFired = false;\n            }\n        }\n    }\n\n    /* Handle the remaining state transitions */\n    switch (xcpClassicTriggerStatus) {\n    case XCP_EXTMODE_TRIGGER_UNARMED:\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_ARMED:\n        if (triggerFired) {\n            if ((xcpClassicTriggerDelay > 0) &&\n                (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)) {\n                /* We need to postpone the enabling of the trigger\n                   by xcpClassicTriggerDelay base periods */\n                xcpTriggerCount = (uint32_T) xcpClassicTriggerDelay;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_DELAYED;\n            } else {\n                /* Negative xcpClassicTriggerDelay are ignored.\n                   The parameter is also ignored if the xcpClassicTriggerSource\n                   is XCP_EXTMODE_TRIGGER_MANUAL\n                   If xcpClassicTriggerDelay is 0 we enable the trigger straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_FIRING:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Duration has expired */\n            if (xcpClassicTriggerMode == XCP_EXTMODE_TRIGGER_ONESHOT) {\n                /* In the one-shot scenario we just disable the trigger */\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n            } else {\n                /* In normal mode, we might have to handle the HoldOff and\n                   pause the triggering  */\n                if (xcpClassicTriggerHoldOff > 0) {\n                    xcpTriggerEnabled = false;\n                    xcpTriggerCount = xcpClassicTriggerHoldOff;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_HOLDING_OFF;\n                } else {\n                    if (triggerFired) {\n                        /* If the trigger has been fired, we start another duration\n                           straight away */\n                        xcpTriggerCount = xcpClassicTriggerDuration;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                    } else {\n                        /* We wait for the next trigger to be fired */\n                        xcpTriggerEnabled = false;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n                    }\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_DELAYED:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Delay is over, we can enable the trigger now */\n            if (xcpClassicTriggerDuration > 0) {\n                xcpTriggerEnabled = true;\n                xcpTriggerCount = xcpClassicTriggerDuration;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n            } else {\n                /* If duration is 0, we would never be able to send any data.\n                   This situation should be prevented on the host,\n                   we just handle it gracefully here, in case it happens */\n                XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_HOLDING_OFF:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* HoldOff time has expired */\n            if (triggerFired) {\n                /* If the trigger has been fired, we start another duration\n                   straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            } else {\n                /* We wait for the next trigger to be fired */\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            }\n        }\n        break;\n\n    default:\n        XCP_PRINTF(\"Invalid Trigger Status %d detected\\n\", xcpClassicTriggerStatus);\n        xcpTriggerEnabled = false;\n        xcpSignalTriggerFired = false;\n        xcpClassicTriggerCancelRequest = false;\n        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n    }\n}\n\n\n\nXcpErrorCode xcpExtModeClassicTriggerInit(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n\n    return XCP_SUCCESS;\n}\n\n\n/** The function returns true if the external mode event must be triggered */\nboolean_T xcpExtModeClassicTriggerEnabled(extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* Whenever a change of the xcpClassicTriggerSource is detected\n           the xcpClassicTriggerStatus is reset */\n        boolean_T triggerSrcChangeDetected = (xcpClassicTriggerSource != xcpOldClassicTriggerSource);\n        xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n        if (triggerSrcChangeDetected) {\n            xcpTriggerEnabled     = false;\n            xcpSignalTriggerFired = false;\n            xcpTriggerCount       = 0;\n\n            xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n        }\n\n        /* If XCP_EXTMODE_TRIGGER_SIGNAL is selected we want to start\n           processing the Arm request (or the Hold-off expiration) \n           straightaway and carry out the state transition before \n           sampling for the first time */\n        if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)  &&\n            (((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) &&\n               xcpClassicTriggerArmRequest) ||\n             ((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_HOLDING_OFF) &&\n              (xcpTriggerCount == 1)))) {\n               xcpTriggerCount = 0;\n               xcpClassicTriggerArmRequest = false;\n               xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n        }\n    }\n\n    if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL) &&\n        (eventId == xcpClassicTriggerEventId))  {\n        /* Since we are running at the correct eventID, sample the\n           trigger signal value to determine if the trigger signal\n           needs to be enabled.\n           Note: this will update the boolean straight away and request\n           the state transition (updated at the next base rate) */\n        sampleSignalTrigger();\n    }\n\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* update trigger status to fulfill user requests */\n        updateTriggerStatus();\n\n        /* If the base rate task has run, then reset the\n         * xcpForceTriggerEnableRequest flag.  The state machine\n         * is up to date. */\n        xcpForceTriggerEnableRequest = false;\n    } else if (xcpForceTriggerEnableRequest) {\n        return xcpForcedTriggerEnabled;\n    }\n\n    return xcpTriggerEnabled;\n}\n\n\n/** Reset External Mode classic triggering logic, by restoring the default status */\nXcpErrorCode xcpExtModeClassicTriggerReset(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n    xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerEventId = 0;\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n    xcpForcedTriggerEnabled = false;\n    xcpForceTriggerEnableRequest = false;\n\n    xcpClassicTriggerSignalAddress = 0;\n    xcpClassicTriggerSignalAddressExtension = 0;\n\n    xcpClassicTriggerLevel    = 0;\n    xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\n    xcpClassicTriggerHoldOff  = 0;\n    xcpClassicTriggerDelay    = 0;\n\n    xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\n    xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\n    xcpClassicTriggerArmRequest = true;\n#endif\n\n    xcpClassicTriggerCancelRequest = false;\n\n    xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\n    return XCP_SUCCESS;\n}\n\n\n/** When Manual triggering is enabled, force output of xcpExtModeClassicTriggerEnabled to\n *  match pending Arm or Cancel request for all non-base rate events until requests are \n *  processed at the next base rate event.\n * \n *  In the concurrent execution workflow, it is used to avoid omission\n *  of logging data points if a non-base rate task completes\n *  before the base rate at t = 0.\n * \n *  This is a NO-OP when XCP_EXTMODE_TRIGGER_SIGNAL is active.\n */\nvoid xcpExtModeClassicTriggerForceEnableStatusUpdate(void) {\n    if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n        if (xcpClassicTriggerArmRequest && !xcpClassicTriggerCancelRequest) {\n            /* Force xcpExtModeClassicTriggerEnabled to return true\n            * until the next base rate event. */\n            xcpForcedTriggerEnabled = true;\n            xcpForceTriggerEnableRequest = true;\n        } else if (xcpClassicTriggerCancelRequest & !xcpClassicTriggerArmRequest) {\n            xcpForcedTriggerEnabled = false;\n            xcpForceTriggerEnableRequest = true;\n        } else {\n            xcpForceTriggerEnableRequest = false;\n        }\n    }\n}"},{"name":"xcp_ext_common.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2021 The MathWorks, Inc.\n *\n * File: xcp_ext_common.c\n *\n * Abstract:\n *  This file contains the implementation of the common functionalities\n *  used within the XCP External Mode Platform Abstraction layer.\n *\n *  This includes the handling of absolute simulation time and the global\n *  variables to control the execution of the model on the target\n *  (and accessed remotely via XCP communication protocol).\n */\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n#include <float.h>         /* for DBL_EPSILON */\n#include <math.h>\n#endif\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"xcp.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_cfg.h\"\n\n#include \"rtw_extmode.h\"\n\n\n#ifndef EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS\n/* Dummy delay, that forces the background task to pause the execution\n   and reduces the packets transmission rate. \n   This is useful for host-based targets to prevent the saturation\n   of transmission buffers */\n#define EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS  10L  /* 10us */\n#endif\n\n\n/* XCP Master can 'directly' access these global variables, in order to control\n   the model state machine */\n\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\nboolean_T volatile xcpModelStartRequest = false;\n#else\nboolean_T volatile xcpModelStartRequest = true;\n#endif\nboolean_T volatile xcpModelStopRequest = false;\nXcpExtModeStatus volatile xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n\nuint32_T volatile xcpModelChecksum0   = 0;\nuint32_T volatile xcpModelChecksum1   = 0;\nuint32_T volatile xcpModelChecksum2   = 0;\nuint32_T volatile xcpModelChecksum3   = 0;\nuint32_T volatile xcpModelIntegerCode = 0;\n\n/* Global variable defined when a non-BYTE addressable target is\n   being emulated as a BYTE addressable target. Currently defined \n   only for WORD addressable targets (Eg.:C2000). But, can be\n   extended to DWORD addressable targets */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\nuint8_T volatile xcpEmulateWordTargetAsByteTarget = 1;\n#endif\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\nboolean_T               volatile xcpExtmodeSimulationComplete  = false;\n\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n/* Dummy double variable, required to obtain the size of double data type on the target \n   using the symbols parser. */\nextmodeDouble_T volatile xcpDummyDoubleVariable = (extmodeDouble_T) 0;\n#endif\n\n/* Definition of a dummy printf function */\nvoid xcp_void_printf(const char_T *fmt,...){UNUSED_PARAMETER(fmt);}\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* The mutex is used to protect against the concurrent access to the global\n   variables (related to the simulation time) when xcpExtModeUpdateTime()\n   is executed by different threads.\n   In particular it guarantees that the state of the variables is updated\n   atomically and it is always consistent when the function is executed */\nstatic XCP_MUTEX_DEFINE(xcpExtModeLock);\n\n\nuint32_T xcpCurrentSimulationTimeInTicks[2] = {0};\n\n/* The variable contains the last value of model simulation time \n   received via extmodeEvent() for the Base Rate thread.\n   In particular, the extmodeSimulationTime_T represents absolute time \n   (in baserate ticks)\n   Note: xcpBaseRateSimulationTime is assumed to be monotonically increasing, \n         but a counter overflow could occur */\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n/* When LifeSpan is short, the xcpBaseRateSimulationTime variable could \n  \"overflow earlier than expected\", as the generated code may use only \n  a 16bit counter to store the baserate ticks.\n\n  The purpose of xcpTicksCounterL is to convert the xcpBaseRateSimulationTime \n  into a \"normal\" 32bit variable (and it relies on the EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n  value to understand when the overflow is supposed to occur).\n\n  xcpTicksCounterL and xcpTicksCounterH are then used to obtain \n  the xcpCurrentSimulationTimeInTicks global tick counter */\nXCP_STATIC uint32_T xcpTicksCounterL = 0;\nXCP_STATIC uint32_T xcpTicksCounterH = 0;\n\n/* The variable contains the last value of simulation time converted into a 32 bit\n   value with XCP_TIMESTAMP_UNIT resolution. This variable is only updated when\n   base rate is executed */\nXCP_STATIC uint32_T xcpBaseRateSimulationTimestamp = 0;\n\n#else /* INTEGER_CODE == 0 */\n\nuint32_T xcpCurrentSimulationTimeInMs[2] = {0};\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n#endif\n\n#ifndef XCP_BIG_ENDIAN\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = lsb;\n    dst[1] = msb;\n}\n\n#else /* BIG ENDIAN*/\n\n#define XCP_BYTES_SWAP(value)    ((((value) >> 24) & 0x000000ff)| \\\n                                  (((value) >> 8)  & 0x0000ff00)| \\\n                                  (((value) << 8)  & 0x00ff0000)| \\\n                                  (((value) << 24) & 0xff000000))\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = XCP_BYTES_SWAP(lsb);\n    dst[1] = XCP_BYTES_SWAP(msb);\n}\n\n#endif /* BIG ENDIAN*/\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_MICROSECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000000\n#else\n#error \"Invalid XCP_TIMESTAMP_UNIT value. When Purely Integer code is selected, it must be greater than or equal to XCP_TIMESTAMP_UNIT_1US.\"\n#endif\n\n\nstatic extmodeSimulationTime_T xcpExtModeMaxBaseRateSimulationTime = EXTMODE_MAX_BASE_RATE_SIMULATION_TIME;\n\n\n/* Internal function that updates absolute simulation time variables:\n   - xcpCurrentSimulationTimeInTicks \n   - xcpBaseRateSimulationTime\n   - xcpBaseRateSimulationTimestamp\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n \n   The function returns the 32bit XCP Timestamp counter value \n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n \n   Note: the newTime input represents the model simulation time in base rate ticks */\nstatic uint32_T updateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n    \n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when \n           base rate thread is executed */\n        extmodeSimulationTime_T ticksIncrement;\n        extmodeSimulationTime_T newCounterTicks;\n\n        /* Detect increment (in ticks) */\n        if (newTime >= xcpBaseRateSimulationTime) {\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n        } else {\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n        }\n    \n        /* Update xcpTicksCounterL and xcpTicksCounterH tick counters */\n        newCounterTicks = xcpTicksCounterL + ticksIncrement;\n    \n        if (newCounterTicks < xcpTicksCounterL) {\n            xcpTicksCounterH++;\n        }\n        xcpTicksCounterL = newCounterTicks;\n\n        /* Update absolute simulation time values */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInTicks, xcpTicksCounterL, xcpTicksCounterH);\n\n        /* Save last received base rate simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    \n        /* Update the 32bit XCP Timestamp counter for the base rate, using 32bit unsigned integer arithmetic */\n        xcpBaseRateSimulationTimestamp += ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND;\n\n        timestamp = xcpBaseRateSimulationTimestamp;\n        \n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n            xcpExtmodeSimulationComplete = (xcpTicksCounterL >= xcpExtmodeFinalSimulationTime);\n        }\n    } else {\n        /* For threads different from the base rate, if the execution is\n           really concurrent, the simulationTime value might be different \n           from xcpBaseRateSimulationTime (ahead or behind).\n           The resulting timestamp value is calculated starting from \n           xcpBaseRateSimulationTimestamp and adding/subtracting the \n           difference */\n        extmodeSimulationTime_T ticksIncrement = 0;\n        extmodeSimulationTime_T ticksDecrement = 0;\n        \n        if (xcpExtModeMaxBaseRateSimulationTime < MAX_extmodeSimulationTime_T) {\n            /* If the size of extmodeSimulationTime_T data type allows\n               the representation of numbers bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n               then the newTime value needs to be \"converted\" to just use the same\n               amount of bits as the Base Rate (ClockTick0)\n               Note: this happens for example when ClockTicks are uint16_T and\n               extmodeSimulationTime_T is uint32_T. If the first subrate is half\n               of the base rate then\n                   newTime = ClockTick1 * 2\n               and this time would end up being bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME */\n            newTime = newTime % (xcpExtModeMaxBaseRateSimulationTime + 1);\n        }\n\n        if (newTime >= xcpBaseRateSimulationTime) {\n            /* We need to identify one of the two cases:\n               - newTime is ahead of xcpBaseRateSimulationTime\n               - newTime is behind but an overflow occurred\n             */\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n            ticksDecrement = xcpBaseRateSimulationTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - newTime + 1;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind and an overflow has occurred */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead */\n                ticksDecrement = 0;\n            }\n        } else {\n            /* We need to identify one of the two cases:\n               - newTime is behind of xcpBaseRateSimulationTime\n               - newTime is ahead but an overflow occurred\n             */\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n            ticksDecrement = xcpBaseRateSimulationTime - newTime;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind, as more likely */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead and an overflow has occurred */\n                ticksDecrement = 0;\n            }\n        }\n\n        if (ticksIncrement > 0) {\n            timestamp = xcpBaseRateSimulationTimestamp +\n                        (ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        } else {\n            timestamp = xcpBaseRateSimulationTimestamp -\n                        (ticksDecrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n    \n    return timestamp;\n}\n\n/* Update absolute simulation time variables\n   and detect if the simulation is actually complete\n\n   Note: the newTime input represents the current model simulation time */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    updateTime(newTime, eventId);\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    return updateTime(newTime, eventId);\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* Return value in XCP_TIMESTAMP_UNITs, based on the current model simulation time */\nuint32_T xcpGetTimestamp(void)\n{\n    uint32_T timestamp;\n\n    /* @note: theoretically the base thread could pre-preempt any thread during the\n       read operation. Since the read of a 32bit value may not be atomic\n       in some architectures we have to protect it with a mutex.\n       We may be able to remove this lock if we extend the Platform Abstraction Layer\n       to include atomic read operations */\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n\n    timestamp = xcpBaseRateSimulationTimestamp;\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n\n    return timestamp;\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#else /* INTEGER_CODE == 0 */\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_SECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e9\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e8\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e7\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e6\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e5\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e4\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e3\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e2\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND            1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e12\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e11\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e10\n#else\n#error \"invalid XCP_TIMESTAMP_UNIT value\"\n#endif\n\n\n/* Update absolute simulation time variable xcpCurrentSimulationTimeInMs\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n\n   The function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time in seconds */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when base rate\n           thread is executed, no need to use any lock */\n        real_T   timeInMs = newTime * 1000.0;\n        uint32_T timeInMsL = (uint32_T)fmod(timeInMs, (extmodeSimulationTime_T)MAX_uint32_T + 1);\n        uint32_T timeInMsH = 0;\n\n        if (timeInMs > MAX_uint32_T) {\n            /* cast truncates, rounding to zero */\n            timeInMsH = (uint32_T)(timeInMs / MAX_uint32_T);\n        }\n\n        /* Update absolute simulation time variables */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInMs, timeInMsL, timeInMsH);\n\n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n           xcpExtmodeSimulationComplete = (xcpExtmodeFinalSimulationTime - newTime) <\n                                          (newTime * (DBL_EPSILON));\n        }\n\n        /* Update the current simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    }\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    xcpExtModeUpdateTime(newTime, eventId);\n\n    /* Convert the newTime into the 32 bits XCP Timestamp counter, based on XCP configuration */\n    timestamp = (uint32_T)fmod(newTime * (extmodeSimulationTime_T) XCP_TIMESTAMP_UNITS_PER_SECOND + 0.5, \n                              (extmodeSimulationTime_T)MAX_uint32_T + 1);\n\n    return timestamp;\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* This function is supposed to return the value of the XCP Timestamp in XCP_TIMESTAMP_UNITs.\n   Specifically it is invoked within the xcpEvent().\n   When XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME is defined, both extmodeEvent() and \n   rtExtModeUpload() use xcpEventExternalTimestamp() instead, so we should never hit this function.\n   However we need to provide a dummy implementation as the function is required by the \n   Platform Abstraction Layer. */\nuint32_T xcpGetTimestamp(void)\n{\n#ifndef EXTMODE_CODE_EXEC_PROFILING\n    return 0;\n#else\n    /* Even if not thread-safe, this implementation has been added for backward compatibility \n       as Code Execution Profiling was invoking the xcpEvent() API directly */\n    return xcpExtModeGetUpdatedTimestamp(xcpBaseRateSimulationTime, EXTMODE_BASE_RATE_EVENT_ID);\n#endif\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#endif /* INTEGER_CODE == 1 */\n\n\nXcpErrorCode xcpExtModeInit(void)\n{\n    int_T parNumber = 0;\n    void **parList = NULL;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    XCP_MUTEX_INIT(xcpExtModeLock);\n#endif\n\n    /* Retrieve XCP Transport Layer initialization parameters */\n    xcpTransportGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Transport Layer */\n    errorCode = xcpTransportInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpTransportInit error\\n\");\n        return errorCode;\n    }\n\n    /* Retrieve XCP Protocol Layer initialization parameters */\n    xcpGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Protocol layer */\n    errorCode = xcpInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpInit error: code %d\\n\", errorCode);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeRunBackground(boolean_T flushAllData)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T done = false;\n\n    /* Add a dummy delay, that forces the task to pause the execution\n       (leaving the 'running' state). This gives Simulink the opportunity\n       to run when connecting to host-based targets in External Mode */\n    XCP_SLEEP(0, 0);\n\n    do {\n        boolean_T dataAvailable = false;\n\n        /* Retrieve a new Rx packet from interface */\n        errorCode = xcpTransportRx();\n\n        if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n            XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportRx error, code %d\\n\", errorCode);\n            done = true;\n        } else {\n            dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n        }\n\n        if (!done) {\n            /* Process it within the protocol layer.\n               By checking the return code value, diagnostic info on\n               XCP packet processing can be collected.\n               Every run corresponds to the processing of one single XCP packet */\n            errorCode = xcpRun();\n\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpRun error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (!done) {\n            /* Send one of the pending Tx packets over the network */\n            errorCode = xcpTransportTx();\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportTx error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (flushAllData) {\n#if EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS > 0\n            /* Dummy delay, that forces the background task to pause the execution\n               and reduces the packets transmission rate, for host-based targets. */\n            XCP_SLEEP(0, EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS);\n#endif\n            /* The xcpExtModeRunBackground will continue to process packets until\n               the TX and RX queues are empty or an error occurred. */\n            done = done || !dataAvailable;\n        } else {\n            /* The xcpExtModeRunBackground will only carry out one iteration and then return.\n               The remaining packets will be processed at the next round. */\n            done = true;\n        }\n    } while (!done);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    extmodeRealTime_T elapsedTime;\n    XcpStatus status;\n\n    /* Wait for the XCP master to complete the clean disconnection procedure */\n    status = xcpGetStatus();\n\n    elapsedTime = 0;\n    while ((elapsedTime < EXTMODE_SHUTDOWN_TIMEOUT_IN_MICROSECONDS) &&\n           (status != XCP_DISCONNECTED)) {\n\n        XCP_SLEEP(0, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        elapsedTime += EXTMODE_RETRY_TIME_IN_MICROSECONDS;\n\n        /* Run the XCP Stack to keep the communication 'alive',\n           forcing the flush of all data */\n        xcpExtModeRunBackground(true);\n\n        /* Check the XCP stack status again */\n        status = xcpGetStatus();\n    }\n\n    /* Reset XCP Protocol Layer */\n    errorCode = xcpReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpReset error: code %d\\n\", errorCode);\n    }\n\n    /* Reset XCP Transport Layer */\n    errorCode = xcpTransportReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset error: code %d\\n\", errorCode);\n    }\n\n    /* Restore the global variables to the default value */\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\n    xcpModelStartRequest = false;\n#else\n    xcpModelStartRequest = true;\n#endif\n\n    xcpModelStopRequest = false;\n\n    xcpModelChecksum0   = 0;\n    xcpModelChecksum1   = 0;\n    xcpModelChecksum2   = 0;\n    xcpModelChecksum3   = 0;\n    xcpModelIntegerCode = 0;\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\n    xcpExtmodeSimulationComplete  = false;\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n    XCP_MEMSET(xcpCurrentSimulationTimeInTicks, 0, sizeof(xcpCurrentSimulationTimeInTicks));\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    XCP_MEMSET(xcpCurrentSimulationTimeInMs, 0, sizeof(xcpCurrentSimulationTimeInMs));\n    xcpBaseRateSimulationTime = 0;\n#endif\n\n    return errorCode;\n}\n\n\n"},{"name":"xcp_ext_mode.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2021 The MathWorks, Inc.\n *\n * File: xcp_ext_mode.c\n *\n * Abstract:\n *  The file provides the implementation of the ext_mode.h interface\n *  based on XCP communication protocol\n */\n\n#if !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <string.h>        /* optional for strcmp */\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"ext_mode.h\"\n\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n\n#include \"xcp_ext_classic_trigger.h\"\n\n#ifndef EXTMODE_XCP_MAX_TRIGGER_NUMBER\n#if defined(XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) && (XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0)\n/* If XCP_MEM_DAQ_RESERVED_POOLS_NUMBER is defined, the value of this macro is \n   equal to the number of sample times in the model, so we use this as default\n   value for EXTMODE_XCP_MAX_TRIGGER_NUMBER */\n#define EXTMODE_XCP_MAX_TRIGGER_NUMBER XCP_MEM_DAQ_RESERVED_POOLS_NUMBER\n#else\n#define EXTMODE_XCP_MAX_TRIGGER_NUMBER EXTMODE_MAX_EVENT_ID\n#endif\n#endif /* EXTMODE_XCP_MAX_TRIGGER_NUMBER */\n\n#if (EXTMODE_XCP_MAX_TRIGGER_NUMBER > EXTMODE_MAX_EVENT_ID) || (EXTMODE_XCP_MAX_TRIGGER_NUMBER < 1)\n#error Invalid EXTMODE_XCP_MAX_TRIGGER_NUMBER value.\n#endif\n\nstatic extmodeEventTriggerEnable xcpCustomTriggerFunction[EXTMODE_XCP_MAX_TRIGGER_NUMBER];\n\n#endif\n\n\nextmodeErrorCode_T extmodeParseArgs(int_T   argc,\n                                    const char_T *argv[])\n{\n    extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n#else\n    boolean_T  parseError = false;\n    int_T  count = 1;\n\n    if (argc < 0) {\n        XCP_PRINTF(\"extmodeParseArgs: argc must be a positive number\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if ((argc > 0) && (argv == NULL)) {\n        XCP_PRINTF(\"extmodeParseArgs: invalid argv value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    /*\n     * Parse the External Mode Platform-independent Abstraction Layer parameters.\n     * Let all unrecognized parameters pass through to the XCP External Mode \n     * Platform-specific Abstraction Layer.\n     * NULL out all args handled so that they can ignored by the lower layer.\n     */\n    while (count < argc) {\n        const char_T *option = argv[count++];\n\n        if (option != NULL) {\n            /* final time */\n            if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                const char_T *timeValueString = argv[count++];\n                extmodeSimulationTime_T  timeValue = 0;\n                char_T        stringBuffer[201];\n\n                XCP_MEMSET(stringBuffer, 0, sizeof(stringBuffer));\n\n                sscanf(timeValueString, \"%200s\", stringBuffer);\n                if (strcmp(stringBuffer, \"inf\") == 0) {\n                    timeValue = EXTMODE_SIMULATION_RUN_FOREVER;\n                }\n                else {\n                    char_T tmpString[2];\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n                    int tmpValue;\n\n                    if ((sscanf(stringBuffer, \"%d%1s\", &tmpValue, tmpString) != 1) ||\n                        (tmpValue < 0)) {\n                        XCP_PRINTF(\"External mode final simulation time must be a positive, integer value or inf\\n\");\n                        parseError = true;\n                        break;\n                    }\n                    timeValue = (extmodeSimulationTime_T) tmpValue;\n#else\n                    if ((sscanf(stringBuffer, \"%lf%1s\", &timeValue, tmpString) != 1) ||\n                        (timeValue < (extmodeSimulationTime_T)0)) {\n                        XCP_PRINTF(\"External mode final simulation time must be a positive, real value or inf\\n\");\n                        parseError = true;\n                        break;\n                    }\n#endif\n                }\n                xcpExtmodeFinalSimulationTime = timeValue;\n\n                argv[count - 2] = NULL;\n                argv[count - 1] = NULL;\n            }\n            /* -w (wait for packet from host) option */\n            else if (strcmp(option, \"-w\") == 0) {\n                xcpModelStartRequest = false;\n                argv[count - 1] = NULL;\n            }\n        }\n    }\n\n    if (parseError) {\n        XCP_PRINTF(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n            \"...\\n\\n\");\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n        XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 ticks\\n\");\n#else\n        XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n#endif\n\n        return EXTMODE_INV_ARG;\n    }\n\n    /* Extract XCP specific initialization parameters, by invoking the \n       XCP External Mode Platform-specific Abstraction Layer API */\n    xcpExtModeParseArgs(argc, argv);\n\n    /*\n     * Check for unprocessed (\"unhandled\") args.\n     */\n    {\n        int i;\n        for (i = 1; i<argc; i++) {\n            if (argv[i] != NULL) {\n                XCP_PRINTF(\"Unexpected command line argument: %s\\n\", argv[i]);\n                return EXTMODE_INV_ARG;\n            }\n        }\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\n    return errorCode;\n}\n\n\nextmodeErrorCode_T extmodeInit(RTWExtModeInfo *extmodeInfo, extmodeSimulationTime_T *finalTime)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (extmodeInfo == NULL) {\n        XCP_PRINTF(\"extmodeInit: invalid extmodeInfo\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (finalTime == NULL) {\n        XCP_PRINTF(\"extmodeInit: invalid finalTime variable\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_TIME_NOT_INITIALIZED) {\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1)  || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then EXTMODE_SIMULATION_RUN_FOREVER is assumed, as the Real-time Model\n           structure doesn't contain any final time information when PurelyIntegerCode\n           is selected */\n        xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then the finalTime argument is considered an INPUT */\n        xcpExtmodeFinalSimulationTime = *finalTime;\n#endif\n    }\n    else {\n        /* If the model final simulation time in External Mode has been initialized\n           (e.g.via '-tf ' parameter detected by extmodeParseArgs() or\n            via explicit call of extmodeSetFinalSimulationTime())\n           then the finalTime argument is considered an OUTPUT */\n        *finalTime = xcpExtmodeFinalSimulationTime;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_RUN_FOREVER) {\n        XCP_PRINTF(\"\\n**warning: the simulation will run with no stop time due \"\n            \"to external mode infinite final simulation time.\\n\");\n    }\n\n    /* Initialize the model checksum information */\n    xcpModelChecksum0 = rteiGetChecksum0(extmodeInfo);\n    xcpModelChecksum1 = rteiGetChecksum1(extmodeInfo);\n    xcpModelChecksum2 = rteiGetChecksum2(extmodeInfo);\n    xcpModelChecksum3 = rteiGetChecksum3(extmodeInfo);\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpModelIntegerCode = 1;\n#else\n    xcpModelIntegerCode = 0;\n#endif\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    xcpExtModeClassicTriggerInit();\n\n    /* By default, use Classic Triggering */\n    {\n        unsigned i = 0;\n        for (i = 0; i < EXTMODE_XCP_MAX_TRIGGER_NUMBER; i++) {\n            xcpCustomTriggerFunction[i] = xcpExtModeClassicTriggerEnabled;\n        }\n    }\n#endif\n\n    /* Initialize the platform abstraction layer common services */\n    errorCode = xcpExtModeInit();\n    \n    if (errorCode == XCP_SUCCESS) {\n        xcpModelStatus = XCP_EXTMODE_STATUS_INITIALIZED;\n    }\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeWaitForHostRequest(extmodeRealTime_T timeoutInMicroseconds)\n{\n    extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\n    extmodeRealTime_T elapsedTime = 0;\n    boolean_T timeoutExpired = false;\n    boolean_T waitForHostRequest = !xcpModelStartRequest;\n    xcpModelStatus = XCP_EXTMODE_STATUS_WAITING_TO_START;\n\n    timeoutExpired = (timeoutInMicroseconds == 0) && !xcpModelStartRequest && !xcpModelStopRequest;\n\n    /*\n     * Pause until the XCP master modifies the xcpModelStartRequest value\n     * or a stop request has been issued\n     */\n    while (!xcpModelStartRequest && !xcpModelStopRequest && !timeoutExpired) {\n        XCP_SLEEP(0L, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        elapsedTime += EXTMODE_RETRY_TIME_IN_MICROSECONDS;\n\n        timeoutExpired = (timeoutInMicroseconds != EXTMODE_WAIT_FOREVER) &&\n                         (elapsedTime > timeoutInMicroseconds);\n\n        xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n    }\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_READY_TO_RUN;\n\n    if (timeoutExpired) {\n        errorCode = EXTMODE_TIMEOUT_ERROR;\n    }\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    /* Avoid missing logged data points at t = 0 in concurrent execution workflows. */\n    if (waitForHostRequest) {\n        xcpExtModeClassicTriggerForceEnableStatusUpdate();\n    }\n#endif\n    return errorCode;\n}\n\n\nextmodeErrorCode_T extmodeEvent(extmodeEventId_T eventId, extmodeSimulationTime_T simulationTime)\n{\n    XcpErrorCode errorCode  = XCP_SUCCESS;\n    boolean_T triggerEnable = true;\n\n#if (!defined(INTEGER_CODE) || (INTEGER_CODE == 0)) && (!defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS))\n    if (simulationTime < 0) {\n        XCP_PRINTF(\"extmodeEvent error: invalid simulationTime, must be non-negative\\n\");\n        return EXTMODE_INV_ARG;\n    }\n#endif\n\n    if (eventId > EXTMODE_MAX_EVENT_ID) {\n        XCP_PRINTF(\"extmodeEvent error: invalid eventId (%d), must be less than %d\\n\", eventId, EXTMODE_MAX_EVENT_ID);\n        return EXTMODE_INV_ARG;\n    }\n    \n    if ((xcpModelStatus == XCP_EXTMODE_STATUS_READY_TO_RUN) ||\n        (xcpModelStatus == XCP_EXTMODE_STATUS_INITIALIZED)) {\n        /* Update model status, as soon as the extmodeEvent() gets invoked */\n        xcpModelStatus = XCP_EXTMODE_STATUS_RUNNING;\n    }\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    if ((eventId < EXTMODE_XCP_MAX_TRIGGER_NUMBER) &&\n        (xcpCustomTriggerFunction[eventId] != NULL)) {\n        /* Trigger logic should be applied only when the synchronous\n           data transfer is active */\n        XcpStatus xcpStatus = xcpGetStatus();\n        if (xcpStatus == XCP_SYNC_DATA_TRANSFER) {\n            triggerEnable = xcpCustomTriggerFunction[eventId](eventId);\n        }\n    }\n#endif\n    {\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n        /* Update local absolute time variables*/\n        uint32_T timestampBasedOnSimTime = xcpExtModeGetUpdatedTimestamp(simulationTime, eventId);\n#else\n        /* Update local absolute time variables*/\n        xcpExtModeUpdateTime(simulationTime, eventId);\n#endif\n\n        if (triggerEnable) {\n            XcpEventIdType xcpEventId = (XcpEventIdType) eventId;\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n            /* Notify XCP Stack about the eventId */\n            errorCode = xcpEventExternalTimestamp(xcpEventId, timestampBasedOnSimTime);\n#else\n            /* Notify XCP Stack about the eventId, using the timestamp read\n               from the HW timer supported by XCP Platform Abstraction layer */\n            errorCode = xcpEvent(xcpEventId);\n#endif\n        }\n    }\n\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"extmodeEvent error: code %d\\n\", errorCode);\n    }\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeBackgroundRun(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    errorCode = xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_RESETTING;\n    \n    errorCode = xcpExtModeReset();\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    XCP_MEMSET(xcpCustomTriggerFunction, 0, sizeof(xcpCustomTriggerFunction));\n\n    xcpExtModeClassicTriggerReset();\n#endif\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n    \n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\nboolean_T extmodeStopRequested(void)\n{\n    return xcpModelStopRequest;\n}\n\nboolean_T extmodeStartRequested(void)\n{\n    return xcpModelStartRequest;\n}\n\n\nboolean_T extmodeSimulationComplete(void)\n{\n    return xcpExtmodeSimulationComplete;\n}\n\nextmodeErrorCode_T extmodeGetFinalSimulationTime(extmodeSimulationTime_T *finalTime)\n{\n    if (finalTime == NULL) {\n        XCP_PRINTF(\"extmodeGetFinalSimulationTime: invalid finalTime variable\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_TIME_NOT_INITIALIZED) {\n        XCP_PRINTF(\"extmodeGetFinalSimulationTime: finalTime not initialized\\n\");\n        return EXTMODE_NOT_INITIALIZED;\n    }\n\n    *finalTime = xcpExtmodeFinalSimulationTime;\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetFinalSimulationTime(extmodeSimulationTime_T finalTime)\n{\n#if (!defined(INTEGER_CODE) || (INTEGER_CODE == 0)) && (!defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS))\n    if ((finalTime < 0) && (finalTime != EXTMODE_SIMULATION_RUN_FOREVER)) {\n        XCP_PRINTF(\"extmodeSetFinalSimulationTime: invalid finalTime value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n#endif\n\n    xcpExtmodeFinalSimulationTime = finalTime;\n\n    return EXTMODE_SUCCESS;\n}\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n\nextmodeErrorCode_T extmodeGetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable *triggerEnable)\n{\n    if (eventId >= EXTMODE_XCP_MAX_TRIGGER_NUMBER) {\n        XCP_PRINTF(\"extmodeGetEventTriggerEnable: invalid eventId value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (triggerEnable == NULL) {\n        XCP_PRINTF(\"extmodeGetEventTriggerEnable: invalid triggerEnabled value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    *triggerEnable = xcpCustomTriggerFunction[eventId];\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable triggerEnable)\n{\n    if (eventId >= EXTMODE_XCP_MAX_TRIGGER_NUMBER) {\n        XCP_PRINTF(\"extmodeSetEventTriggerEnable: invalid eventId value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    xcpCustomTriggerFunction[eventId] = triggerEnable;\n    return EXTMODE_SUCCESS;\n}\n\n#else\n\nextmodeErrorCode_T extmodeGetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable *triggerEnable)\n{\n    UNUSED_PARAMETER(eventId);\n\n    if (triggerEnable != NULL) {\n        *triggerEnable = NULL;\n    }\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable triggerEnable)\n{\n    UNUSED_PARAMETER(eventId);\n    UNUSED_PARAMETER(triggerEnable);\n\n    return EXTMODE_SUCCESS;\n}\n\n#endif\n"},{"name":"xcp_ext_param_default_serial.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2018 The MathWorks, Inc.\n *\n * File: xcp_ext_param_default_serial.c     \n *\n * Abstract:\n *  The file provides the implementation of the xcp_ext_param.h \n *  interface specific for the XCP Default Platform Abstraction Layer\n *  for the Serial transport layer.\n */\n\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n#include \"xcp_common.h\"\n#include \"xcp_ext_param.h\"\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\n\n /** Transport Layer initialization parameters \n     @note the default values can be overwritten when parsing the\n           External Mode command line arguments */\nstatic const void* xcpTransportLayerParams[] =\n{\n    \"-port\", \"1\",\n    \"-baud\", \"57600\",\n    \"-verbose\", \"0\",\n};\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\nvoid xcpExtModeParseArgs(int_T argc, const char_T *argv[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n#else\n    if ((argv != NULL) && (argc > 0)) {\n        int_T optionId = 1;\n        uint_T idx;\n\n        while (optionId < argc) {\n            const char_T *option = argv[optionId];\n\n            optionId++;\n\n            if ((option != NULL) && (optionId != argc)) {\n                boolean_T isXcpOption = false;\n\n                for (idx = 0; idx < sizeof(xcpTransportLayerParams)/sizeof(xcpTransportLayerParams[0]); idx = idx + 2){\n                    if (strcmp(option, xcpTransportLayerParams[idx]) == 0) {\n                        xcpTransportLayerParams[idx+1] = argv[optionId];\n                        isXcpOption = true;\n                        break;\n                    }\n                }\n\n                if (isXcpOption) {\n                    /* Mark arguments as \"processed\" */\n                    argv[optionId - 1] = NULL;\n                    argv[optionId] = NULL;\n                }\n                \n                optionId++;\n            }\n        }\n    }\n#endif\n}\n\nvoid xcpTransportGetInitParameters(int_T *parNumber, void **parList[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Transport Layer parameters defined (assuming rtiostream default) */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n#else    \n    if ((parNumber != NULL) && (parList != NULL)) {\n        *parNumber = XCP_ELEMENTS_NUMBER(xcpTransportLayerParams);\n        *parList = (void **) &xcpTransportLayerParams;\n    }\n#endif\n}\n\nvoid xcpGetInitParameters(int_T *parNumber, void **parList[])\n{\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Protocol Layer parameters available at the moment */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n}\n\n\n"},{"name":"xcp_fifo.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\transport\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_fifo.c\n*\n* Abstract:\n*  Implementation of FIFO data structure based on single linked list\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_fifo.h\"\n\n\nvoid xcpFifoInit(struct xcpFifo * fifo)\n{\n    fifo->first = NULL;\n    fifo->last = &(fifo)->first;\n}\n\n\nvoid xcpFifoEnqueue(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = NULL;\n    *(fifo)->last = element;\n    fifo->last = &(element->next);\n}\n\n\nvoid xcpFifoDequeue(struct xcpFifo *fifo, struct xcpFifoEntry **element)\n{\n    *element = fifo->first;\n\n    if (fifo->first != NULL) {\n        fifo->first = fifo->first->next;\n\n        if (fifo->first == NULL)\n            fifo->last = &(fifo)->first;\n    }\n}\n\n\nvoid xcpFifoEnqueueHead(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = (fifo)->first;\n\n    if ((fifo)->first == NULL) {\n        (fifo)->last = &(element->next);\n    }\n\n    (fifo)->first = element;\n}\n\n\nvoid xcpFifoSpliceHead(struct xcpFifo *dstFifo, struct xcpFifo *srcFifo)\n{\n    if (srcFifo->first != NULL) {\n        *(srcFifo->last) = dstFifo->first;\n        dstFifo->first = srcFifo->first;\n         \n        srcFifo->first = NULL;\n        srcFifo->last = &(srcFifo)->first;\n    }\n}\n\n\nboolean_T xcpFifoEmpty(struct xcpFifo *fifo)\n{\n    return ((fifo)->first == NULL);\n}\n\n\nvoid xcpFifoReset(struct xcpFifo * fifo)\n{\n    xcpFifoInit(fifo);\n}\n"},{"name":"xcp_frame_serial.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\transport\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_frame_serial.c\n*\n* Abstract:\n*  XCP Frame Handler implementation for the Serial transport layer.\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_frame_serial.h\"\n#include \"xcp_drv.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_types.h\"\n\n\n/* Frame Handler internal counters */\n#if XCP_SERIAL_USES_CTR\nstatic uintCTR_T txCounter = 0;\nstatic uintCTR_T rxCounter = 0;\nstatic int       firstRxCounterReceived = 0;\n#endif\n\n/* true if the Frame Handler has been successfully initialized */\nstatic boolean_T initialized = false;\n\n/* ID for of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n\nuint16_T xcpSxiHtons(uint16_T hostShort)\n{\n#ifndef XCP_BIG_ENDIAN\n    return hostShort;\n#else\n    return ((hostShort & 0xFF00) >> 8) | ((hostShort & 0x00FF) << 8);\n#endif\n}\n\n\nuint16_T xcpSxiNtohs(uint16_T networkShort)\n{\n    return xcpSxiHtons(networkShort);\n}\n\n#if XCP_SERIAL_USES_CS\n /*\n  * Checksum is calculated for all octets in a target memory location.\n  * length : number of target memory locations.\n  */\n#if XCP_ADDRESS_GRANULARITY == XCP_ADDRESS_GRANULARITY_BYTE\n    uintCS_T xcpSxiChecksum(const void *buffer, uintLEN_T length){\n        const uint8_T *buf = buffer;\n        uintCS_T checkSum = 0;\n        while (length-- > 0) {\n            /* buf is a uint8_T* so endian transformation is not required. */\n            checkSum += *buf++;\n        }\n        return checkSum;\n    }\n#elif XCP_ADDRESS_GRANULARITY == XCP_ADDRESS_GRANULARITY_WORD\n    uintCS_T xcpSxiChecksum(const void *buffer, uintLEN_T length){\n        const uint16_T *buf = buffer;\n        uintCS_T checkSum = 0;\n        while (length-- > 0){\n            checkSum += *buf & 0x00FF;\n            checkSum += (*buf++) >> 8;\n        }\n        return checkSum;\n    }\n#endif\n\n#endif\n\nXcpErrorCode xcpFrameInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpFrameInit: frame handler already initialized\\n\");\n\n    /* Open the XCP driver */\n    errorCode = xcpDrvOpen(argc, argv);\n    if (errorCode == XCP_SUCCESS) {\n#if XCP_SERIAL_USES_CTR\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n#endif\n        initialized = true;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgSend(\n    void    *msgBuffer,  /**< [in] pointer to the base address of the buffer where the message is stored */\n    size_t   msgOffset,  /**< [in] offset (from base address in AG units) where the XCP message frame is stored */\n    size_t   msgSize     /**< [in] size (in AG units) of XCP message frame */\n    )\n{\n    /* This function works properly only if the XCP_SERIAL_HEADER_FORMAT is LEN_WORD_CTR_WORD and \n     * XCP_SERIAL_TAIL_FORMAT is CHECKSUM_WORD.\n     */\n    uint8_T *bufferPtr = NULL;\n    struct XcpHeader *header = NULL;\n    uintLEN_T lengthInBytes = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n#if XCP_SERIAL_USES_CS\n    uintCS_T checksum;\n    struct XcpTail *tail;\n#endif\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(msgSize < sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE), XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgSend: frame handler not initialized\\n\");\n\n    bufferPtr = (uint8_T *) msgBuffer + msgOffset;\n\n    header = (struct XcpHeader *) bufferPtr;\n    lengthInBytes = LenSxiNtoH(header->length);\n\n    if ( ( lengthInBytes == 0 ) ||\n         ( msgSize < ( sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE) + XCP_IN_AG(lengthInBytes) ) )\n       ) {\n        XCP_PRINTF(\"xcpFrameMsgSend: invalid message format detected\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Set the value of the transport layer txCounter immediately before\n     * sending the message so that it reflects the correct order for the\n     * sequence of frames that are sent rather than the sequence in which\n     * they are constructed (which could be different in the case where\n     * there are multiple prioritized queues). */\n    header->counter = CtrSxiHtoN(txCounter);\n#endif\n\n#if XCP_SERIAL_USES_CS\n    tail = (struct XcpTail *) ((char *) header + sizeof(struct XcpHeader) + XCP_IN_AG(lengthInBytes));\n    checksum = CsSxiHtoN(xcpSxiChecksum(header, sizeof(struct XcpHeader) + XCP_IN_AG(lengthInBytes)));\n    XCP_MEMCPY(&tail->cs, &checksum, sizeof(tail->cs));\n#endif\n\n    /* Send the XCP Frame Header\n     * If the xcpDrvSend() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvSend() is non-blocking, the return code could be XCP_SUCCESS or XCP_BUSY.\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_TX_TIMEOUT_ERROR */\n    errorCode = xcpDrvSend(bufferPtr, XCP_SERIAL_HEADER_SIZE);\n    if(errorCode != XCP_SUCCESS){\n        return errorCode;\n    }\n    bufferPtr += XCP_IN_AG(XCP_SERIAL_HEADER_SIZE);\n\n    /* Since have already started sending the packet, we should wait until \n     * the remaining part is sent, or a XCP_PKT_TX_TIMEOUT_ERROR has occurred.\n     * For this reason we force the subsequent xcpDrvRecv to be blocking */\n    xcpDrvIoctl(XCP_DRV_FORCE_BLOCKING);\n\n    /* Send the XCP Packet */\n    errorCode = xcpDrvSend(bufferPtr, lengthInBytes);\n    if(errorCode != XCP_SUCCESS){\n        goto txError;\n    }\n    bufferPtr += XCP_IN_AG(lengthInBytes);\n\n    /* Send the XCP Frame Tail */\n    errorCode = xcpDrvSend(bufferPtr, XCP_SERIAL_TAIL_SIZE);\n    if (errorCode != XCP_SUCCESS){\n        goto txError;\n    }\n\n    /* If successfully sent, the buffer can be freed */\n    if (errorCode == XCP_SUCCESS) {\n        xcpMemFree(msgBuffer);\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Don't increment the counter if the transfer of the packet is delayed\n       due to the transport layer being busy. */\n    if (errorCode != XCP_BUSY) {\n        txCounter++;\n    }\n#endif\n\ntxError:\n    /* The packet has been sent, or an error occurred. In any case\n     * we can restore the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgRecv(\n    void  **msgBuffer,  /**< [out] pointer to the base address of the buffer where the message is stored */\n    size_t  msgOffset,  /**< [in] offset (from base address in AG units) where the XCP message frame is stored */\n    size_t *msgSize     /**< [out] size (in AG units) of the XCP message frame that has been received */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    struct XcpHeader rxHeader;\n    uintLEN_T lengthInBytes = 0;\n    uint8_T *buffer;\n    uint8_T *bufferPtr;\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgSize == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgRecv: frame handler not initialized\\n\");\n\n    /* Receive message header first.\n     * If the xcpDrvRecv() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvRecv() is non-blocking, the return code could be XCP_SUCCESS or XCP_EMPTY\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_RX_TIMEOUT_ERROR */\n    errorCode = xcpDrvRecv(&rxHeader, XCP_SERIAL_HEADER_SIZE);\n    if (errorCode != XCP_SUCCESS) {\n        return errorCode;\n    }\n\n    /* Infer the number of BYTES in the XCP Packet from the received header.\n     * This may not be a multiple of XCP_ADDRESS_GRANULARITY */\n    lengthInBytes = LenSxiNtoH(rxHeader.length);\n    if (lengthInBytes == 0) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: invalid message format detected\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        return errorCode;\n    }\n\n    /* Request to the XCP allocator the memory for the message to be received.\n     * STIM packets are not supported at the moment. For this reason\n     * the XCP Slave can only receive CTOs */\n    buffer = xcpMemAllocFromPool(xcpCtoReservedMemPoolId,\n                msgOffset\n                + XCP_IN_AG(XCP_SERIAL_HEADER_SIZE)\n                + XCP_IN_AG(lengthInBytes)\n                + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE) );\n\n    if (buffer == NULL) {\n        errorCode = XCP_NO_MEMORY;\n        return errorCode;\n    }\n\n    bufferPtr = buffer;\n\n    /* Initialize the header part */\n    XCP_MEMSET(bufferPtr, 0, msgOffset);\n    bufferPtr += msgOffset;\n\n    XCP_MEMCPY(bufferPtr, &rxHeader, sizeof(rxHeader));\n    bufferPtr += sizeof(rxHeader);\n\n    /* Since have already started receiving the packet, we should wait until\n     * the remaining part is received, or a XCP_PKT_RX_TIMEOUT_ERROR has occurred.\n     * For this reason we force the subsequent xcpDrvRecv to be blocking */\n    xcpDrvIoctl(XCP_DRV_FORCE_BLOCKING);\n\n    /* Receive the XCP packet */\n    errorCode = xcpDrvRecv(bufferPtr, lengthInBytes);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: received XCP header, but XCP packet is not available or packet size is incorrect\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        goto rxError;\n    }\n\n    bufferPtr  += XCP_IN_AG(lengthInBytes);\n\n    /* Receive the XCP packet */\n    errorCode = xcpDrvRecv(bufferPtr, XCP_SERIAL_TAIL_SIZE);\n\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: received XCP header and XCP packet, but XCP tail is not available or packet size is incorrect\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        goto rxError;\n    }\n\n    /* The packet has been received, so we can restore\n     * the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    *msgBuffer = buffer;\n    *msgSize = sizeof(rxHeader) + XCP_IN_AG(lengthInBytes) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE);\n\n    return errorCode;\n\nrxError:\n    /* An error occurred while receiving a packet, so we can restore\n     * the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    *msgBuffer = NULL;\n    *msgSize = 0;\n    xcpMemFree(buffer);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameCreateMsg(\n    void        *msgFrame,           /**< [out] pointer to the buffer containing the full message frame */\n    size_t       msgFrameBufferSize, /**< [in]  max size (in AG units) of the buffer where the message frame is copied */\n    size_t      *msgFrameSize,       /**< [out] size (in AG units) of the generated msg frame */\n    size_t       xcpPacketSize       /**< [in]  size (in BYTEs) of the XCP packet. */\n    )\n{\n    struct XcpHeader *header = (struct XcpHeader *) msgFrame;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrame buffer\\n\");\n    XCP_ERROR_IF(msgFrameSize == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameSize pointer\\n\");\n    XCP_ERROR_IF(xcpPacketSize == 0, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid xcpPacketSize\\n\");\n    XCP_ERROR_IF(msgFrameBufferSize < (XCP_IN_AG(xcpPacketSize) + sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE)), XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameBufferSize\\n\");\n\n    /* update XCP header */\n    /* header->length = number of BYTES in the XCP Packet */\n    header->length = LenSxiHtoN((uint16_T)xcpPacketSize);\n\n    *msgFrameSize = XCP_IN_AG(xcpPacketSize) + sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpFrameExtractPacket(\n    const void  *msgFrame,      /**< [in]  pointer to the buffer containing full message frame content */\n    size_t       msgFrameSize,  /**< [in]  size (in AG units) of the full message frame */\n    size_t      *xcpPacketSize  /**< [out] size (in BYTEs) of the XCP packet that has been processed */\n    )\n{\n    const struct XcpHeader *header = (const struct XcpHeader *) msgFrame;\n    uintLEN_T length = 0;\n#if XCP_SERIAL_USES_CTR\n    uintCTR_T counter = 0;\n#endif\n#if XCP_SERIAL_USES_CS\n    const struct XcpTail *tail;\n    uintCS_T checksum = 0;\n#endif\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrame\\n\");\n    XCP_ERROR_IF(xcpPacketSize == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid xcpPacketSize pointer\\n\");\n    XCP_ERROR_IF(msgFrameSize <= sizeof(struct XcpHeader), XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrameSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameExtractPacket: frame handler not initialized\\n\");\n\n    /* Extract info from the received message */\n    length = LenSxiNtoH(header->length);\n#if XCP_SERIAL_USES_CTR\n    counter = CtrSxiNtoH(header->counter);\n#endif\n\n    /* Check message length */\n    if (msgFrameSize != (XCP_IN_AG(length) + XCP_IN_AG(XCP_SERIAL_HEADER_SIZE) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE))) {\n        XCP_PRINTF(\"xcpFrameExtractPacket: Xcp packet has an invalid size\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Check message counter */\n    if (!firstRxCounterReceived) {\n        /* No checks can be carried out the first time */\n        firstRxCounterReceived = 1;\n    }\n    else {\n        if (counter < (rxCounter + 1)) {\n            errorCode = XCP_PKT_OUT_OF_SEQUENCE;\n        }\n        else if (counter >(rxCounter + 1)) {\n            errorCode = XCP_PKT_LOST;\n        }\n    }\n    rxCounter = counter;\n#endif\n\n    /* Verify the checksum */\n#if XCP_SERIAL_USES_CS\n    tail = (const struct XcpTail *) ((const char *) msgFrame + sizeof(struct XcpHeader) + XCP_IN_AG(length));\n    XCP_MEMCPY(&checksum, &tail->cs, sizeof(checksum));\n    checksum = CsSxiNtoH(checksum);\n    XCP_ERROR_IF(checksum != xcpSxiChecksum(header, sizeof(struct XcpHeader) + XCP_IN_AG(length)), XCP_PKT_CHECKSUM_ERROR, \"xcpFrameExtractPacket: invalid checksum\\n\");\n#endif\n    *xcpPacketSize = length;\n\n    return errorCode;\n}\n\n/* Returns the number of BYTEs in an XCP Frame Header */\nsize_t xcpFrameHeaderSize(void)\n{\n    return XCP_SERIAL_HEADER_SIZE;\n}\n\n/* Returns the number of BYTEs in an XCP Tail */\nsize_t xcpFrameTailSize(void)\n{\n    return XCP_SERIAL_TAIL_SIZE;\n}\n\n\nsize_t xcpFrameMaxDtoSize(void)\n{\n    return XCP_MAX_DTO_SIZE;\n}\n\n\nsize_t xcpFrameMaxCtoSize(void)\n{\n    return XCP_MAX_CTO_SIZE;\n}\n\n\nXcpErrorCode xcpFrameRestart(void)\n{\n#if XCP_SERIAL_USES_CTR\n    txCounter = 0;\n    rxCounter = 0;\n    firstRxCounterReceived = 0;\n#endif\n\n    return XCP_SUCCESS;\n}\n\n\nvoid xcpFrameSetCtoReservedMemPoolId(xcpPoolId_T poolId)\n{\n    xcpCtoReservedMemPoolId = poolId;\n}\n\n\nXcpErrorCode xcpFrameReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpFrameReset: frame handler already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Close the actual communication channel */\n    errorCode = xcpDrvClose();\n    if (errorCode == XCP_SUCCESS) {\n#if XCP_SERIAL_USES_CTR\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n#endif\n        initialized = false;\n    } else {\n        XCP_PRINTF(\"xcpFrameReset: xcpDrvClose error\\n\");\n    }\n\n    return errorCode;\n}\n"},{"name":"xcp_mem_default.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\platform\\default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_mem_default.c\n*\n* Abstract:\n*  Implementation of default XCP Slave memory allocator\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_mem_default.h\"\n\n#define PADDING (XCP_MEM_ALIGNMENT-1)\n\n/* Array of XcpMemPoolDescriptor for each block size to allow freeing and\n   allocating blocks.\n\n   @note this includes both the Main Memory area and the Reserved Pools\n         Memory Area */\nstatic XcpMemPoolDescriptor xcpMemPoolDescriptors[XCP_MEM_MAIN_RESERVED_POOL_NUMBER];\n\n/* xcpMemCustomPoolDescriptor stores the custom memory functions to allocate and\n   free memory for a specific memory pool */\nstatic XcpMemCustomPoolDescriptor xcpMemCustomPoolDescriptors[XCP_MEM_CUSTOM_POOL_MAX_NUMBER];\n\n\n/* Main memory chunk from which blocks are allocated using the xcpMemAlloc\n * This may not be aligned to XCP_MEM_ALIGNMENT depending on the compiler \n * and/or build flags.\n * Add padding bytes to the end to enable aligning blocks in xcpMemMainChunk\n * to aligned addresses if needed.\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemMainChunk[XCP_MEM_MAIN_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\n\n/* Reserved pools memory chunk from which pool blocks are allocated using the\n * xcpMemAllocFromPool()\n * Also refer to comments in xcpMemMainChunk\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemReservedPoolsChunk[XCP_MEM_RESERVED_POOLS_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\nstatic size_t  xcpMemReservedPoolsChunkUsedBytes;\n\n/* Mutex to prevent concurrent access to xcpMemPoolDescriptors, xcpMemMainChunk\n   and xcpMemReservedPoolsChunk\n   @note: the insertion/removal of blocks within each reserved pool is protected by a dedicated\n          lock, to reduce the interference between threads in multi-core applications */\nstatic XCP_MUTEX_DEFINE(xcpMemLock);\n\n\n/* Initialize pool's memory chunk, by creating the pool's memory blocks and as a linked list */\nstatic void xcpInitializePoolMemoryArea(uint8_T *memoryPtr, size_t blockSize, size_t blocksNumber)\n{\n    if (memoryPtr != NULL) {\n        XcpMemHeader *p, *prev = NULL;\n        size_t i;\n\n        for(i = 0 ; i < blocksNumber; ++i) {\n            p = (XcpMemHeader*) memoryPtr;\n            p -> next = NULL;\n            p -> poolId = XCP_FREE_POOL_ID;\n            if (prev) {\n                prev -> next = p;\n            }\n            memoryPtr += XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n            prev = p;\n        }\n    }\n}\n\n\nXcpErrorCode xcpMemInit(void)\n{\n    uint8_T poolIdx;\n    uint8_T *memoryPtr = (uint8_T *)XCP_ALIGNED(xcpMemMainChunk);\n\n    XCP_MUTEX_INIT(xcpMemLock);\n\n    /* Initialize Main memory */\n    for(poolIdx = 0; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        size_t blocksCount = xcpMemMainBlocksNumber[poolIdx];\n        size_t blockSize = xcpMemMainBlockSizes[poolIdx];\n\n        xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) memoryPtr;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n        xcpMemPoolDescriptors[poolIdx].poolSize =\n            blocksCount * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n\n        xcpInitializePoolMemoryArea(memoryPtr, blockSize, blocksCount);\n        memoryPtr += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n\n    /* Initialize Reserved pools memory\n       @note since the allocation of the memory pools is dynamic,\n             the creation of the blocks for each pool is deferred\n             and carried out within the xcpMemReservedPoolCreate() */\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        xcpMemPoolDescriptors[poolIdx].head = XCP_FREE_POOL;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].blockSize = 0;\n        xcpMemPoolDescriptors[poolIdx].poolSize = 0;\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n    }\n    \n    for(poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        xcpMemCustomPoolDescriptors[poolIdx].allocHandler = NULL;\n        xcpMemCustomPoolDescriptors[poolIdx].freeHandler = NULL;\n    }\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAlloc(size_t size)\n{\n    uint8_T poolIdx;\n    size_t blockSize = 0;\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* find the first large enough pool */\n    for(poolIdx = 0; poolIdx <  XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        blockSize = xcpMemMainBlockSizes[poolIdx];\n        if ((size <= blockSize) && (xcpMemPoolDescriptors[poolIdx].freeBlocksCount > 0)) {\n            poolHead = xcpMemPoolDescriptors[poolIdx].head;\n            break;\n        }\n    }\n\n    if (!poolHead) { /* size is too large, or there are no more free blocks */\n       XCP_MUTEX_UNLOCK(xcpMemLock);\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolIdx].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolIdx].freeBlocksCount)--;\n    poolHead->poolId = poolIdx;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n}\n\n\nvoid xcpMemFree(void *ptr)\n{\n    if (ptr) {\n        /* the XcpMemHeader cell is 'behind' the user's pointer */\n        XcpMemHeader *hd = (XcpMemHeader*) ((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n        uint8_T poolIdx = hd -> poolId;\n        \n        if (poolIdx >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolIdx < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n            poolIdx = poolIdx - XCP_MEM_CUSTOM_POOLS_OFFSET;\n            if (xcpMemCustomPoolDescriptors[poolIdx].freeHandler) {\n                /* For custom memory pools, protection against concurrent\n                   exclusion must be guaranteed within the custom free method */\n                xcpMemCustomPoolDescriptors[poolIdx].freeHandler((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n            }\n            return;\n        }\n\n        if ((poolIdx == XCP_FREE_POOL_ID) || (poolIdx >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)){\n            /* ill-formed block or already freed pointer */\n            XCP_PRINTF(\"xcpMemFree: invalid or double-freed pointer %p\\n\", ptr);\n            return;\n        }\n\n        /* insert the new free block in the front of the pool */\n        if (poolIdx < XCP_MEM_MAIN_POOLS_NUMBER) {\n            XCP_MUTEX_LOCK(xcpMemLock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n\n            XCP_MUTEX_UNLOCK(xcpMemLock);\n        } \n        else {\n        #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n            /* If lockless support is enabled, the freed memory block is\n               not immediately available for subsequent allocations,\n               until xcpMemReservedPoolFlushFreeMem is invoked */\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].deferredFreeHead;\n\n            if (xcpMemPoolDescriptors[poolIdx].deferredFreeTail == NULL) {\n                /* Let's save a reference to the first block in the pool\n                   that has been freed */\n                xcpMemPoolDescriptors[poolIdx].deferredFreeTail = hd;\n            }\n\n            xcpMemPoolDescriptors[poolIdx].deferredFreeHead = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount);\n        #else\n            XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolIdx].lock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n            XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolIdx].lock);\n        #endif\n        }\n    }\n}\n\n\nXcpErrorCode xcpMemReservedPoolCreate(size_t blockSize, size_t blocksNumber, xcpPoolId_T* poolId)\n{\n    uint8_T poolIdx;\n    uint8_T *currentHead = (uint8_T *) XCP_ALIGNED(xcpMemReservedPoolsChunk);\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n    size_t requestedPoolSize;\n\n    if ((poolId == NULL) || (blockSize == 0) || (blocksNumber == 0)) {\n        XCP_PRINTF(\"xcpMemReservedPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    /* blockSize needs to be a multiple of XCP_MEM_ALIGNMENT in order to align blocks to aligned addresses.\n     * If the size is not a multiple, adjustment is done here.\n     */\n    blockSize = (size_t) XCP_ALIGNED(blockSize);\n\n    requestedPoolSize = blocksNumber * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        if (xcpMemPoolDescriptors[poolIdx].head == XCP_FREE_POOL) {\n            /* The pool is free, let's check if it is big enough */\n            if ((xcpMemPoolDescriptors[poolIdx].poolSize) == 0) {\n                /* The pool has never been allocated before, so this must be the last\n                   usable pool in the list */\n                if (requestedPoolSize <= (XCP_MEM_RESERVED_POOLS_TOTAL_SIZE - xcpMemReservedPoolsChunkUsedBytes)) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                    xcpMemPoolDescriptors[poolIdx].poolSize = requestedPoolSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    xcpMemReservedPoolsChunkUsedBytes += requestedPoolSize;\n\n                    pool = poolIdx;\n                }\n                break; /* No more pools to process, exit from the loop */\n            } else {\n                /* The pool has already been allocated so it can't be re-sized */\n                if (requestedPoolSize <= xcpMemPoolDescriptors[poolIdx].poolSize) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    pool = poolIdx;\n                    break; /* We found what we were looking for, exit from the loop */\n                }\n            }\n        }\n\n        /* Let's continue to see if there are bigger memory areas available */\n        currentHead += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemReservedPoolDestroy(xcpPoolId_T poolId)\n{\n    uint8_T poolIdx;\n    boolean_T isLastPool = true;\n\n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)) {\n        XCP_PRINTF(\"xcpMemReservedPoolDestroy: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* Check if the pool is the last used one */\n    for(poolIdx = (XCP_MEM_MAIN_RESERVED_POOL_NUMBER - 1); poolIdx > poolId; --poolIdx) {\n        if ((xcpMemPoolDescriptors[poolIdx].head != XCP_FREE_POOL) ||\n            (xcpMemPoolDescriptors[poolId].poolSize != 0)) {\n            isLastPool = false;\n            break; /* the pool is not the last, exit from the loop */\n        }\n    }\n\n    /* Reset the pool to the initial state */\n    if (xcpMemPoolDescriptors[poolIdx].head != XCP_FREE_POOL) {\n        XCP_MEMSET(xcpMemPoolDescriptors[poolId].head,  0, xcpMemPoolDescriptors[poolId].poolSize);\n    }\n\n    if (isLastPool) {\n        /* If it's the last pool we can de-allocate the memory */\n        xcpMemReservedPoolsChunkUsedBytes -= xcpMemPoolDescriptors[poolIdx].poolSize;\n        xcpMemPoolDescriptors[poolId].poolSize = 0;\n    }\n\n    xcpMemPoolDescriptors[poolId].head = XCP_FREE_POOL;\n    xcpMemPoolDescriptors[poolId].totalBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].freeBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].blockSize = 0;\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#endif\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpMemCustomPoolCreate(XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler, xcpPoolId_T* poolId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint8_T poolIdx;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n\n    if ((poolId == NULL) || (allocHandler == NULL) || (freeHandler == NULL)) {\n        XCP_PRINTF(\"xcpMemCustomPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for (poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        if (xcpMemCustomPoolDescriptors[poolIdx].allocHandler == NULL && xcpMemCustomPoolDescriptors[poolIdx].freeHandler == NULL) {\n            pool = poolIdx + XCP_MEM_CUSTOM_POOLS_OFFSET;\n            xcpMemCustomPoolDescriptors[poolIdx].allocHandler = allocHandler;\n            xcpMemCustomPoolDescriptors[poolIdx].freeHandler = freeHandler;\n            break;\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemCustomPoolDestroy(xcpPoolId_T poolId)\n{\n    if (poolId < XCP_MEM_CUSTOM_POOLS_OFFSET || poolId >= XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        XCP_PRINTF(\"xcpMemCustomPoolDestroy: invalid poolId\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler = NULL;\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].freeHandler = NULL;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAllocFromPool(xcpPoolId_T poolId, size_t size)\n{\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    /* Check if memory allocation is delegated to a custom handler.\n       For custom memory pools, protection against concurrent execution must be\n       implemented withing the allocation method */\n    if (poolId >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolId < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        if (xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler) {\n            /* Memory must be added explicitly to store the pool ID */\n            poolHead = (XcpMemHeader *) xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler(size + XCP_MEM_POOLID_SIZE);\n            if (!poolHead) {\n                return NULL;\n            }\n            poolHead->poolId = (uint8_T) poolId;\n            return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n        }\n        return NULL;\n    }\n    \n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER) ||\n        (xcpMemPoolDescriptors[poolId].head == XCP_FREE_POOL) ||\n        (xcpMemPoolDescriptors[poolId].blockSize < size)) {\n        /* No memory block of the given size is available from this pool */\n        return NULL;\n    }\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    if (xcpMemPoolDescriptors[poolId].freeBlocksCount > 0) {\n        poolHead = xcpMemPoolDescriptors[poolId].head;\n    }\n\n    if (!poolHead){ /* there are no more free blocks */\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n       XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolId].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolId].freeBlocksCount)--;\n    poolHead->poolId = (uint8_T) poolId;\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n\n}\n\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\nvoid xcpMemReservedPoolFlushFreeMem(xcpPoolId_T poolId)\n{\n    if ((poolId >= XCP_MEM_MAIN_POOLS_NUMBER) &&\n        (poolId < XCP_MEM_MAIN_RESERVED_POOL_NUMBER) &&\n        (xcpMemPoolDescriptors[poolId].deferredFreeTail != NULL)) {\n        /* Let's move the deferred free blocks to the list of free blocks\n           available for subsequent allocations */\n        xcpMemPoolDescriptors[poolId].deferredFreeTail->next = xcpMemPoolDescriptors[poolId].head;\n        xcpMemPoolDescriptors[poolId].head = xcpMemPoolDescriptors[poolId].deferredFreeHead;\n        xcpMemPoolDescriptors[poolId].freeBlocksCount += xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount;\n        xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolId].deferredFreeTail = NULL;\n    }\n}\n#endif\n\n\nXcpErrorCode xcpMemReset(void){\n    XCP_MEMSET(xcpMemMainChunk,          0, sizeof(xcpMemMainChunk));\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    XCP_MEMSET(xcpMemPoolDescriptors,    0, sizeof(xcpMemPoolDescriptors));\n\n    XCP_MEMSET(xcpMemCustomPoolDescriptors, 0, sizeof(xcpMemCustomPoolDescriptors));\n\n    return XCP_SUCCESS;\n}\n\n#ifdef XCP_DEBUG_SUPPORT\n\nvoid xcpMemPrintDiagnostics(void)\n{\n    uint8_T poolIdx;\n    XCP_PRINTF(\"#############################\\n\");\n    XCP_PRINTF(\"             Header size: %7zu B\\n\", XCP_MEM_HEADER_SIZE);\n    XCP_PRINTF(\"             Offset size: %7zu B\\n\", XCP_MEM_POOLID_SIZE);\n    XCP_PRINTF(\"      Main System memory: %7zu B\\n\", XCP_MEM_MAIN_SYSTEM_SIZE);\n    XCP_PRINTF(\"        Main User memory: %7zu B\\n\", XCP_MEM_MAIN_USER_SIZE);\n    XCP_PRINTF(\"       Main Total memory: %7zu B\\n\", XCP_MEM_MAIN_TOTAL_SIZE);\n\n    for(poolIdx = 0 ; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER ; ++poolIdx) {\n        size_t bsThisPool = xcpMemMainBlockSizes[poolIdx];\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        XCP_PRINTF(\"%6zu B blocks: %4zu/%-4zu\\n\", bsThisPool, nbFreeBlocksThisPool, nbBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n    XCP_PRINTF(\"#############################\\n\");\n\n    XCP_PRINTF(\"        Res Pools Number: %7d B\\n\", XCP_MEM_RESERVED_POOLS_NUMBER);\n    XCP_PRINTF(\"  Res Pools Total memory: %7zu B\\n\", XCP_MEM_RESERVED_POOLS_TOTAL_SIZE);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER ; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER ; ++poolIdx) {\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        XCP_PRINTF(\"Pool %3d blocks: %4zu/%-4zu\\n\", poolIdx, nbFreeBlocksThisPool, nbBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n}\n\n#endif\n\n#ifdef XCP_MEM_BYTE_COPY_SUPPORT\n/* xcpMemcpyByte() currently supports byte-wise copy on WORD (HW_AG=2) addressable targets only */\nvoid xcpMemcpyByte(void *pDst, uint8_T dstOffsetBytes, void *pSrc, uint8_T srcOffsetBytes, size_t numOfBytes)\n{\n    uint16_T *dst = (uint16_T *)pDst;\n    uint16_T *src = (uint16_T *)pSrc;\n\n    if (numOfBytes >= 1) {\n        size_t numOfAGUnits = ((numOfBytes + 1) >> 1);\n        \n        if ((dstOffsetBytes == 0) && (srcOffsetBytes == 0)){\n            if (numOfBytes % 2){\n                numOfAGUnits--;\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n            else {\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 0)){\n            uint32_t i = 0;\n            dst[0] &= 0x00ff;\n            dst[0] |= ((src[0] & 0x00ff) << 8);\n            for (i = 1; i < numOfAGUnits; i++){\n                dst[i]  = ((src[i-1] & 0xff00) >> 8);\n                dst[i] |= ((src[i] & 0x00ff) << 8);\n            }\n            if ((numOfBytes % 2) == 0){\n                dst[i] &= 0xff00;\n                dst[i] |= ((src[i-1] & 0xff00) >> 8);\n            }\n        }\n        else if ((dstOffsetBytes == 0) && (srcOffsetBytes == 1)){\n            uint32_t i = 0;\n            dst[0] = ((src[0] & 0xff00) >> 8);\n            if (numOfBytes >= 2) {\n                dst[0] |= ((src[1] & 0x00ff) << 8);\n                for (i = 1; i < numOfAGUnits-1; i++){\n                    dst[i]  = ((src[i] & 0xff00) >> 8);\n                    dst[i] |= ((src[i+1] & 0x00ff) << 8);\n                }\n                if (numOfBytes % 2){\n                    dst[i] &= 0xff00;\n                    dst[i] |= ((src[i] & 0xff00) >> 8);\n                }\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 1)){\n            dst[0] &= 0x00ff;\n            dst[0] |= (src[0] & 0xff00);\n            numOfBytes--;\n            numOfAGUnits--;\n            dst++;\n            src++;\n            XCP_MEMCPY(dst, src, numOfAGUnits);\n            if ((numOfBytes % 2) != 0){\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n        }\n    }\n}\n\n#endif\n"},{"name":"xcp_standard.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_standard.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer standard commands\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_standard_ext.h\"\n#include \"xcp_standard_types.h\"\n\n\n/*****************************************************************************\n    Internal Variables\n******************************************************************************/\nstatic XcpAddress xcpMta = {0,0};   /* MTA and MTA extension in same format as in SET_MTA packet, used by (SHORT)_UPLOAD, (SHORT)_DOWNLOAD */\nstatic uint8_T xcpUploadSize = 0;\n\n\n/*****************************************************************************\n    Internal Utility Functions\n******************************************************************************/\nstatic boolean_T isValidUploadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size < ((maxCtoSize) / addressGranularity));\n}\n\n/** memcpy function used to copy data from MTA address to the packet */\nstatic void xcpMemcpyFromMTA(uint8_T *pktData, uint8_T dstOffsetBytes)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"reading at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T srcOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    srcOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    if (dstOffsetBytes) { pktData--; }\n    xcpMemcpyByte(pktData, dstOffsetBytes, xcpMTARawPointer, srcOffsetBytes, xcpUploadSize);\n}\n#else\n    XCP_UNUSED_PARAM(dstOffsetBytes);\n    XCP_MEMCPY(pktData, xcpMTARawPointer, xcpUploadSize);\n#endif\n\n}\n\n/*****************************************************************************\n    XCP CONNECT\n******************************************************************************/\n#define XCP_NO_RESOURCES  0x00\n\nstatic const uint8_T xcpResourceValue = (\n    XCP_NO_RESOURCES\n#ifdef XCP_DAQ_SUPPORT\n    | XCP_RESOURCE_DAQ_MASK\n#endif\n#ifdef XCP_STIM_SUPPORT\n    | XCP_RESOURCE_STIM_MASK\n#endif\n#ifdef XCP_PGM_SUPPORT\n    | XCP_RESOURCE_PGM_MASK\n#endif\n#ifdef XCP_CALIBRATION_SUPPORT\n    | XCP_RESOURCE_CAL_PAG_MASK\n#endif\n    );\n\nstatic const uint8_T xcpCommModeBaseValue = (\n    (XCP_ADDRESS_GRANULARITY << XCP_COMM_MODE_ADDRESS_GRANULARITY_OFFSET)\n#if (XCP_BYTE_ORDER != 0)\n    | XCP_COMM_MODE_BYTE_ORDER_MASK\n#endif\n#ifdef XCP_BLOCK_MODE_SUPPORT\n    | XCP_COMM_MODE_SLAVE_BLOCK_MODE_MASK\n#endif\n#ifdef XCP_COMM_MODE_INFO_SUPPORT\n    | XCP_COMM_MODE_OPTIONAL_MASK\n#endif\n    );\n\nstatic XcpProtoErrorCode connectInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpConnectCmdPacketFrame *frame = (XcpConnectCmdPacketFrame *) packet;\n    boolean_T ok = false;\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"CONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Validate command inputs */\n    ok = (frame->mode == XCP_CONNECT_MODE_NORMAL) || (frame->mode == XCP_CONNECT_MODE_USER_DEFINED);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n                          (\"CONNECT: invalid mode detected %xH\\n\", frame->mode));\n\n    /* Everything is fine -> updating the Protocol Layer status */\n    XCP_PRINTF(\"CONNECT: entering XCP_CONNECTED status\\n\");\n    xcpStatusSet(XCP_CONNECTED);\n\n    protoErrorCode = XCP_PROTO_SUCCESS;\n    *outputPacketSize = XCP_CONNECT_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\nstatic void connectOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Fill connect response */\n        XcpConnectResPacketFrame *frame = (XcpConnectResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        /* Update resource field */\n        frame->resource = xcpResourceValue;\n\n        /* Update commModeBasic field */\n        frame->commModeBasic = xcpCommModeBaseValue;\n\n        /* Update Max CTO and DTO fields */\n        frame->maxCtoSize = (uint8_T)xcpTransportMaxCtoSize();\n        frame->maxDtoSize = (uint16_T)xcpTransportMaxDtoSize();\n\n        /* Update Protocol and Transport Version fields */\n        frame->xcpProtocolVersion  = XCP_MAJOR_NUMBER(XCP_PROTOCOL_LAYER_VERSION);\n        frame->xcpTransportVersion = XCP_MAJOR_NUMBER(XCP_TRANSPORT_LAYER_VERSION);\n\n        XCP_PRINTF(\"* Resource:          %xH\\n\", frame->resource);\n        XCP_PRINTF(\"* Comm Mode Basic:   %xH\\n\", frame->commModeBasic);\n        XCP_PRINTF(\"* Max CTO size:      %d\\n\",  frame->maxCtoSize);\n        XCP_PRINTF(\"* Max DTO size:      %d\\n\",  frame->maxDtoSize);\n        XCP_PRINTF(\"* Protocol Version:  %d\\n\",  frame->xcpProtocolVersion);\n        XCP_PRINTF(\"* Transport Version: %d\\n\",  frame->xcpTransportVersion);\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP DISCONNECT\n******************************************************************************/\nstatic XcpProtoErrorCode disconnectInputPacketHandler(void   *msgBuffer,\n                                                      size_t  xcpPacketOffset,\n                                                      size_t *outputPacketSize)\n{\n    boolean_T ok = true;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"DISCONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Everything is fine -> proceed with the status update */\n    XCP_PRINTF(\"DISCONNECT: entering XCP_DISCONNECTED status\\n\");\n    xcpStatusSet(XCP_DISCONNECTED);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/*****************************************************************************\n    XCP GET_STATUS\n******************************************************************************/\nstatic XcpProtoErrorCode getStatusInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET STATUS\\n\");\n\n    *outputPacketSize = XCP_GET_STATUS_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getStatusOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetStatusResPacketFrame *frame = (XcpGetStatusResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Status response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID                      = XCP_PID_RES;\n    frame->sessionStatus            = xcpSessionStatusGet();\n    frame->resourceProtectionStatus = xcpResourceProtectionStatusGet();\n    frame->sessionConfigurationId   = xcpSessionConfigurationIdGet();\n\n    XCP_PRINTF(\"* Session Status:              %xH\\n\", frame->sessionStatus);\n    XCP_PRINTF(\"* Resource Protection Status:  %xH\\n\", frame->resourceProtectionStatus);\n    XCP_PRINTF(\"* Session Config Id:           %d\\n\", frame->sessionConfigurationId);\n}\n\n/*****************************************************************************\n    XCP SYNCH\n******************************************************************************/\n#define XCP_SYNC_RES_PACKET_SIZE_IN_BYTES 2\n\nstatic XcpProtoErrorCode synchInputPacketHandler(void   *msgBuffer,\n                                                 size_t  xcpPacketOffset,\n                                                 size_t *outputPacketSize)\n{\n    boolean_T locked = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"SYNCH\\n\");\n\n    /* Make sure that no DAQ list is currently\n       in the process of sending packets */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        /* Re-synchronizing the transport layer, by flushing the TX packets currently\n           in the TX FIFO and restarting the frame handler */\n        xcpTransportResynch();\n\n        xcpDaqUnlock();\n    }\n\n    *outputPacketSize = XCP_SYNC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SYNCH;\n}\n\n\n#if XCP_SET_MTA_ENABLE == 1\n/*****************************************************************************\n    XCP SET_MTA\n******************************************************************************/\n    static XcpProtoErrorCode setMTAInputPacketHandler(void  *msgBuffer, \n        size_t  xcpPacketOffset, \n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpSetMTACmdPacketFrame *frame = (XcpSetMTACmdPacketFrame *)packet;\n        boolean_T ok = false;\n\n        /* Check if the memory address is valid and set the MTA pointer */\n        ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SET_MTA: invalid address\\n\"));\n        \n        XCP_PRINTF(\"SET_MTA: setting MTA value to %x and extension %x\\n\", frame->address, frame->addressExtension);    \n\n        *outputPacketSize = sizeof(XcpGenericResPacketFrame);\n\n        return protoErrorCode;\n    }\n\n/*****************************************************************************\n    XCP UPLOAD\n******************************************************************************/\n    static XcpProtoErrorCode uploadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpUploadCmdPacketFrame *frame = (XcpUploadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidUploadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n        \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF(xcpMTARawPointer == 0, XCP_PROTO_ACCESS_DENIED,\n            (\"UPLOAD: invalid address\\n\"));\n        \n        xcpUploadSize = (uint8_T)frame->size;\n        *outputPacketSize = XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n        return protoErrorCode;\n    }\n\n    \n    static void uploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize) {\n        \n        if (inputCode == XCP_PROTO_SUCCESS) {\n\n            /* Fill Upload response */\n            uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n            XcpUploadResPacketFrame *frame = (XcpUploadResPacketFrame *)packet;\n            XCP_MEMSET(frame, 0, sizeof(*frame));\n            frame->PID = XCP_PID_RES;\n\n            if ((xcpMTARawPointer != NULL) &&\n                (packetSize == (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize)))\n                ) {\n                uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n                uint8_T dstOffsetBytes = (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n                XCP_PRINTF(\"UPLOAD: \");\n                \n                /* Copy the memory content to the packet data area */\n                xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n                /* Post-increment MTA by the frame size in address granularity units */\n                xcpStandardIncrementMta(xcpUploadSize);\n                xcpUploadSize = 0;\n            }\n            else {\n                /* This is a software error and it should never happen */\n                XCP_PRINTF(\"UPLOAD: invalid data detected\\n\");\n            }\n        }\n        else {\n            genericOutputPacketHandler(inputCode, packet, packetSize);\n        }\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1  */\n\n\n/*****************************************************************************\n    XCP SHORT_UPLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortUploadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortUploadCmdPacketFrame *frame = (XcpShortUploadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidUploadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_UPLOAD: invalid address\\n\"));\n\n    xcpUploadSize = (uint8_T)frame->size;\n\n    *outputPacketSize = XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n    return protoErrorCode;\n}\n\nstatic void shortUploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{    \n    if (inputCode == XCP_PROTO_SUCCESS) {\n\n        /* Fill Short Upload response */\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n        XcpShortUploadResPacketFrame *frame = (XcpShortUploadResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        if ((xcpMTARawPointer != NULL) &&\n            (packetSize == XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize) )\n           ) {\n            uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n            uint8_T dstOffsetBytes = (XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n            XCP_PRINTF(\"SHORT_UPLOAD: \");\n\n            /* Copy the memory content to the packet data area */\n            xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n            /* Post-increment MTA by the frame size in address granularity units */\n            xcpStandardIncrementMta(xcpUploadSize);\n\n            xcpUploadSize = 0;\n        }\n        else {\n            /* This is a software error and it should never happen */\n            XCP_PRINTF(\"SHORT_UPLOAD: invalid data detected\\n\");\n        }\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers standardSupportedRxPacket[] =\n{\n    { XCP_PID_CONNECT,      connectInputPacketHandler,     connectOutputPacketHandler },\n    { XCP_PID_DISCONNECT,   disconnectInputPacketHandler,  genericOutputPacketHandler },\n    { XCP_PID_GET_STATUS,   getStatusInputPacketHandler,   getStatusOutputPacketHandler },\n    { XCP_PID_SYNCH,        synchInputPacketHandler,       genericOutputPacketHandler },\n#if XCP_SET_MTA_ENABLE == 1  \n    { XCP_PID_SET_MTA,      setMTAInputPacketHandler,      genericOutputPacketHandler },\n    { XCP_PID_UPLOAD,       uploadInputPacketHandler,      uploadOutputPacketHandler},\n#endif\n    { XCP_PID_SHORT_UPLOAD, shortUploadInputPacketHandler, shortUploadOutputPacketHandler }\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic standard commands\n******************************************************************************/\n\n/* Default Standard Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, standardSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(standardSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpStandardInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       standard commands */\n    xcpStandardSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of Standard commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpStandardExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpStandardGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpStandardSetPacketLookup(XcpPacketLookupFunction getPacket)\n{\n    packetLookup = getPacket;\n}\n\n\nvoid xcpStandardReset(void)\n{\n    /* reset support for the extended list of Standard commands */\n    xcpStandardExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpStandardSetPacketLookup(NULL);\n}\n\n\nuint8_T* xcpStandardGetAddressFromMta(void) {\n    return XCP_ADDRESS_GET(xcpMta.addressExtension, xcpMta.address);\n}\n\n\nboolean_T xcpStandardSetMta(uint32_T address, uint8_T addressExtension) {\n    if ((addressExtension == 0) && (address == 0)) {\n        return false;\n    } else {\n        xcpMta.address = address;\n        xcpMta.addressExtension = addressExtension;\n        return true;\n    }\n}\n\n\nvoid xcpStandardGetMta(uint32_T *address, uint8_T *addressExtension) {\n    *address = xcpMta.address;\n    *addressExtension = xcpMta.addressExtension;\n}\n\n\nvoid xcpStandardIncrementMta(uint8_T incr) {\n    xcpMta.address += incr;\n}\n\n\n#ifndef XCP_STANDARD_EXTENDED_SUPPORT\n\nvoid xcpStandardExtendedInit(void) {}\nvoid xcpStandardExtendedReset(void) {}\n\n#endif\n"},{"name":"xcp_transport.c","type":"source","group":"legacy","path":"C:\\Users\\win\\Desktop\\GitHub\\Modelling\\Modelling\\07_Interleaved_Buck\\DCDC_Buck_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\xcp\\src\\target\\slave\\transport\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_transport.c\n*\n* Abstract:\n*  Implementation of XCP Transport Layer.\n*  The file contains the common part that is responsible for the handling\n*  of Tx/Rx buffers and relies on the Xcp Driver and Xcp Frame Handler layers\n*  for sending and receiving data to/from the supported transport layer specification\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_transport_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_fifo.h\"\n#include \"xcp_mem.h\"\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n#include \"xcp_daq_types.h\"\n#endif\n\n/** Number of supported Tx queues */\n\n#define XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER     2\n\n/** Number of supported Rx queues */\n#define XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER  1\n\n\n/* In this Transport Layer implementation, the memory buffer associated with a generic\n   XCP message has the following format:\n\n   --------------      +---->  --------------\n  | xcpFifoEntry | ----+      | xcpFifoEntry |\n   --------------              --------------\n  | XCP Header   |            | XCP Header   |\n   --------------              --------------\n  | XCP Packet   |            | XCP Packet   |\n   --------------              --------------\n\n  xcpFifoEntry is an internal data structure used to implement a FIFO through a single linked list\n*/\n\n\n\n/* Transmit FIFOs */\nstatic struct xcpFifo txFifo[XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(txLock);\n\n/* Receive FIFOs */\nstatic struct xcpFifo rxFifo[XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(rxLock);\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER <= 0\n#error  \"XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT requires a XCP_MEM_DAQ_RESERVED_POOLS_NUMBER value greater than 0\"\n#endif\n\nstatic struct xcpFifo daqDeferredTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic struct xcpFifo daqTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic boolean_T      daqTxRequest[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic uint16_T       lastDaqIdTx = 0xFFFF;\n\n#endif\n\n\n/* true if the Transport Layer has been successfully initialized */\nstatic boolean_T  initialized = false;\n\n/* ID of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n\n#ifdef XCP_DEBUG_SUPPORT\nstatic const char *xcpTransportDiagDataString[XCP_TRANSPORT_COUNTERS_NUMBER] = {\n    \"XCP_TRANSPORT_INIT_COUNTER               \",\n    \"XCP_TRANSPORT_TX_COUNTER                 \",\n    \"XCP_TRANSPORT_TX_PACKET_SET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_GET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_COUNTER                 \",\n    \"XCP_TRANSPORT_RESTART_COUNTER            \",\n    \"XCP_TRANSPORT_RESYNCH_COUNTER            \",\n    \"XCP_TRANSPORT_RESET_COUNTER              \",\n    \"XCP_TRANSPORT_MEM_INIT_ERROR             \",\n    \"XCP_TRANSPORT_MEM_RESET_ERROR            \",\n    \"XCP_TRANSPORT_FRAME_INIT_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR     \",\n    \"XCP_TRANSPORT_FRAME_SEND_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_RECV_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR \",\n    \"XCP_TRANSPORT_FRAME_RESTART_ERROR        \",\n    \"XCP_TRANSPORT_FRAME_RESET_ERROR          \",\n    \"XCP_TRANSPORT_TX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_TX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_TX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_TX_IS_EMPTY_COUNTER        \",\n    \"XCP_TRANSPORT_RX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_RX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_RX_IS_EMPTY_COUNTER        \"\n};\n\nstatic XcpTransportDiagnostic xcpTransportDiagnostic;\n\n\nvoid xcpTransportDiagnosticReset(void)\n{\n    XCP_MEMSET(&xcpTransportDiagnostic, 0, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticGet(XcpTransportDiagnostic *diag)\n{\n    XCP_MEMCPY(diag, &xcpTransportDiagnostic, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticPrint(const XcpTransportDiagnostic *diag)\n{\n    if (diag != NULL) {\n        int i = 0;\n        for (i = 0; i < XCP_TRANSPORT_COUNTERS_NUMBER; i++) {\n            XCP_PRINTF(\"%s = %lu\\n\", xcpTransportDiagDataString[i], (unsigned long) xcpTransportDiagnostic.data[i]);\n        }\n    }\n}\n\n#define XCP_DIAG_UPDATE(counterId)     xcpTransportDiagnostic.data[counterId]++\n\n#else\n\n#define XCP_DIAG_UPDATE(counterId) \n\n#endif\n\n/* Empty the TX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyTxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint16_T i = 0;\n\n    XCP_MUTEX_LOCK(txLock);\n\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&txFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&daqTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        do {\n            xcpFifoDequeue(&daqDeferredTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n}\n\n\n/* Empty the RX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyRxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T i = 0;\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&rxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(rxLock);\n}\n\n\nXcpErrorCode xcpTransportInit(int argc, void * argv[])\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint16_T i = 0;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpTransportInit: transport layer already initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_INIT_COUNTER);\n\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&txFifo[i]);\n    }\n    XCP_MUTEX_INIT(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoInit(&daqTxFifo[i]);\n        xcpFifoInit(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&rxFifo[i]);\n    }\n    XCP_MUTEX_INIT(rxLock);\n\n    /* Initialize XCP memory allocator */\n    errorCode = xcpMemInit();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during memory allocator initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n        return errorCode;\n    }\n\n    {\n        /* Allocate the memory pool reserved for the allocation\n           of CTO, EV and SERV XCP Packets */\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        size_t maxBufferSize = xcpTransportMsgBufferSize(maxCtoSize, XCP_CTO);\n\n        errorCode = xcpMemReservedPoolCreate(maxBufferSize, XCP_MEM_CTO_RESERVED_POOL_BLOCKS_NUMBER,\n                                             &xcpCtoReservedMemPoolId);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_PRINTF(\"xcpTransportInit: error (%d) detected during allocation of reserved memory pool\\n\", errorCode);\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n            return errorCode;\n        }\n\n        xcpFrameSetCtoReservedMemPoolId(xcpCtoReservedMemPoolId);\n    }\n\n    /* Initialize XCP Frame handler */\n    errorCode = xcpFrameInit(argc, argv);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during frame handler initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_INIT_ERROR);\n        return errorCode;\n    }\n\n    initialized = true;\n\n    return errorCode;\n}\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n\tuint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    boolean_T ready = true;\n    /* In the lockless implementation we enqueue data only\n       if the previous transmission has been completed */\n    if ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE) &&\n        (daqId <  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        ready = !daqTxRequest[daqId];\n    }\n\n    return ready;\n}\n\n\n/** If lockless streaming is enabled, trigger the transmission of\n    packets previously enqueued (by invoking xcpTransportTxPacketSet.\n    The function returns XCP_BUSY if the TX request is already\n    in progress */\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if ((queueType != XCP_TRANSPORT_TX_DEFAULT_QUEUE) ||\n        (daqId >= XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        return XCP_INV_ARG;\n    }\n\n    if (!daqTxRequest[daqId]) {\n        if (!xcpFifoEmpty(daqDeferredTxFifo)) {\n            /* If the transmission of any packets was deferred \n               from previous run, we need to enqueue them at the\n               head of the daqTxFifo, as they need to be sent first */\n            xcpFifoSpliceHead(daqTxFifo, daqDeferredTxFifo);\n        }\n\n        XCP_MEM_BARRIER();\n        daqTxRequest[daqId] = true;\n    } else {\n        errorCode = XCP_BUSY;\n    }\n\n    return errorCode;\n}\n\n#else\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    /* In the standard (mutex-based) implementation we can always enqueue\n       new packets and therefore TX is always ready*/\n    return true;\n}\n\n\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    /* In the standard (mutex-based) implementation the transmission\n       is always in progress, as long as there are samples in the TX fifo.\n       For this reasons this method has no effect in this case */\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    return XCP_SUCCESS;\n}\n\n#endif\n\n\nXcpErrorCode xcpTransportTxPacketSet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the TX queue the packet has to be sent to */\n    uint16_T daqId,       /**< [in] id of the DAQ list the packet refers to */\n    void  *msgBuffer,       /* [in] pointer to the buffer containing the full XCP message */\n    size_t msgBufferSize,   /* [in] size (in AG units) of the buffer */\n    size_t xcpPktOffset,    /* [in] offset (in AG units) where the actual XCP packet content has been copied (within xcpMsg buffer)  */\n    size_t xcpPktSize       /* [in] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameMaxSize = 0;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE)   ||\n                            (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE)) &&\n                            (daqId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n#else\n    XCP_UNUSED_PARAM(daqId);\n#endif\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType != XCP_TRANSPORT_DEFERRED_TX_QUEUE) && \n                 ((queueType < 0) || (queueType >= XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER)), \n                 XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(xcpPktOffset != xcpTransportPacketOffset(), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet offset\\n\");\n    XCP_ERROR_IF(xcpPktSize == 0, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet size\\n\");\n    XCP_ERROR_IF(msgBufferSize < (xcpPktOffset + XCP_IN_HW_AG(xcpPktSize)), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBufferSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTxPacketSet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_SET_COUNTER);\n\n    msgBufferHeader = (struct xcpFifoEntry *) msgBuffer;\n    msgFrame = (uint8_T *)msgBuffer + sizeof(struct xcpFifoEntry);\n    msgFrameMaxSize = msgBufferSize - sizeof(struct xcpFifoEntry);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    /* Now fill the XCP frame content \n       @note the lock is used to protect the txFifo data structures from concurrent execution */\n    XCP_MUTEX_LOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    errorCode = xcpFrameCreateMsg(msgFrame, msgFrameMaxSize, &msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportTxPacketSet: xcpFrameCreateMsg failure detected (%d)\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR);\n        goto error;\n    }\n\n    msgBufferHeader->msgFrameSize = msgFrameSize;\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n        /* Now that the packet has been created, we can add it to the txFifo for transmission */\n        xcpFifoEnqueue(&txFifo[queueType], msgBufferHeader);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    } else {\n        if (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE) {\n            xcpFifoEnqueue(&daqDeferredTxFifo[daqId], msgBufferHeader);\n        } else {\n         xcpFifoEnqueue(&daqTxFifo[daqId], msgBufferHeader);\n        }\n    }\n#endif\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_IN_COUNTER);\n\nerror:\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportTx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T queueType = XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = false;\n#endif\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_COUNTER);\n\n    XCP_MUTEX_LOCK(txLock);\n    /* Extract the message from the Fifos, starting from the highest priority */\n    xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (msgBufferHeader == NULL) {\n        uint16_T i = 0;\n        /* If the highest priority is empty, check if one of the DAQ-specific ones\n           has a pending request */\n        for (i = 0; (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) && !locklessTx; i++) {\n            lastDaqIdTx = (lastDaqIdTx + 1) %  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER;\n            if (daqTxRequest[lastDaqIdTx]) {\n                xcpFifoDequeue(&daqTxFifo[lastDaqIdTx], &msgBufferHeader);\n                if (msgBufferHeader == NULL) {\n                    /* if no data are available, we can acknowledge the request\n                       straight away */\n                    daqTxRequest[lastDaqIdTx] = false;\n                } else {\n                    locklessTx = true;\n                }\n            }\n        }\n    }\n#endif\n    if (msgBufferHeader == NULL) {\n        /* If the highest priority is empty, and no DAQ packets are available\n           try the default queue */\n        XCP_MUTEX_LOCK(txLock);\n\n        queueType = XCP_TRANSPORT_TX_DEFAULT_QUEUE;\n        xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n        XCP_MUTEX_UNLOCK(txLock);\n    }\n\n    if (msgBufferHeader != NULL) {\n        msgFrameSize = msgBufferHeader->msgFrameSize;\n\n        /* Trying to send one XCP message via the frame handler\n           @note The frame handler will be responsible for releasing\n                 the message buffer if the data has been successfully sent\n                 (return code XCP_SUCCESS).\n                 If not, the memory area won't be freed and the message\n                 will need to go back to the FIFO. */\n        errorCode = xcpFrameMsgSend(msgBufferHeader, sizeof(struct xcpFifoEntry), msgFrameSize);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_SEND_ERROR);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (!locklessTx) {\n#endif\n            XCP_MUTEX_LOCK(txLock);\n\n            xcpFifoEnqueueHead(&txFifo[queueType], msgBufferHeader);\n\n            XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            } else {\n                xcpFifoEnqueueHead(&daqTxFifo[lastDaqIdTx], msgBufferHeader);\n            }\n#endif\n        } else {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_OUT_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (locklessTx && xcpFifoEmpty(&daqTxFifo[lastDaqIdTx])) {\n                /* All packets in the queue have been sent,\n                   the request can be acknowledged */\n                XCP_MEM_BARRIER();\n                daqTxRequest[lastDaqIdTx] = false;\n            }\n#endif\n        }\n    } else {\n        errorCode = XCP_EMPTY;\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_IS_EMPTY_COUNTER);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Make sure that the blocks associated to the CTO reserved memory\n       pool are made available for subsequent allocations */\n    xcpMemReservedPoolFlushFreeMem(xcpCtoReservedMemPoolId);\n#endif\n\n    /* Trying to receive one XCP message via the frame handler\n       @note The frame handler is also responsible for allocating the\n             memory area and it is no longer responsible for the ownership\n             of the memory if the function has been successfully executed\n             (error code XCP_SUCCESS)\n             If there are no messages available, the return code is XCP_EMPTY */\n    errorCode = xcpFrameMsgRecv((void**) &msgBufferHeader, sizeof(struct xcpFifoEntry), &msgFrameSize);\n\n    if (errorCode == XCP_SUCCESS) {\n        /* Add the message to the Fifo */\n        msgBufferHeader->msgFrameSize = msgFrameSize;\n\n        XCP_MUTEX_LOCK(rxLock);\n\n        /* Only one RX queue available */\n        xcpFifoEnqueue(&rxFifo[XCP_TRANSPORT_RX_DEFAULT_QUEUE], msgBufferHeader);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_IN_COUNTER);\n\n        XCP_MUTEX_UNLOCK(rxLock);\n    } else if (errorCode == XCP_EMPTY) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_IS_EMPTY_COUNTER);\n    } else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RECV_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRxPacketGet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the RX queue the packet has to be received from */\n    void  **msgBuffer,     /* [out] pointer to the buffer containing the full XCP message that has been extracted */\n    size_t *msgBufferSize, /* [out] size (in AG units) of the buffer */\n    size_t *xcpPktOffset,  /* [out] offset (in AG units) of the XCP packet within the message buffer */\n    size_t *xcpPktSize     /* [out] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType < 0) || (queueType >= XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER), XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgBufferSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBufferSize pointer\\n\");\n    XCP_ERROR_IF(xcpPktOffset == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktOffset pointer\\n\");\n    XCP_ERROR_IF(xcpPktSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRxPacketGet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_GET_COUNTER);\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    xcpFifoDequeue(&rxFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(rxLock);\n\n    if (msgBufferHeader == NULL) {\n        return XCP_EMPTY; /* No messages in the FIFO */\n    }\n    else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_OUT_COUNTER);\n    }\n\n    msgFrame = (uint8_T *) msgBufferHeader + sizeof(struct xcpFifoEntry);\n    msgFrameSize = msgBufferHeader->msgFrameSize;\n\n    /* Extract a new XCP packet from the XCP message, and carry out all the relevant checks in the frame format */\n    errorCode = xcpFrameExtractPacket(msgFrame, msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR);\n    }\n\n    *msgBuffer = msgBufferHeader;\n    *msgBufferSize = msgBufferHeader->msgFrameSize + sizeof(struct xcpFifoEntry);\n    *xcpPktOffset = xcpTransportPacketOffset();\n\n    return errorCode;\n}\n\n\nsize_t xcpTransportPacketOffset(void)\n{\n    size_t size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n\n    return size;\n}\n\n/* xcpPacketSize is the number of octets in the XCP Packet\n * Return value the buffer size in terms of target memory granularity needed to contain this packet.\n * On 32-bit address granularity processor, a packet of 6 contiguous BYTEs, we require 2 memory\n *  locations to contain it.\n */\nsize_t xcpTransportMsgBufferSize(size_t xcpPacketSize, XcpPacketType pktType)\n{\n    size_t size = 0;\n    size_t maxPacketSize = 0;\n    \n    maxPacketSize = (pktType == XCP_CTO) ? xcpFrameMaxCtoSize() : xcpFrameMaxDtoSize();\n\n    if (xcpPacketSize > maxPacketSize) {\n        XCP_PRINTF(\"xcpTransportMsgSize: invalid xcpPacketSize\\n\");\n        return 0;\n    }\n\n    size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n    size += XCP_IN_HW_AG(xcpPacketSize);\n    size += XCP_IN_HW_AG(xcpFrameTailSize());\n\n    return size;\n}\n\n\nsize_t xcpTransportMaxDtoSize(void)\n{\n    return xcpFrameMaxDtoSize();\n}\n\n\nsize_t xcpTransportMaxCtoSize(void)\n{\n    return xcpFrameMaxCtoSize();\n}\n\n\nXcpErrorCode xcpTransportRestart(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESTART_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX and RX fifos */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportResynch(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESYNCH_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX FIFO */\n    xcpTransportEmptyTxFifo();\n\n    return errorCode;\n}\n\n\nxcpPoolId_T xcpTransportCtoReservedMemPoolId(void)\n{\n    return xcpCtoReservedMemPoolId;\n}\n\n\nXcpErrorCode xcpTransportReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpTransportQueueType_T i = 0;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpTransportReset: transport layer already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESET_COUNTER);\n\n    /* Reset XCP Frame handler */\n    errorCode = xcpFrameReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during frame handler reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Before resetting the txFifo and rxFifo, all the message buffers still enqueued need to be freed\n    as the ownership of the memory area was explicitly given to the Transport Layer */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    /* Destroy the reserved memory pool */\n    xcpMemReservedPoolDestroy(xcpCtoReservedMemPoolId);\n\n    /* Reset XCP memory allocator */\n    errorCode = xcpMemReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during memory allocator reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Now we can reset Tx and Rx Fifos */\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&txFifo[i]);\n    }\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&rxFifo[i]);\n    }\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoReset(&daqTxFifo[i]);\n        xcpFifoReset(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    initialized = false;\n\n    return errorCode;\n}\n\n\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};